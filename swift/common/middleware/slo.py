begin_unit
comment|'# Copyright (c) 2013 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
string|'"""\nMiddleware that will provide Static Large Object (SLO) support.\n\nThis feature is very similar to Dynamic Large Object (DLO) support in that\nit allows the user to upload many objects concurrently and afterwards\ndownload them as a single object. It is different in that it does not rely\non eventually consistent container listings to do so. Instead, a user\ndefined manifest of the object segments is used.\n\n----------------------\nUploading the Manifest\n----------------------\n\nAfter the user has uploaded the objects to be concatenated, a manifest is\nuploaded. The request must be a PUT with the query parameter::\n\n    ?multipart-manifest=put\n\nThe body of this request will be an ordered list of segment descriptions in\nJSON format. The data to be supplied for each segment is:\n\n=========== ========================================================\nKey         Description\n=========== ========================================================\npath        the path to the segment object (not including account)\n            /container/object_name\netag        the ETag given back when the segment object was PUT,\n            or null\nsize_bytes  the size of the complete segment object in\n            bytes, or null\nrange       (optional) the (inclusive) range within the object to\n            use as a segment. If omitted, the entire object is used.\n=========== ========================================================\n\nThe format of the list will be:\n\n  .. code::\n\n    [{"path": "/cont/object",\n      "etag": "etagoftheobjectsegment",\n      "size_bytes": 10485760,\n      "range": "1048576-2097151"}, ...]\n\nThe number of object segments is limited to a configurable amount, default\n1000. Each segment, except for the final one, must be at least 1 megabyte\n(configurable). On upload, the middleware will head every segment passed in to\nverify:\n\n 1. the segment exists (i.e. the HEAD was successful);\n 2. the segment meets minimum size requirements (if not the last segment);\n 3. if the user provided a non-null etag, the etag matches;\n 4. if the user provided a non-null size_bytes, the size_bytes matches; and\n 5. if the user provided a range, it is a singular, syntactically correct range\n    that is satisfiable given the size of the object.\n\nNote that the etag and size_bytes keys are still required; this acts as a guard\nagainst user errors such as typos. If any of the objects fail to verify (not\nfound, size/etag mismatch, below minimum size, invalid range) then the user\nwill receive a 4xx error response. If everything does match, the user will\nreceive a 2xx response and the SLO object is ready for downloading.\n\nBehind the scenes, on success, a json manifest generated from the user input is\nsent to object servers with an extra "X-Static-Large-Object: True" header\nand a modified Content-Type. The items in this manifest will include the etag\nand size_bytes for each segment, regardless of whether the client specified\nthem for verification. The parameter: swift_bytes=$total_size will be\nappended to the existing Content-Type, where total_size is the sum of all\nthe included segments\' size_bytes. This extra parameter will be hidden from\nthe user.\n\nManifest files can reference objects in separate containers, which will improve\nconcurrent upload speed. Objects can be referenced by multiple manifests. The\nsegments of a SLO manifest can even be other SLO manifests. Treat them as any\nother object i.e., use the Etag and Content-Length given on the PUT of the\nsub-SLO in the manifest to the parent SLO.\n\n-------------------\nRange Specification\n-------------------\n\nUsers now have the ability to specify ranges for SLO segments.\nUsers can now include an optional \'range\' field in segment descriptions\nto specify which bytes from the underlying object should be used for the\nsegment data. Only one range may be specified per segment.\n\n  .. note::\n\n     The \'etag\' and \'size_bytes\' fields still describe the backing object as a\n     whole.\n\nIf a user uploads this manifest:\n\n  .. code::\n\n     [{"path": "/con/obj_seg_1", "etag": null, "size_bytes": 2097152,\n       "range": "0-1048576"},\n      {"path": "/con/obj_seg_2", "etag": null, "size_bytes": 2097152,\n       "range": "512-1550000"},\n      {"path": "/con/obj_seg_1", "etag": null, "size_bytes": 2097152,\n       "range": "-2048"}]\n\nThe segment will consist of the first 1048576 bytes of /con/obj_seg_1,\nfollowed by bytes 513 through 1550000 (inclusive) of /con/obj_seg_2, and\nfinally bytes 2095104 through 2097152 (i.e., the last 2048 bytes) of\n/con/obj_seg_1.\n\n  .. note::\n\n     The minimum sized range is min_segment_size, which by\n     default is 1048576 (1MB).\n\n\n-------------------------\nRetrieving a Large Object\n-------------------------\n\nA GET request to the manifest object will return the concatenation of the\nobjects from the manifest much like DLO. If any of the segments from the\nmanifest are not found or their Etag/Content Length have changed since upload,\nthe connection will drop. In this case a 409 Conflict will be logged in the\nproxy logs and the user will receive incomplete results. Note that this will be\nenforced regardless of whether the user perfomed per-segment validation during\nupload.\n\nThe headers from this GET or HEAD request will return the metadata attached\nto the manifest object itself with some exceptions::\n\n    Content-Length: the total size of the SLO (the sum of the sizes of\n                    the segments in the manifest)\n    X-Static-Large-Object: True\n    Etag: the etag of the SLO (generated the same way as DLO)\n\nA GET request with the query parameter::\n\n    ?multipart-manifest=get\n\nWill return the actual manifest file itself. This is generated json and does\nnot match the data sent from the original multipart-manifest=put. This call\'s\nmain purpose is for debugging.\n\nWhen the manifest object is uploaded you are more or less guaranteed that\nevery segment in the manifest exists and matched the specifications.\nHowever, there is nothing that prevents the user from breaking the\nSLO download by deleting/replacing a segment referenced in the manifest. It is\nleft to the user to use caution in handling the segments.\n\n-----------------------\nDeleting a Large Object\n-----------------------\n\nA DELETE request will just delete the manifest object itself.\n\nA DELETE with a query parameter::\n\n    ?multipart-manifest=delete\n\nwill delete all the segments referenced in the manifest and then the manifest\nitself. The failure response will be similar to the bulk delete middleware.\n\n------------------------\nModifying a Large Object\n------------------------\n\nPUTs / POSTs will work as expected, PUTs will just overwrite the manifest\nobject for example.\n\n------------------\nContainer Listings\n------------------\n\nIn a container listing the size listed for SLO manifest objects will be the\ntotal_size of the concatenated segments in the manifest. The overall\nX-Container-Bytes-Used for the container (and subsequently for the account)\nwill not reflect total_size of the manifest but the actual size of the json\ndata stored. The reason for this somewhat confusing discrepancy is we want the\ncontainer listing to reflect the size of the manifest object when it is\ndownloaded. We do not, however, want to count the bytes-used twice (for both\nthe manifest and the segments it\'s referring to) in the container and account\nmetadata which can be used for stats purposes.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'six'
op|'.'
name|'moves'
name|'import'
name|'range'
newline|'\n'
nl|'\n'
name|'from'
name|'datetime'
name|'import'
name|'datetime'
newline|'\n'
name|'import'
name|'mimetypes'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'six'
name|'import'
name|'BytesIO'
newline|'\n'
name|'from'
name|'hashlib'
name|'import'
name|'md5'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'ListingIterError'
op|','
name|'SegmentError'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'swob'
name|'import'
name|'Request'
op|','
name|'HTTPBadRequest'
op|','
name|'HTTPServerError'
op|','
name|'HTTPMethodNotAllowed'
op|','
name|'HTTPRequestEntityTooLarge'
op|','
name|'HTTPLengthRequired'
op|','
name|'HTTPOk'
op|','
name|'HTTPPreconditionFailed'
op|','
name|'HTTPException'
op|','
name|'HTTPNotFound'
op|','
name|'HTTPUnauthorized'
op|','
name|'HTTPConflict'
op|','
name|'HTTPRequestedRangeNotSatisfiable'
op|','
name|'Response'
op|','
name|'Range'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'json'
op|','
name|'get_logger'
op|','
name|'config_true_value'
op|','
name|'get_valid_utf8_str'
op|','
name|'override_bytes_from_content_type'
op|','
name|'split_path'
op|','
name|'register_swift_info'
op|','
name|'RateLimitedIterator'
op|','
name|'quote'
op|','
name|'close_if_possible'
op|','
name|'closing_if_possible'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'request_helpers'
name|'import'
name|'SegmentedIterable'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'constraints'
name|'import'
name|'check_utf8'
op|','
name|'MAX_BUFFERED_SLO_SEGMENTS'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'http'
name|'import'
name|'HTTP_NOT_FOUND'
op|','
name|'HTTP_UNAUTHORIZED'
op|','
name|'is_success'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'wsgi'
name|'import'
name|'WSGIContext'
op|','
name|'make_subrequest'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'middleware'
op|'.'
name|'bulk'
name|'import'
name|'get_response_body'
op|','
name|'ACCEPTABLE_FORMATS'
op|','
name|'Bulk'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|DEFAULT_MIN_SEGMENT_SIZE
name|'DEFAULT_MIN_SEGMENT_SIZE'
op|'='
number|'1024'
op|'*'
number|'1024'
comment|'# 1 MiB'
newline|'\n'
DECL|variable|DEFAULT_MAX_MANIFEST_SEGMENTS
name|'DEFAULT_MAX_MANIFEST_SEGMENTS'
op|'='
number|'1000'
newline|'\n'
DECL|variable|DEFAULT_MAX_MANIFEST_SIZE
name|'DEFAULT_MAX_MANIFEST_SIZE'
op|'='
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'2'
comment|'# 2 MiB'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|REQUIRED_SLO_KEYS
name|'REQUIRED_SLO_KEYS'
op|'='
name|'set'
op|'('
op|'['
string|"'path'"
op|','
string|"'etag'"
op|','
string|"'size_bytes'"
op|']'
op|')'
newline|'\n'
DECL|variable|OPTIONAL_SLO_KEYS
name|'OPTIONAL_SLO_KEYS'
op|'='
name|'set'
op|'('
op|'['
string|"'range'"
op|']'
op|')'
newline|'\n'
DECL|variable|ALLOWED_SLO_KEYS
name|'ALLOWED_SLO_KEYS'
op|'='
name|'REQUIRED_SLO_KEYS'
op|'|'
name|'OPTIONAL_SLO_KEYS'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_and_validate_input
name|'def'
name|'parse_and_validate_input'
op|'('
name|'req_body'
op|','
name|'req_path'
op|','
name|'min_segment_size'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a request body, parses it and returns a list of dictionaries.\n\n    The output structure is nearly the same as the input structure, but it\n    is not an exact copy. Given a valid input dictionary `d_in`, its\n    corresponding output dictionary `d_out` will be as follows:\n\n      * d_out[\'etag\'] == d_in[\'etag\']\n\n      * d_out[\'path\'] == d_in[\'path\']\n\n      * d_in[\'size_bytes\'] can be a string ("12") or an integer (12), but\n        d_out[\'size_bytes\'] is an integer.\n\n      * (optional) d_in[\'range\'] is a string of the form "M-N", "M-", or\n        "-N", where M and N are non-negative integers. d_out[\'range\'] is the\n        corresponding swob.Range object. If d_in does not have a key\n        \'range\', neither will d_out.\n\n    :raises: HTTPException on parse errors or semantic errors (e.g. bogus\n        JSON structure, syntactically invalid ranges)\n\n    :returns: a list of dictionaries on success\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'parsed_data'
op|'='
name|'json'
op|'.'
name|'loads'
op|'('
name|'req_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'HTTPBadRequest'
op|'('
string|'"Manifest must be valid JSON.\\n"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'parsed_data'
op|','
name|'list'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'HTTPBadRequest'
op|'('
string|'"Manifest must be a list.\\n"'
op|')'
newline|'\n'
nl|'\n'
comment|"# If we got here, req_path refers to an object, so this won't ever raise"
nl|'\n'
comment|'# ValueError.'
nl|'\n'
dedent|''
name|'vrs'
op|','
name|'account'
op|','
name|'_junk'
op|'='
name|'split_path'
op|'('
name|'req_path'
op|','
number|'3'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'errors'
op|'='
op|'['
op|']'
newline|'\n'
name|'num_segs'
op|'='
name|'len'
op|'('
name|'parsed_data'
op|')'
newline|'\n'
name|'for'
name|'seg_index'
op|','
name|'seg_dict'
name|'in'
name|'enumerate'
op|'('
name|'parsed_data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'seg_dict'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: not a JSON object"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'missing_keys'
op|'='
op|'['
name|'k'
name|'for'
name|'k'
name|'in'
name|'REQUIRED_SLO_KEYS'
name|'if'
name|'k'
name|'not'
name|'in'
name|'seg_dict'
op|']'
newline|'\n'
name|'if'
name|'missing_keys'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"Index %d: missing keys %s"'
nl|'\n'
op|'%'
op|'('
name|'seg_index'
op|','
nl|'\n'
string|'", "'
op|'.'
name|'join'
op|'('
string|'\'"%s"\''
op|'%'
op|'('
name|'mk'
op|','
op|')'
name|'for'
name|'mk'
name|'in'
name|'sorted'
op|'('
name|'missing_keys'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'extraneous_keys'
op|'='
op|'['
name|'k'
name|'for'
name|'k'
name|'in'
name|'seg_dict'
name|'if'
name|'k'
name|'not'
name|'in'
name|'ALLOWED_SLO_KEYS'
op|']'
newline|'\n'
name|'if'
name|'extraneous_keys'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"Index %d: extraneous keys %s"'
nl|'\n'
op|'%'
op|'('
name|'seg_index'
op|','
nl|'\n'
string|'", "'
op|'.'
name|'join'
op|'('
string|'\'"%s"\''
op|'%'
op|'('
name|'ek'
op|','
op|')'
nl|'\n'
name|'for'
name|'ek'
name|'in'
name|'sorted'
op|'('
name|'extraneous_keys'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'seg_dict'
op|'['
string|"'path'"
op|']'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: \\"path\\" must be a string"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'not'
op|'('
name|'seg_dict'
op|'['
string|"'etag'"
op|']'
name|'is'
name|'None'
name|'or'
nl|'\n'
name|'isinstance'
op|'('
name|'seg_dict'
op|'['
string|"'etag'"
op|']'
op|','
name|'basestring'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"Index %d: \\"etag\\" must be a string or null"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'/'"
name|'not'
name|'in'
name|'seg_dict'
op|'['
string|"'path'"
op|']'
op|'.'
name|'strip'
op|'('
string|"'/'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"Index %d: path does not refer to an object. Path must be of "'
nl|'\n'
string|'"the form /container/object."'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'seg_size'
op|'='
name|'seg_dict'
op|'['
string|"'size_bytes'"
op|']'
newline|'\n'
name|'if'
name|'seg_size'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'seg_size'
op|'='
name|'int'
op|'('
name|'seg_size'
op|')'
newline|'\n'
name|'seg_dict'
op|'['
string|"'size_bytes'"
op|']'
op|'='
name|'seg_size'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: invalid size_bytes"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'seg_size'
op|'<'
name|'min_segment_size'
name|'and'
name|'seg_index'
op|'<'
name|'num_segs'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: too small; each segment, except "'
nl|'\n'
string|'"the last, must be at least %d bytes."'
nl|'\n'
op|'%'
op|'('
name|'seg_index'
op|','
name|'min_segment_size'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'obj_path'
op|'='
string|"'/'"
op|'.'
name|'join'
op|'('
op|'['
string|"''"
op|','
name|'vrs'
op|','
name|'account'
op|','
name|'seg_dict'
op|'['
string|"'path'"
op|']'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|']'
op|')'
newline|'\n'
name|'if'
name|'req_path'
op|'=='
name|'quote'
op|'('
name|'obj_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'errors'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"Index %d: manifest must not include itself as a segment"'
nl|'\n'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|'='
name|'Range'
op|'('
string|"'bytes=%s'"
op|'%'
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: invalid range"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|'.'
name|'ranges'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: multiple ranges (only one allowed)"'
nl|'\n'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|"# If the user *told* us the object's size, we can check range"
nl|'\n'
comment|"# satisfiability right now. If they lied about the size, we'll"
nl|'\n'
comment|'# fail that validation later.'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'seg_size'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'len'
op|'('
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|'.'
name|'ranges_for_length'
op|'('
name|'seg_size'
op|')'
op|')'
op|'!='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
string|'"Index %d: unsatisfiable range"'
op|'%'
name|'seg_index'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'errors'
op|':'
newline|'\n'
indent|'        '
name|'error_message'
op|'='
string|'""'
op|'.'
name|'join'
op|'('
name|'e'
op|'+'
string|'"\\n"'
name|'for'
name|'e'
name|'in'
name|'errors'
op|')'
newline|'\n'
name|'raise'
name|'HTTPBadRequest'
op|'('
name|'error_message'
op|','
nl|'\n'
name|'headers'
op|'='
op|'{'
string|'"Content-Type"'
op|':'
string|'"text/plain"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'parsed_data'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SloPutContext
dedent|''
name|'class'
name|'SloPutContext'
op|'('
name|'WSGIContext'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'slo'
op|','
name|'slo_etag'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'SloPutContext'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'slo'
op|'.'
name|'app'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'slo_etag'
op|'='
string|'\'"\''
op|'+'
name|'slo_etag'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|'+'
string|'\'"\''
newline|'\n'
nl|'\n'
DECL|member|handle_slo_put
dedent|''
name|'def'
name|'handle_slo_put'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'app_resp'
op|'='
name|'self'
op|'.'
name|'_app_call'
op|'('
name|'req'
op|'.'
name|'environ'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'_response_headers'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_response_headers'
op|'['
name|'i'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'etag'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_response_headers'
op|'['
name|'i'
op|']'
op|'='
op|'('
string|"'Etag'"
op|','
name|'self'
op|'.'
name|'slo_etag'
op|')'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'start_response'
op|'('
name|'self'
op|'.'
name|'_response_status'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_headers'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_exc_info'
op|')'
newline|'\n'
name|'return'
name|'app_resp'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SloGetContext
dedent|''
dedent|''
name|'class'
name|'SloGetContext'
op|'('
name|'WSGIContext'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|max_slo_recursion_depth
indent|'    '
name|'max_slo_recursion_depth'
op|'='
number|'10'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'slo'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'slo'
op|'='
name|'slo'
newline|'\n'
name|'self'
op|'.'
name|'first_byte'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'None'
newline|'\n'
name|'super'
op|'('
name|'SloGetContext'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'slo'
op|'.'
name|'app'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fetch_sub_slo_segments
dedent|''
name|'def'
name|'_fetch_sub_slo_segments'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'version'
op|','
name|'acc'
op|','
name|'con'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Fetch the submanifest, parse it, and return it.\n        Raise exception on failures.\n        """'
newline|'\n'
name|'sub_req'
op|'='
name|'make_subrequest'
op|'('
nl|'\n'
name|'req'
op|'.'
name|'environ'
op|','
name|'path'
op|'='
string|"'/'"
op|'.'
name|'join'
op|'('
op|'['
string|"''"
op|','
name|'version'
op|','
name|'acc'
op|','
name|'con'
op|','
name|'obj'
op|']'
op|')'
op|','
nl|'\n'
name|'method'
op|'='
string|"'GET'"
op|','
nl|'\n'
name|'headers'
op|'='
op|'{'
string|"'x-auth-token'"
op|':'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'x-auth-token'"
op|')'
op|'}'
op|','
nl|'\n'
name|'agent'
op|'='
op|'('
string|"'%(orig)s '"
op|'+'
string|"'SLO MultipartGET'"
op|')'
op|','
name|'swift_source'
op|'='
string|"'SLO'"
op|')'
newline|'\n'
name|'sub_resp'
op|'='
name|'sub_req'
op|'.'
name|'get_response'
op|'('
name|'self'
op|'.'
name|'slo'
op|'.'
name|'app'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'is_success'
op|'('
name|'sub_resp'
op|'.'
name|'status_int'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'close_if_possible'
op|'('
name|'sub_resp'
op|'.'
name|'app_iter'
op|')'
newline|'\n'
name|'raise'
name|'ListingIterError'
op|'('
nl|'\n'
string|"'ERROR: while fetching %s, GET of submanifest %s '"
nl|'\n'
string|"'failed with status %d'"
op|'%'
op|'('
name|'req'
op|'.'
name|'path'
op|','
name|'sub_req'
op|'.'
name|'path'
op|','
nl|'\n'
name|'sub_resp'
op|'.'
name|'status_int'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'closing_if_possible'
op|'('
name|'sub_resp'
op|'.'
name|'app_iter'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'json'
op|'.'
name|'loads'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'sub_resp'
op|'.'
name|'app_iter'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'ValueError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ListingIterError'
op|'('
nl|'\n'
string|"'ERROR: while fetching %s, JSON-decoding of submanifest %s '"
nl|'\n'
string|"'failed with %s'"
op|'%'
op|'('
name|'req'
op|'.'
name|'path'
op|','
name|'sub_req'
op|'.'
name|'path'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_segment_length
dedent|''
dedent|''
name|'def'
name|'_segment_length'
op|'('
name|'self'
op|','
name|'seg_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the number of bytes that will be fetched from the specified\n        segment on a plain GET request for this SLO manifest.\n        """'
newline|'\n'
name|'seg_range'
op|'='
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
newline|'\n'
name|'if'
name|'seg_range'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# The range is of the form N-M, where N and M are both positive'
nl|'\n'
comment|'# decimal integers. We know this because this middleware is the'
nl|'\n'
comment|'# only thing that creates the SLO manifests stored in the'
nl|'\n'
comment|'# cluster.'
nl|'\n'
indent|'            '
name|'range_start'
op|','
name|'range_end'
op|'='
op|'['
name|'int'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'seg_range'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
op|']'
newline|'\n'
name|'return'
name|'range_end'
op|'-'
name|'range_start'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'int'
op|'('
name|'seg_dict'
op|'['
string|"'bytes'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_segment_listing_iterator
dedent|''
dedent|''
name|'def'
name|'_segment_listing_iterator'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'version'
op|','
name|'account'
op|','
name|'segments'
op|','
nl|'\n'
name|'recursion_depth'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'seg_dict'
name|'in'
name|'segments'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'config_true_value'
op|'('
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'sub_slo'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'override_bytes_from_content_type'
op|'('
name|'seg_dict'
op|','
nl|'\n'
name|'logger'
op|'='
name|'self'
op|'.'
name|'slo'
op|'.'
name|'logger'
op|')'
newline|'\n'
nl|'\n'
comment|'# We handle the range stuff here so that we can be smart about'
nl|'\n'
comment|'# skipping unused submanifests. For example, if our first segment is a'
nl|'\n'
comment|'# submanifest referencing 50 MiB total, but start_byte falls in'
nl|'\n'
comment|'# the 51st MiB, then we can avoid fetching the first submanifest.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# If we were to make SegmentedIterable handle all the range'
nl|'\n'
comment|'# calculations, we would be unable to make this optimization.'
nl|'\n'
dedent|''
dedent|''
name|'total_length'
op|'='
name|'sum'
op|'('
name|'self'
op|'.'
name|'_segment_length'
op|'('
name|'seg'
op|')'
name|'for'
name|'seg'
name|'in'
name|'segments'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'first_byte'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'first_byte'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'last_byte'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'total_length'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'last_sub_path'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'seg_dict'
name|'in'
name|'segments'
op|':'
newline|'\n'
indent|'            '
name|'seg_length'
op|'='
name|'self'
op|'.'
name|'_segment_length'
op|'('
name|'seg_dict'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'first_byte'
op|'>='
name|'seg_length'
op|':'
newline|'\n'
comment|"# don't need any bytes from this segment"
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'first_byte'
op|'-='
name|'seg_length'
newline|'\n'
name|'self'
op|'.'
name|'last_byte'
op|'-='
name|'seg_length'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'last_byte'
op|'<'
number|'0'
op|':'
newline|'\n'
comment|'# no bytes are needed from this or any future segment'
nl|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'range'
op|'='
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
newline|'\n'
name|'if'
name|'range'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'range_start'
op|','
name|'range_end'
op|'='
number|'0'
op|','
name|'seg_length'
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# We already validated and supplied concrete values'
nl|'\n'
comment|'# for the range on upload'
nl|'\n'
indent|'                '
name|'range_start'
op|','
name|'range_end'
op|'='
name|'map'
op|'('
name|'int'
op|','
name|'range'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'config_true_value'
op|'('
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'sub_slo'"
op|')'
op|')'
op|':'
newline|'\n'
comment|'# do this check here so that we can avoid fetching this last'
nl|'\n'
comment|'# manifest before raising the exception'
nl|'\n'
indent|'                '
name|'if'
name|'recursion_depth'
op|'>='
name|'self'
op|'.'
name|'max_slo_recursion_depth'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ListingIterError'
op|'('
string|'"Max recursion depth exceeded"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'sub_path'
op|'='
name|'get_valid_utf8_str'
op|'('
name|'seg_dict'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'sub_cont'
op|','
name|'sub_obj'
op|'='
name|'split_path'
op|'('
name|'sub_path'
op|','
number|'2'
op|','
number|'2'
op|','
name|'True'
op|')'
newline|'\n'
name|'if'
name|'last_sub_path'
op|'!='
name|'sub_path'
op|':'
newline|'\n'
indent|'                    '
name|'sub_segments'
op|'='
name|'self'
op|'.'
name|'_fetch_sub_slo_segments'
op|'('
nl|'\n'
name|'req'
op|','
name|'version'
op|','
name|'account'
op|','
name|'sub_cont'
op|','
name|'sub_obj'
op|')'
newline|'\n'
dedent|''
name|'last_sub_path'
op|'='
name|'sub_path'
newline|'\n'
nl|'\n'
comment|'# Use the existing machinery to slice into the sub-SLO.'
nl|'\n'
comment|'# This requires that we save off our current state, and'
nl|'\n'
comment|'# restore at the other end.'
nl|'\n'
name|'orig_start'
op|','
name|'orig_end'
op|'='
name|'self'
op|'.'
name|'first_byte'
op|','
name|'self'
op|'.'
name|'last_byte'
newline|'\n'
name|'self'
op|'.'
name|'first_byte'
op|'='
name|'range_start'
op|'+'
name|'max'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'first_byte'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'min'
op|'('
name|'range_end'
op|','
name|'range_start'
op|'+'
name|'self'
op|'.'
name|'last_byte'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'sub_seg_dict'
op|','
name|'sb'
op|','
name|'eb'
name|'in'
name|'self'
op|'.'
name|'_segment_listing_iterator'
op|'('
nl|'\n'
name|'req'
op|','
name|'version'
op|','
name|'account'
op|','
name|'sub_segments'
op|','
nl|'\n'
name|'recursion_depth'
op|'='
name|'recursion_depth'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'sub_seg_dict'
op|','
name|'sb'
op|','
name|'eb'
newline|'\n'
nl|'\n'
comment|'# Restore the first/last state'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'first_byte'
op|','
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'orig_start'
op|','
name|'orig_end'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'isinstance'
op|'('
name|'seg_dict'
op|'['
string|"'name'"
op|']'
op|','
name|'six'
op|'.'
name|'text_type'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'seg_dict'
op|'['
string|"'name'"
op|']'
op|'='
name|'seg_dict'
op|'['
string|"'name'"
op|']'
op|'.'
name|'encode'
op|'('
string|'"utf-8"'
op|')'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'seg_dict'
op|','
nl|'\n'
name|'max'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'first_byte'
op|')'
op|'+'
name|'range_start'
op|','
nl|'\n'
name|'min'
op|'('
name|'range_end'
op|','
name|'range_start'
op|'+'
name|'self'
op|'.'
name|'last_byte'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'first_byte'
op|'-='
name|'seg_length'
newline|'\n'
name|'self'
op|'.'
name|'last_byte'
op|'-='
name|'seg_length'
newline|'\n'
nl|'\n'
DECL|member|_need_to_refetch_manifest
dedent|''
dedent|''
name|'def'
name|'_need_to_refetch_manifest'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Just because a response shows that an object is a SLO manifest does not\n        mean that response\'s body contains the entire SLO manifest. If it\n        doesn\'t, we need to make a second request to actually get the whole\n        thing.\n\n        Note: this assumes that X-Static-Large-Object has already been found.\n        """'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'response_status'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_response_status'
op|'['
op|':'
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|"# These are based on etag, and the SLO's etag is almost certainly not"
nl|'\n'
comment|"# the manifest object's etag. Still, it's highly likely that the"
nl|'\n'
comment|"# submitted If-None-Match won't match the manifest object's etag, so"
nl|'\n'
comment|'# we can avoid re-fetching the manifest if we got a successful'
nl|'\n'
comment|'# response.'
nl|'\n'
name|'if'
op|'('
op|'('
name|'req'
op|'.'
name|'if_match'
name|'or'
name|'req'
op|'.'
name|'if_none_match'
op|')'
name|'and'
nl|'\n'
name|'not'
name|'is_success'
op|'('
name|'response_status'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'range'
name|'and'
name|'response_status'
name|'in'
op|'('
number|'206'
op|','
number|'416'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'content_range'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'header'
op|','
name|'value'
name|'in'
name|'self'
op|'.'
name|'_response_headers'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'header'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'content-range'"
op|':'
newline|'\n'
indent|'                    '
name|'content_range'
op|'='
name|'value'
newline|'\n'
name|'break'
newline|'\n'
comment|'# e.g. Content-Range: bytes 0-14289/14290'
nl|'\n'
dedent|''
dedent|''
name|'match'
op|'='
name|'re'
op|'.'
name|'match'
op|'('
string|"'bytes (\\d+)-(\\d+)/(\\d+)$'"
op|','
name|'content_range'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'match'
op|':'
newline|'\n'
comment|"# Malformed or missing, so we don't know what we got."
nl|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'first_byte'
op|','
name|'last_byte'
op|','
name|'length'
op|'='
op|'['
name|'int'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'match'
op|'.'
name|'groups'
op|'('
op|')'
op|']'
newline|'\n'
comment|'# If and only if we actually got back the full manifest body, then'
nl|'\n'
comment|'# we can avoid re-fetching the object.'
nl|'\n'
name|'got_everything'
op|'='
op|'('
name|'first_byte'
op|'=='
number|'0'
name|'and'
name|'last_byte'
op|'=='
name|'length'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'return'
name|'not'
name|'got_everything'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|handle_slo_get_or_head
dedent|''
name|'def'
name|'handle_slo_get_or_head'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Takes a request and a start_response callable and does the normal WSGI\n        thing with them. Returns an iterator suitable for sending up the WSGI\n        chain.\n\n        :param req: swob.Request object; is a GET or HEAD request aimed at\n                    what may be a static large object manifest (or may not).\n        :param start_response: WSGI start_response callable\n        """'
newline|'\n'
name|'resp_iter'
op|'='
name|'self'
op|'.'
name|'_app_call'
op|'('
name|'req'
op|'.'
name|'environ'
op|')'
newline|'\n'
nl|'\n'
comment|'# make sure this response is for a static large object manifest'
nl|'\n'
name|'for'
name|'header'
op|','
name|'value'
name|'in'
name|'self'
op|'.'
name|'_response_headers'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'header'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'x-static-large-object'"
name|'and'
nl|'\n'
name|'config_true_value'
op|'('
name|'value'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Not a static large object manifest. Just pass it through.'
nl|'\n'
indent|'            '
name|'start_response'
op|'('
name|'self'
op|'.'
name|'_response_status'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_headers'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_exc_info'
op|')'
newline|'\n'
name|'return'
name|'resp_iter'
newline|'\n'
nl|'\n'
comment|'# Handle pass-through request for the manifest itself'
nl|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'params'
op|'.'
name|'get'
op|'('
string|"'multipart-manifest'"
op|')'
op|'=='
string|"'get'"
op|':'
newline|'\n'
indent|'            '
name|'new_headers'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'header'
op|','
name|'value'
name|'in'
name|'self'
op|'.'
name|'_response_headers'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'header'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'content-type'"
op|':'
newline|'\n'
indent|'                    '
name|'new_headers'
op|'.'
name|'append'
op|'('
op|'('
string|"'Content-Type'"
op|','
nl|'\n'
string|"'application/json; charset=utf-8'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'new_headers'
op|'.'
name|'append'
op|'('
op|'('
name|'header'
op|','
name|'value'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_response_headers'
op|'='
name|'new_headers'
newline|'\n'
name|'start_response'
op|'('
name|'self'
op|'.'
name|'_response_status'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_headers'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_response_exc_info'
op|')'
newline|'\n'
name|'return'
name|'resp_iter'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_need_to_refetch_manifest'
op|'('
name|'req'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.non_client_disconnect'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'close_if_possible'
op|'('
name|'resp_iter'
op|')'
newline|'\n'
name|'del'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.non_client_disconnect'"
op|']'
newline|'\n'
nl|'\n'
name|'get_req'
op|'='
name|'make_subrequest'
op|'('
nl|'\n'
name|'req'
op|'.'
name|'environ'
op|','
name|'method'
op|'='
string|"'GET'"
op|','
nl|'\n'
name|'headers'
op|'='
op|'{'
string|"'x-auth-token'"
op|':'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'x-auth-token'"
op|')'
op|'}'
op|','
nl|'\n'
name|'agent'
op|'='
op|'('
string|"'%(orig)s '"
op|'+'
string|"'SLO MultipartGET'"
op|')'
op|','
name|'swift_source'
op|'='
string|"'SLO'"
op|')'
newline|'\n'
name|'resp_iter'
op|'='
name|'self'
op|'.'
name|'_app_call'
op|'('
name|'get_req'
op|'.'
name|'environ'
op|')'
newline|'\n'
nl|'\n'
comment|'# Any Content-Range from a manifest is almost certainly wrong for the'
nl|'\n'
comment|'# full large object.'
nl|'\n'
dedent|''
name|'resp_headers'
op|'='
op|'['
op|'('
name|'h'
op|','
name|'v'
op|')'
name|'for'
name|'h'
op|','
name|'v'
name|'in'
name|'self'
op|'.'
name|'_response_headers'
nl|'\n'
name|'if'
name|'not'
name|'h'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'content-range'"
op|']'
newline|'\n'
nl|'\n'
name|'response'
op|'='
name|'self'
op|'.'
name|'get_or_head_response'
op|'('
nl|'\n'
name|'req'
op|','
name|'resp_headers'
op|','
name|'resp_iter'
op|')'
newline|'\n'
name|'return'
name|'response'
op|'('
name|'req'
op|'.'
name|'environ'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_or_head_response
dedent|''
name|'def'
name|'get_or_head_response'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'resp_headers'
op|','
name|'resp_iter'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'closing_if_possible'
op|'('
name|'resp_iter'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'resp_body'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'resp_iter'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'segments'
op|'='
name|'json'
op|'.'
name|'loads'
op|'('
name|'resp_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'segments'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'etag'
op|'='
name|'md5'
op|'('
op|')'
newline|'\n'
name|'content_length'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'seg_dict'
name|'in'
name|'segments'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'etag'
op|'.'
name|'update'
op|'('
string|"'%s:%s;'"
op|'%'
op|'('
name|'seg_dict'
op|'['
string|"'hash'"
op|']'
op|','
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'etag'
op|'.'
name|'update'
op|'('
name|'seg_dict'
op|'['
string|"'hash'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'config_true_value'
op|'('
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'sub_slo'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'override_bytes_from_content_type'
op|'('
nl|'\n'
name|'seg_dict'
op|','
name|'logger'
op|'='
name|'self'
op|'.'
name|'slo'
op|'.'
name|'logger'
op|')'
newline|'\n'
dedent|''
name|'content_length'
op|'+='
name|'self'
op|'.'
name|'_segment_length'
op|'('
name|'seg_dict'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'response_headers'
op|'='
op|'['
op|'('
name|'h'
op|','
name|'v'
op|')'
name|'for'
name|'h'
op|','
name|'v'
name|'in'
name|'resp_headers'
nl|'\n'
name|'if'
name|'h'
op|'.'
name|'lower'
op|'('
op|')'
name|'not'
name|'in'
op|'('
string|"'etag'"
op|','
string|"'content-length'"
op|')'
op|']'
newline|'\n'
name|'response_headers'
op|'.'
name|'append'
op|'('
op|'('
string|"'Content-Length'"
op|','
name|'str'
op|'('
name|'content_length'
op|')'
op|')'
op|')'
newline|'\n'
name|'response_headers'
op|'.'
name|'append'
op|'('
op|'('
string|"'Etag'"
op|','
string|'\'"%s"\''
op|'%'
name|'etag'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_manifest_head_response'
op|'('
name|'req'
op|','
name|'response_headers'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_manifest_get_response'
op|'('
nl|'\n'
name|'req'
op|','
name|'content_length'
op|','
name|'response_headers'
op|','
name|'segments'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_manifest_head_response
dedent|''
dedent|''
name|'def'
name|'_manifest_head_response'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'response_headers'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'HTTPOk'
op|'('
name|'request'
op|'='
name|'req'
op|','
name|'headers'
op|'='
name|'response_headers'
op|','
name|'body'
op|'='
string|"''"
op|','
nl|'\n'
name|'conditional_response'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_manifest_get_response
dedent|''
name|'def'
name|'_manifest_get_response'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'content_length'
op|','
name|'response_headers'
op|','
nl|'\n'
name|'segments'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'first_byte'
op|','
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'range'
op|':'
newline|'\n'
indent|'            '
name|'byteranges'
op|'='
name|'req'
op|'.'
name|'range'
op|'.'
name|'ranges_for_length'
op|'('
name|'content_length'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'byteranges'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'HTTPRequestedRangeNotSatisfiable'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'byteranges'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'first_byte'
op|','
name|'self'
op|'.'
name|'last_byte'
op|'='
name|'byteranges'
op|'['
number|'0'
op|']'
newline|'\n'
comment|'# For some reason, swob.Range.ranges_for_length adds 1 to the'
nl|'\n'
comment|"# last byte's position."
nl|'\n'
name|'self'
op|'.'
name|'last_byte'
op|'-='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'req'
op|'.'
name|'range'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'ver'
op|','
name|'account'
op|','
name|'_junk'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'3'
op|','
number|'3'
op|','
name|'rest_with_last'
op|'='
name|'True'
op|')'
newline|'\n'
name|'plain_listing_iter'
op|'='
name|'self'
op|'.'
name|'_segment_listing_iterator'
op|'('
nl|'\n'
name|'req'
op|','
name|'ver'
op|','
name|'account'
op|','
name|'segments'
op|')'
newline|'\n'
nl|'\n'
name|'ratelimited_listing_iter'
op|'='
name|'RateLimitedIterator'
op|'('
nl|'\n'
name|'plain_listing_iter'
op|','
nl|'\n'
name|'self'
op|'.'
name|'slo'
op|'.'
name|'rate_limit_segments_per_sec'
op|','
nl|'\n'
name|'limit_after'
op|'='
name|'self'
op|'.'
name|'slo'
op|'.'
name|'rate_limit_after_segment'
op|')'
newline|'\n'
nl|'\n'
comment|'# self._segment_listing_iterator gives us 3-tuples of (segment dict,'
nl|'\n'
comment|'# start byte, end byte), but SegmentedIterable wants (obj path, etag,'
nl|'\n'
comment|'# size, start byte, end byte), so we clean that up here'
nl|'\n'
name|'segment_listing_iter'
op|'='
op|'('
nl|'\n'
op|'('
string|'"/{ver}/{acc}/{conobj}"'
op|'.'
name|'format'
op|'('
nl|'\n'
name|'ver'
op|'='
name|'ver'
op|','
name|'acc'
op|'='
name|'account'
op|','
name|'conobj'
op|'='
name|'seg_dict'
op|'['
string|"'name'"
op|']'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|')'
op|','
nl|'\n'
name|'seg_dict'
op|'['
string|"'hash'"
op|']'
op|','
name|'int'
op|'('
name|'seg_dict'
op|'['
string|"'bytes'"
op|']'
op|')'
op|','
nl|'\n'
name|'start_byte'
op|','
name|'end_byte'
op|')'
nl|'\n'
name|'for'
name|'seg_dict'
op|','
name|'start_byte'
op|','
name|'end_byte'
name|'in'
name|'ratelimited_listing_iter'
op|')'
newline|'\n'
nl|'\n'
name|'segmented_iter'
op|'='
name|'SegmentedIterable'
op|'('
nl|'\n'
name|'req'
op|','
name|'self'
op|'.'
name|'slo'
op|'.'
name|'app'
op|','
name|'segment_listing_iter'
op|','
nl|'\n'
name|'name'
op|'='
name|'req'
op|'.'
name|'path'
op|','
name|'logger'
op|'='
name|'self'
op|'.'
name|'slo'
op|'.'
name|'logger'
op|','
nl|'\n'
name|'ua_suffix'
op|'='
string|'"SLO MultipartGET"'
op|','
nl|'\n'
name|'swift_source'
op|'='
string|'"SLO"'
op|','
nl|'\n'
name|'max_get_time'
op|'='
name|'self'
op|'.'
name|'slo'
op|'.'
name|'max_get_time'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'segmented_iter'
op|'.'
name|'validate_first_segment'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ListingIterError'
op|','
name|'SegmentError'
op|')'
op|':'
newline|'\n'
comment|'# Copy from the SLO explanation in top of this file.'
nl|'\n'
comment|'# If any of the segments from the manifest are not found or'
nl|'\n'
comment|'# their Etag/Content Length no longer match the connection'
nl|'\n'
comment|'# will drop. In this case a 409 Conflict will be logged in'
nl|'\n'
comment|'# the proxy logs and the user will receive incomplete results.'
nl|'\n'
indent|'            '
name|'return'
name|'HTTPConflict'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'response'
op|'='
name|'Response'
op|'('
name|'request'
op|'='
name|'req'
op|','
name|'content_length'
op|'='
name|'content_length'
op|','
nl|'\n'
name|'headers'
op|'='
name|'response_headers'
op|','
nl|'\n'
name|'conditional_response'
op|'='
name|'True'
op|','
nl|'\n'
name|'app_iter'
op|'='
name|'segmented_iter'
op|')'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'range'
op|':'
newline|'\n'
indent|'            '
name|'response'
op|'.'
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'Etag'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'response'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StaticLargeObject
dedent|''
dedent|''
name|'class'
name|'StaticLargeObject'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    StaticLargeObject Middleware\n\n    See above for a full description.\n\n    The proxy logs created for any subrequests made will have swift.source set\n    to "SLO".\n\n    :param app: The next WSGI filter or app in the paste.deploy chain.\n    :param conf: The configuration dict for the middleware.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'app'
op|','
name|'conf'
op|','
name|'min_segment_size'
op|'='
name|'DEFAULT_MIN_SEGMENT_SIZE'
op|','
nl|'\n'
name|'max_manifest_segments'
op|'='
name|'DEFAULT_MAX_MANIFEST_SEGMENTS'
op|','
nl|'\n'
name|'max_manifest_size'
op|'='
name|'DEFAULT_MAX_MANIFEST_SIZE'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'conf'
op|'='
name|'conf'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'='
name|'app'
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'='
name|'get_logger'
op|'('
name|'conf'
op|','
name|'log_route'
op|'='
string|"'slo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'max_manifest_segments'
op|'='
name|'max_manifest_segments'
newline|'\n'
name|'self'
op|'.'
name|'max_manifest_size'
op|'='
name|'max_manifest_size'
newline|'\n'
name|'self'
op|'.'
name|'min_segment_size'
op|'='
name|'min_segment_size'
newline|'\n'
name|'self'
op|'.'
name|'max_get_time'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'max_get_time'"
op|','
number|'86400'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'rate_limit_after_segment'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'conf'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'rate_limit_after_segment'"
op|','
string|"'10'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'rate_limit_segments_per_sec'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'conf'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'rate_limit_segments_per_sec'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bulk_deleter'
op|'='
name|'Bulk'
op|'('
name|'app'
op|','
op|'{'
op|'}'
op|','
name|'logger'
op|'='
name|'self'
op|'.'
name|'logger'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_multipart_get_or_head
dedent|''
name|'def'
name|'handle_multipart_get_or_head'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handles the GET or HEAD of a SLO manifest.\n\n        The response body (only on GET, of course) will consist of the\n        concatenation of the segments.\n\n        :params req: a swob.Request with a path referencing an object\n        :raises: HttpException on errors\n        """'
newline|'\n'
name|'return'
name|'SloGetContext'
op|'('
name|'self'
op|')'
op|'.'
name|'handle_slo_get_or_head'
op|'('
name|'req'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
DECL|member|copy_hook
dedent|''
name|'def'
name|'copy_hook'
op|'('
name|'self'
op|','
name|'inner_hook'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|function|slo_hook
indent|'        '
name|'def'
name|'slo_hook'
op|'('
name|'source_req'
op|','
name|'source_resp'
op|','
name|'sink_req'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'x_slo'
op|'='
name|'source_resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Static-Large-Object'"
op|')'
newline|'\n'
name|'if'
op|'('
name|'config_true_value'
op|'('
name|'x_slo'
op|')'
nl|'\n'
name|'and'
name|'source_req'
op|'.'
name|'params'
op|'.'
name|'get'
op|'('
string|"'multipart-manifest'"
op|')'
op|'!='
string|"'get'"
nl|'\n'
name|'and'
string|"'swift.post_as_copy'"
name|'not'
name|'in'
name|'source_req'
op|'.'
name|'environ'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_resp'
op|'='
name|'SloGetContext'
op|'('
name|'self'
op|')'
op|'.'
name|'get_or_head_response'
op|'('
nl|'\n'
name|'source_req'
op|','
name|'source_resp'
op|'.'
name|'headers'
op|'.'
name|'items'
op|'('
op|')'
op|','
nl|'\n'
name|'source_resp'
op|'.'
name|'app_iter'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'inner_hook'
op|'('
name|'source_req'
op|','
name|'source_resp'
op|','
name|'sink_req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'slo_hook'
newline|'\n'
nl|'\n'
DECL|member|handle_multipart_put
dedent|''
name|'def'
name|'handle_multipart_put'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Will handle the PUT of a SLO manifest.\n        Heads every object in manifest to check if is valid and if so will\n        save a manifest generated from the user input. Uses WSGIContext to\n        call self and start_response and returns a WSGI iterator.\n\n        :params req: a swob.Request with an obj in path\n        :raises: HttpException on errors\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vrs'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'1'
op|','
number|'4'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'app'
op|'('
name|'req'
op|'.'
name|'environ'
op|','
name|'start_response'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'content_length'
op|'>'
name|'self'
op|'.'
name|'max_manifest_size'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
nl|'\n'
string|'"Manifest File > %d bytes"'
op|'%'
name|'self'
op|'.'
name|'max_manifest_size'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Copy-From'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPMethodNotAllowed'
op|'('
nl|'\n'
string|"'Multipart Manifest PUTs cannot be COPY requests'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'content_length'
name|'is'
name|'None'
name|'and'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'transfer-encoding'"
op|','
string|"''"
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'!='
string|"'chunked'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPLengthRequired'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'parsed_data'
op|'='
name|'parse_and_validate_input'
op|'('
nl|'\n'
name|'req'
op|'.'
name|'body_file'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'max_manifest_size'
op|')'
op|','
nl|'\n'
name|'req'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'min_segment_size'
op|')'
newline|'\n'
name|'problem_segments'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'parsed_data'
op|')'
op|'>'
name|'self'
op|'.'
name|'max_manifest_segments'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
nl|'\n'
string|"'Number of segments must be <= %d'"
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'max_manifest_segments'
op|')'
newline|'\n'
dedent|''
name|'total_size'
op|'='
number|'0'
newline|'\n'
name|'out_content_type'
op|'='
name|'req'
op|'.'
name|'accept'
op|'.'
name|'best_match'
op|'('
name|'ACCEPTABLE_FORMATS'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'out_content_type'
op|':'
newline|'\n'
indent|'            '
name|'out_content_type'
op|'='
string|"'text/plain'"
newline|'\n'
dedent|''
name|'data_for_storage'
op|'='
op|'['
op|']'
newline|'\n'
name|'slo_etag'
op|'='
name|'md5'
op|'('
op|')'
newline|'\n'
name|'last_obj_path'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'index'
op|','
name|'seg_dict'
name|'in'
name|'enumerate'
op|'('
name|'parsed_data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'obj_name'
op|'='
name|'seg_dict'
op|'['
string|"'path'"
op|']'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'obj_name'
op|','
name|'six'
op|'.'
name|'text_type'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'obj_name'
op|'='
name|'obj_name'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
dedent|''
name|'obj_path'
op|'='
string|"'/'"
op|'.'
name|'join'
op|'('
op|'['
string|"''"
op|','
name|'vrs'
op|','
name|'account'
op|','
name|'obj_name'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'new_env'
op|'='
name|'req'
op|'.'
name|'environ'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'new_env'
op|'['
string|"'PATH_INFO'"
op|']'
op|'='
name|'obj_path'
newline|'\n'
name|'new_env'
op|'['
string|"'REQUEST_METHOD'"
op|']'
op|'='
string|"'HEAD'"
newline|'\n'
name|'new_env'
op|'['
string|"'swift.source'"
op|']'
op|'='
string|"'SLO'"
newline|'\n'
name|'del'
op|'('
name|'new_env'
op|'['
string|"'wsgi.input'"
op|']'
op|')'
newline|'\n'
name|'del'
op|'('
name|'new_env'
op|'['
string|"'QUERY_STRING'"
op|']'
op|')'
newline|'\n'
name|'new_env'
op|'['
string|"'CONTENT_LENGTH'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'new_env'
op|'['
string|"'HTTP_USER_AGENT'"
op|']'
op|'='
string|"'%s MultipartPUT'"
op|'%'
name|'req'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
string|"'HTTP_USER_AGENT'"
op|')'
newline|'\n'
name|'if'
name|'obj_path'
op|'!='
name|'last_obj_path'
op|':'
newline|'\n'
indent|'                '
name|'last_obj_path'
op|'='
name|'obj_path'
newline|'\n'
name|'head_seg_resp'
op|'='
name|'Request'
op|'.'
name|'blank'
op|'('
name|'obj_path'
op|','
name|'new_env'
op|')'
op|'.'
name|'get_response'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'head_seg_resp'
op|'.'
name|'is_success'
op|':'
newline|'\n'
indent|'                '
name|'segment_length'
op|'='
name|'head_seg_resp'
op|'.'
name|'content_length'
newline|'\n'
name|'if'
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
op|':'
newline|'\n'
comment|'# Since we now know the length, we can normalize the'
nl|'\n'
comment|'# range. We know that there is exactly one range'
nl|'\n'
comment|'# requested since we checked that earlier in'
nl|'\n'
comment|'# parse_and_validate_input().'
nl|'\n'
indent|'                    '
name|'ranges'
op|'='
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|'.'
name|'ranges_for_length'
op|'('
nl|'\n'
name|'head_seg_resp'
op|'.'
name|'content_length'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'ranges'
op|':'
newline|'\n'
indent|'                        '
name|'problem_segments'
op|'.'
name|'append'
op|'('
op|'['
name|'quote'
op|'('
name|'obj_name'
op|')'
op|','
nl|'\n'
string|"'Unsatisfiable Range'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'ranges'
op|'=='
op|'['
op|'('
number|'0'
op|','
name|'head_seg_resp'
op|'.'
name|'content_length'
op|')'
op|']'
op|':'
newline|'\n'
comment|'# Just one range, and it exactly matches the object.'
nl|'\n'
comment|"# Why'd we do this again?"
nl|'\n'
indent|'                        '
name|'del'
name|'seg_dict'
op|'['
string|"'range'"
op|']'
newline|'\n'
name|'segment_length'
op|'='
name|'head_seg_resp'
op|'.'
name|'content_length'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'rng'
op|'='
name|'ranges'
op|'['
number|'0'
op|']'
newline|'\n'
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|'='
string|"'%d-%d'"
op|'%'
op|'('
name|'rng'
op|'['
number|'0'
op|']'
op|','
name|'rng'
op|'['
number|'1'
op|']'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'segment_length'
op|'='
name|'rng'
op|'['
number|'1'
op|']'
op|'-'
name|'rng'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'segment_length'
op|'<'
name|'self'
op|'.'
name|'min_segment_size'
name|'and'
name|'index'
op|'<'
name|'len'
op|'('
name|'parsed_data'
op|')'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'problem_segments'
op|'.'
name|'append'
op|'('
nl|'\n'
op|'['
name|'quote'
op|'('
name|'obj_name'
op|')'
op|','
nl|'\n'
string|"'Too small; each segment, except the last, must be '"
nl|'\n'
string|"'at least %d bytes.'"
op|'%'
name|'self'
op|'.'
name|'min_segment_size'
op|']'
op|')'
newline|'\n'
dedent|''
name|'total_size'
op|'+='
name|'segment_length'
newline|'\n'
name|'if'
name|'seg_dict'
op|'['
string|"'size_bytes'"
op|']'
name|'is'
name|'not'
name|'None'
name|'and'
name|'seg_dict'
op|'['
string|"'size_bytes'"
op|']'
op|'!='
name|'head_seg_resp'
op|'.'
name|'content_length'
op|':'
newline|'\n'
indent|'                    '
name|'problem_segments'
op|'.'
name|'append'
op|'('
op|'['
name|'quote'
op|'('
name|'obj_name'
op|')'
op|','
string|"'Size Mismatch'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'seg_dict'
op|'['
string|"'etag'"
op|']'
name|'is'
name|'None'
name|'or'
name|'seg_dict'
op|'['
string|"'etag'"
op|']'
op|'=='
name|'head_seg_resp'
op|'.'
name|'etag'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'slo_etag'
op|'.'
name|'update'
op|'('
string|"'%s:%s;'"
op|'%'
op|'('
name|'head_seg_resp'
op|'.'
name|'etag'
op|','
nl|'\n'
name|'seg_dict'
op|'['
string|"'range'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'slo_etag'
op|'.'
name|'update'
op|'('
name|'head_seg_resp'
op|'.'
name|'etag'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'problem_segments'
op|'.'
name|'append'
op|'('
op|'['
name|'quote'
op|'('
name|'obj_name'
op|')'
op|','
string|"'Etag Mismatch'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'head_seg_resp'
op|'.'
name|'last_modified'
op|':'
newline|'\n'
indent|'                    '
name|'last_modified'
op|'='
name|'head_seg_resp'
op|'.'
name|'last_modified'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# shouldn't happen"
nl|'\n'
indent|'                    '
name|'last_modified'
op|'='
name|'datetime'
op|'.'
name|'now'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'last_modified_formatted'
op|'='
name|'last_modified'
op|'.'
name|'strftime'
op|'('
string|"'%Y-%m-%dT%H:%M:%S.%f'"
op|')'
newline|'\n'
name|'seg_data'
op|'='
op|'{'
string|"'name'"
op|':'
string|"'/'"
op|'+'
name|'seg_dict'
op|'['
string|"'path'"
op|']'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|','
nl|'\n'
string|"'bytes'"
op|':'
name|'head_seg_resp'
op|'.'
name|'content_length'
op|','
nl|'\n'
string|"'hash'"
op|':'
name|'head_seg_resp'
op|'.'
name|'etag'
op|','
nl|'\n'
string|"'content_type'"
op|':'
name|'head_seg_resp'
op|'.'
name|'content_type'
op|','
nl|'\n'
string|"'last_modified'"
op|':'
name|'last_modified_formatted'
op|'}'
newline|'\n'
name|'if'
name|'seg_dict'
op|'.'
name|'get'
op|'('
string|"'range'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'seg_data'
op|'['
string|"'range'"
op|']'
op|'='
name|'seg_dict'
op|'['
string|"'range'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'config_true_value'
op|'('
nl|'\n'
name|'head_seg_resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Static-Large-Object'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'seg_data'
op|'['
string|"'sub_slo'"
op|']'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'data_for_storage'
op|'.'
name|'append'
op|'('
name|'seg_data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'problem_segments'
op|'.'
name|'append'
op|'('
op|'['
name|'quote'
op|'('
name|'obj_name'
op|')'
op|','
nl|'\n'
name|'head_seg_resp'
op|'.'
name|'status'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'problem_segments'
op|':'
newline|'\n'
indent|'            '
name|'resp_body'
op|'='
name|'get_response_body'
op|'('
nl|'\n'
name|'out_content_type'
op|','
op|'{'
op|'}'
op|','
name|'problem_segments'
op|')'
newline|'\n'
name|'raise'
name|'HTTPBadRequest'
op|'('
name|'resp_body'
op|','
name|'content_type'
op|'='
name|'out_content_type'
op|')'
newline|'\n'
dedent|''
name|'env'
op|'='
name|'req'
op|'.'
name|'environ'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'env'
op|'.'
name|'get'
op|'('
string|"'CONTENT_TYPE'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guessed_type'
op|','
name|'_junk'
op|'='
name|'mimetypes'
op|'.'
name|'guess_type'
op|'('
name|'req'
op|'.'
name|'path_info'
op|')'
newline|'\n'
name|'env'
op|'['
string|"'CONTENT_TYPE'"
op|']'
op|'='
name|'guessed_type'
name|'or'
string|"'application/octet-stream'"
newline|'\n'
dedent|''
name|'env'
op|'['
string|"'swift.content_type_overridden'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'env'
op|'['
string|"'CONTENT_TYPE'"
op|']'
op|'+='
string|'";swift_bytes=%d"'
op|'%'
name|'total_size'
newline|'\n'
name|'env'
op|'['
string|"'HTTP_X_STATIC_LARGE_OBJECT'"
op|']'
op|'='
string|"'True'"
newline|'\n'
name|'json_data'
op|'='
name|'json'
op|'.'
name|'dumps'
op|'('
name|'data_for_storage'
op|')'
newline|'\n'
name|'if'
name|'six'
op|'.'
name|'PY3'
op|':'
newline|'\n'
indent|'            '
name|'json_data'
op|'='
name|'json_data'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
dedent|''
name|'env'
op|'['
string|"'CONTENT_LENGTH'"
op|']'
op|'='
name|'str'
op|'('
name|'len'
op|'('
name|'json_data'
op|')'
op|')'
newline|'\n'
name|'env'
op|'['
string|"'wsgi.input'"
op|']'
op|'='
name|'BytesIO'
op|'('
name|'json_data'
op|')'
newline|'\n'
nl|'\n'
name|'slo_put_context'
op|'='
name|'SloPutContext'
op|'('
name|'self'
op|','
name|'slo_etag'
op|')'
newline|'\n'
name|'return'
name|'slo_put_context'
op|'.'
name|'handle_slo_put'
op|'('
name|'req'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_segments_to_delete_iter
dedent|''
name|'def'
name|'get_segments_to_delete_iter'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A generator function to be used to delete all the segments and\n        sub-segments referenced in a manifest.\n\n        :params req: a swob.Request with an SLO manifest in path\n        :raises HTTPPreconditionFailed: on invalid UTF8 in request path\n        :raises HTTPBadRequest: on too many buffered sub segments and\n                                on invalid SLO manifest path\n        """'
newline|'\n'
name|'if'
name|'not'
name|'check_utf8'
op|'('
name|'req'
op|'.'
name|'path_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPPreconditionFailed'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
name|'body'
op|'='
string|"'Invalid UTF8 or contains NULL'"
op|')'
newline|'\n'
dedent|''
name|'vrs'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'4'
op|','
number|'4'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'segments'
op|'='
op|'['
op|'{'
nl|'\n'
string|"'sub_slo'"
op|':'
name|'True'
op|','
nl|'\n'
string|"'name'"
op|':'
op|'('
string|"'/%s/%s'"
op|'%'
op|'('
name|'container'
op|','
name|'obj'
op|')'
op|')'
op|'.'
name|'decode'
op|'('
string|"'utf-8'"
op|')'
op|'}'
op|']'
newline|'\n'
name|'while'
name|'segments'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'segments'
op|')'
op|'>'
name|'MAX_BUFFERED_SLO_SEGMENTS'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'HTTPBadRequest'
op|'('
nl|'\n'
string|"'Too many buffered slo segments to delete.'"
op|')'
newline|'\n'
dedent|''
name|'seg_data'
op|'='
name|'segments'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'if'
name|'seg_data'
op|'.'
name|'get'
op|'('
string|"'sub_slo'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'segments'
op|'.'
name|'extend'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'get_slo_segments'
op|'('
name|'seg_data'
op|'['
string|"'name'"
op|']'
op|','
name|'req'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'HTTPException'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|'# allow bulk delete response to report errors'
nl|'\n'
indent|'                    '
name|'seg_data'
op|'['
string|"'error'"
op|']'
op|'='
op|'{'
string|"'code'"
op|':'
name|'err'
op|'.'
name|'status_int'
op|','
nl|'\n'
string|"'message'"
op|':'
name|'err'
op|'.'
name|'body'
op|'}'
newline|'\n'
nl|'\n'
comment|'# add manifest back to be deleted after segments'
nl|'\n'
dedent|''
name|'seg_data'
op|'['
string|"'sub_slo'"
op|']'
op|'='
name|'False'
newline|'\n'
name|'segments'
op|'.'
name|'append'
op|'('
name|'seg_data'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'seg_data'
op|'['
string|"'name'"
op|']'
op|'='
name|'seg_data'
op|'['
string|"'name'"
op|']'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
name|'yield'
name|'seg_data'
newline|'\n'
nl|'\n'
DECL|member|get_slo_segments
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_slo_segments'
op|'('
name|'self'
op|','
name|'obj_name'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Performs a swob.Request and returns the SLO manifest\'s segments.\n\n        :raises HTTPServerError: on unable to load obj_name or\n                                 on unable to load the SLO manifest data.\n        :raises HTTPBadRequest: on not an SLO manifest\n        :raises HTTPNotFound: on SLO manifest not found\n        :returns: SLO manifest\'s segments\n        """'
newline|'\n'
name|'vrs'
op|','
name|'account'
op|','
name|'_junk'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'2'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
name|'new_env'
op|'='
name|'req'
op|'.'
name|'environ'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'new_env'
op|'['
string|"'REQUEST_METHOD'"
op|']'
op|'='
string|"'GET'"
newline|'\n'
name|'del'
op|'('
name|'new_env'
op|'['
string|"'wsgi.input'"
op|']'
op|')'
newline|'\n'
name|'new_env'
op|'['
string|"'QUERY_STRING'"
op|']'
op|'='
string|"'multipart-manifest=get'"
newline|'\n'
name|'new_env'
op|'['
string|"'CONTENT_LENGTH'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'new_env'
op|'['
string|"'HTTP_USER_AGENT'"
op|']'
op|'='
string|"'%s MultipartDELETE'"
op|'%'
name|'new_env'
op|'.'
name|'get'
op|'('
string|"'HTTP_USER_AGENT'"
op|')'
newline|'\n'
name|'new_env'
op|'['
string|"'swift.source'"
op|']'
op|'='
string|"'SLO'"
newline|'\n'
name|'new_env'
op|'['
string|"'PATH_INFO'"
op|']'
op|'='
op|'('
nl|'\n'
string|"'/%s/%s/%s'"
op|'%'
op|'('
name|'vrs'
op|','
name|'account'
op|','
name|'obj_name'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|')'
nl|'\n'
op|')'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
name|'resp'
op|'='
name|'Request'
op|'.'
name|'blank'
op|'('
string|"''"
op|','
name|'new_env'
op|')'
op|'.'
name|'get_response'
op|'('
name|'self'
op|'.'
name|'app'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'resp'
op|'.'
name|'is_success'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'config_true_value'
op|'('
name|'resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Static-Large-Object'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'json'
op|'.'
name|'loads'
op|'('
name|'resp'
op|'.'
name|'body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'HTTPServerError'
op|'('
string|"'Unable to load SLO manifest'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'HTTPBadRequest'
op|'('
string|"'Not an SLO manifest'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'resp'
op|'.'
name|'status_int'
op|'=='
name|'HTTP_NOT_FOUND'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPNotFound'
op|'('
string|"'SLO manifest not found'"
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'resp'
op|'.'
name|'status_int'
op|'=='
name|'HTTP_UNAUTHORIZED'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPUnauthorized'
op|'('
string|"'401 Unauthorized'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPServerError'
op|'('
string|"'Unable to load SLO manifest or segment.'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_multipart_delete
dedent|''
dedent|''
name|'def'
name|'handle_multipart_delete'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Will delete all the segments in the SLO manifest and then, if\n        successful, will delete the manifest file.\n\n        :params req: a swob.Request with an obj in path\n        :returns: swob.Response whose app_iter set to Bulk.handle_delete_iter\n        """'
newline|'\n'
name|'resp'
op|'='
name|'HTTPOk'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
name|'out_content_type'
op|'='
name|'req'
op|'.'
name|'accept'
op|'.'
name|'best_match'
op|'('
name|'ACCEPTABLE_FORMATS'
op|')'
newline|'\n'
name|'if'
name|'out_content_type'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'.'
name|'content_type'
op|'='
name|'out_content_type'
newline|'\n'
dedent|''
name|'resp'
op|'.'
name|'app_iter'
op|'='
name|'self'
op|'.'
name|'bulk_deleter'
op|'.'
name|'handle_delete_iter'
op|'('
nl|'\n'
name|'req'
op|','
name|'objs_to_delete'
op|'='
name|'self'
op|'.'
name|'get_segments_to_delete_iter'
op|'('
name|'req'
op|')'
op|','
nl|'\n'
name|'user_agent'
op|'='
string|"'MultipartDELETE'"
op|','
name|'swift_source'
op|'='
string|"'SLO'"
op|','
nl|'\n'
name|'out_content_type'
op|'='
name|'out_content_type'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'env'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        WSGI entry point\n        """'
newline|'\n'
name|'req'
op|'='
name|'Request'
op|'('
name|'env'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vrs'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'4'
op|','
number|'4'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'app'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
comment|'# install our COPY-callback hook'
nl|'\n'
dedent|''
name|'env'
op|'['
string|"'swift.copy_hook'"
op|']'
op|'='
name|'self'
op|'.'
name|'copy_hook'
op|'('
nl|'\n'
name|'env'
op|'.'
name|'get'
op|'('
string|"'swift.copy_hook'"
op|','
nl|'\n'
name|'lambda'
name|'src_req'
op|','
name|'src_resp'
op|','
name|'sink_req'
op|':'
name|'src_resp'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'PUT'"
name|'and'
name|'req'
op|'.'
name|'params'
op|'.'
name|'get'
op|'('
string|"'multipart-manifest'"
op|')'
op|'=='
string|"'put'"
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'handle_multipart_put'
op|'('
name|'req'
op|','
name|'start_response'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'DELETE'"
name|'and'
name|'req'
op|'.'
name|'params'
op|'.'
name|'get'
op|'('
string|"'multipart-manifest'"
op|')'
op|'=='
string|"'delete'"
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'handle_multipart_delete'
op|'('
name|'req'
op|')'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'GET'"
name|'or'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'handle_multipart_get_or_head'
op|'('
name|'req'
op|','
name|'start_response'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'X-Static-Large-Object'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'HTTPBadRequest'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
nl|'\n'
name|'body'
op|'='
string|"'X-Static-Large-Object is a reserved header. '"
nl|'\n'
string|"'To create a static large object add query param '"
nl|'\n'
string|"'multipart-manifest=put.'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'HTTPException'
name|'as'
name|'err_resp'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'err_resp'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'app'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|filter_factory
dedent|''
dedent|''
name|'def'
name|'filter_factory'
op|'('
name|'global_conf'
op|','
op|'**'
name|'local_conf'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'conf'
op|'='
name|'global_conf'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'conf'
op|'.'
name|'update'
op|'('
name|'local_conf'
op|')'
newline|'\n'
nl|'\n'
name|'max_manifest_segments'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'max_manifest_segments'"
op|','
nl|'\n'
name|'DEFAULT_MAX_MANIFEST_SEGMENTS'
op|')'
op|')'
newline|'\n'
name|'max_manifest_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'max_manifest_size'"
op|','
nl|'\n'
name|'DEFAULT_MAX_MANIFEST_SIZE'
op|')'
op|')'
newline|'\n'
name|'min_segment_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'min_segment_size'"
op|','
nl|'\n'
name|'DEFAULT_MIN_SEGMENT_SIZE'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'register_swift_info'
op|'('
string|"'slo'"
op|','
nl|'\n'
name|'max_manifest_segments'
op|'='
name|'max_manifest_segments'
op|','
nl|'\n'
name|'max_manifest_size'
op|'='
name|'max_manifest_size'
op|','
nl|'\n'
name|'min_segment_size'
op|'='
name|'min_segment_size'
op|')'
newline|'\n'
nl|'\n'
DECL|function|slo_filter
name|'def'
name|'slo_filter'
op|'('
name|'app'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'StaticLargeObject'
op|'('
nl|'\n'
name|'app'
op|','
name|'conf'
op|','
nl|'\n'
name|'max_manifest_segments'
op|'='
name|'max_manifest_segments'
op|','
nl|'\n'
name|'max_manifest_size'
op|'='
name|'max_manifest_size'
op|','
nl|'\n'
name|'min_segment_size'
op|'='
name|'min_segment_size'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'slo_filter'
newline|'\n'
dedent|''
endmarker|''
end_unit
