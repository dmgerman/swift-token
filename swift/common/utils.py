begin_unit
comment|'# Copyright (c) 2010 OpenStack, LLC.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
string|'"""Miscellaneous utility functions for use with Swift."""'
newline|'\n'
nl|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'fcntl'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'pwd'
newline|'\n'
name|'import'
name|'signal'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'mimetools'
newline|'\n'
name|'from'
name|'hashlib'
name|'import'
name|'md5'
newline|'\n'
name|'from'
name|'random'
name|'import'
name|'shuffle'
newline|'\n'
name|'from'
name|'urllib'
name|'import'
name|'quote'
newline|'\n'
name|'from'
name|'contextlib'
name|'import'
name|'contextmanager'
newline|'\n'
name|'import'
name|'ctypes'
newline|'\n'
name|'import'
name|'ctypes'
op|'.'
name|'util'
newline|'\n'
name|'import'
name|'struct'
newline|'\n'
name|'from'
name|'ConfigParser'
name|'import'
name|'ConfigParser'
op|','
name|'NoSectionError'
op|','
name|'NoOptionError'
newline|'\n'
name|'from'
name|'optparse'
name|'import'
name|'OptionParser'
newline|'\n'
name|'from'
name|'tempfile'
name|'import'
name|'mkstemp'
newline|'\n'
name|'import'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
nl|'\n'
nl|'\n'
name|'import'
name|'eventlet'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenio'
op|','
name|'GreenPool'
op|','
name|'sleep'
op|','
name|'Timeout'
op|','
name|'listen'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'green'
name|'import'
name|'socket'
op|','
name|'subprocess'
op|','
name|'ssl'
op|','
name|'thread'
op|','
name|'threading'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'LockTimeout'
op|','
name|'MessageTimeout'
newline|'\n'
nl|'\n'
comment|"# logging doesn't import patched as cleanly as one would like"
nl|'\n'
name|'from'
name|'logging'
op|'.'
name|'handlers'
name|'import'
name|'SysLogHandler'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'logging'
op|'.'
name|'thread'
op|'='
name|'eventlet'
op|'.'
name|'green'
op|'.'
name|'thread'
newline|'\n'
name|'logging'
op|'.'
name|'threading'
op|'='
name|'eventlet'
op|'.'
name|'green'
op|'.'
name|'threading'
newline|'\n'
name|'logging'
op|'.'
name|'_lock'
op|'='
name|'logging'
op|'.'
name|'threading'
op|'.'
name|'RLock'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# These are lazily pulled from libc elsewhere'
nl|'\n'
DECL|variable|_sys_fallocate
name|'_sys_fallocate'
op|'='
name|'None'
newline|'\n'
DECL|variable|_posix_fadvise
name|'_posix_fadvise'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Used by hash_path to offer a bit more security when generating hashes for'
nl|'\n'
comment|'# paths. It simply appends this value to all paths; guessing the hash a path'
nl|'\n'
comment|'# will end up with would also require knowing this suffix.'
nl|'\n'
DECL|variable|hash_conf
name|'hash_conf'
op|'='
name|'ConfigParser'
op|'('
op|')'
newline|'\n'
DECL|variable|HASH_PATH_SUFFIX
name|'HASH_PATH_SUFFIX'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'hash_conf'
op|'.'
name|'read'
op|'('
string|"'/etc/swift/swift.conf'"
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
DECL|variable|HASH_PATH_SUFFIX
indent|'        '
name|'HASH_PATH_SUFFIX'
op|'='
name|'hash_conf'
op|'.'
name|'get'
op|'('
string|"'swift-hash'"
op|','
nl|'\n'
string|"'swift_hash_path_suffix'"
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'NoSectionError'
op|','
name|'NoOptionError'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# Used when reading config values'
nl|'\n'
DECL|variable|TRUE_VALUES
dedent|''
dedent|''
name|'TRUE_VALUES'
op|'='
name|'set'
op|'('
op|'('
string|"'true'"
op|','
string|"'1'"
op|','
string|"'yes'"
op|','
string|"'True'"
op|','
string|"'Yes'"
op|','
string|"'on'"
op|','
string|"'On'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|validate_configuration
name|'def'
name|'validate_configuration'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'HASH_PATH_SUFFIX'
op|'=='
string|"''"
op|':'
newline|'\n'
indent|'        '
name|'sys'
op|'.'
name|'exit'
op|'('
string|'"Error: [swift-hash]: swift_hash_path_suffix missing "'
nl|'\n'
string|'"from /etc/swift/swift.conf"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|load_libc_function
dedent|''
dedent|''
name|'def'
name|'load_libc_function'
op|'('
name|'func_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Attempt to find the function in libc, otherwise return a no-op func.\n\n    :param func_name: name of the function to pull from libc.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'libc'
op|'='
name|'ctypes'
op|'.'
name|'CDLL'
op|'('
name|'ctypes'
op|'.'
name|'util'
op|'.'
name|'find_library'
op|'('
string|"'c'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'getattr'
op|'('
name|'libc'
op|','
name|'func_name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'        '
name|'logging'
op|'.'
name|'warn'
op|'('
string|'"Unable to locate %s in libc.  Leaving as a no-op."'
nl|'\n'
op|'%'
name|'func_name'
op|')'
newline|'\n'
nl|'\n'
DECL|function|noop_libc_function
name|'def'
name|'noop_libc_function'
op|'('
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'return'
name|'noop_libc_function'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_param
dedent|''
dedent|''
name|'def'
name|'get_param'
op|'('
name|'req'
op|','
name|'name'
op|','
name|'default'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get parameters from an HTTP request ensuring proper handling UTF-8\n    encoding.\n\n    :param req: Webob request object\n    :param name: parameter name\n    :param default: result to return if the parameter is not found\n    :returns: HTTP request parameter value\n    """'
newline|'\n'
name|'value'
op|'='
name|'req'
op|'.'
name|'str_params'
op|'.'
name|'get'
op|'('
name|'name'
op|','
name|'default'
op|')'
newline|'\n'
name|'if'
name|'value'
op|':'
newline|'\n'
indent|'        '
name|'value'
op|'.'
name|'decode'
op|'('
string|"'utf8'"
op|')'
comment|'# Ensure UTF8ness'
newline|'\n'
dedent|''
name|'return'
name|'value'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|fallocate
dedent|''
name|'def'
name|'fallocate'
op|'('
name|'fd'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pre-allocate disk space for a file file.\n\n    :param fd: file descriptor\n    :param size: size to allocate (in bytes)\n    """'
newline|'\n'
name|'global'
name|'_sys_fallocate'
newline|'\n'
name|'if'
name|'_sys_fallocate'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'_sys_fallocate'
op|'='
name|'load_libc_function'
op|'('
string|"'fallocate'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'size'
op|'>'
number|'0'
op|':'
newline|'\n'
comment|'# 1 means "FALLOC_FL_KEEP_SIZE", which means it pre-allocates invisibly'
nl|'\n'
indent|'        '
name|'ret'
op|'='
name|'_sys_fallocate'
op|'('
name|'fd'
op|','
number|'1'
op|','
number|'0'
op|','
name|'ctypes'
op|'.'
name|'c_uint64'
op|'('
name|'size'
op|')'
op|')'
newline|'\n'
comment|'# XXX: in (not very thorough) testing, errno always seems to be 0?'
nl|'\n'
name|'err'
op|'='
name|'ctypes'
op|'.'
name|'get_errno'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ret'
name|'and'
name|'err'
name|'not'
name|'in'
op|'('
number|'0'
op|','
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'OSError'
op|'('
name|'err'
op|','
string|"'Unable to fallocate(%s)'"
op|'%'
name|'size'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|drop_buffer_cache
dedent|''
dedent|''
dedent|''
name|'def'
name|'drop_buffer_cache'
op|'('
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Drop \'buffer\' cache for the given range of the given file.\n\n    :param fd: file descriptor\n    :param offset: start offset\n    :param length: length\n    """'
newline|'\n'
name|'global'
name|'_posix_fadvise'
newline|'\n'
name|'if'
name|'_posix_fadvise'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'_posix_fadvise'
op|'='
name|'load_libc_function'
op|'('
string|"'posix_fadvise'"
op|')'
newline|'\n'
comment|'# 4 means "POSIX_FADV_DONTNEED"'
nl|'\n'
dedent|''
name|'ret'
op|'='
name|'_posix_fadvise'
op|'('
name|'fd'
op|','
name|'ctypes'
op|'.'
name|'c_uint64'
op|'('
name|'offset'
op|')'
op|','
nl|'\n'
name|'ctypes'
op|'.'
name|'c_uint64'
op|'('
name|'length'
op|')'
op|','
number|'4'
op|')'
newline|'\n'
name|'if'
name|'ret'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'logging'
op|'.'
name|'warn'
op|'('
string|'"posix_fadvise(%s, %s, %s, 4) -> %s"'
nl|'\n'
op|'%'
op|'('
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|','
name|'ret'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|normalize_timestamp
dedent|''
dedent|''
name|'def'
name|'normalize_timestamp'
op|'('
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Format a timestamp (string or numeric) into a standardized\n    xxxxxxxxxx.xxxxx format.\n\n    :param timestamp: unix timestamp\n    :returns: normalized timestamp as a string\n    """'
newline|'\n'
name|'return'
string|'"%016.05f"'
op|'%'
op|'('
name|'float'
op|'('
name|'timestamp'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|mkdirs
dedent|''
name|'def'
name|'mkdirs'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Ensures the path is a directory or makes it if not. Errors if the path\n    exists but is a file or on permissions failure.\n\n    :param path: path to create\n    """'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'EEXIST'
name|'or'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|renamer
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'renamer'
op|'('
name|'old'
op|','
name|'new'
op|')'
op|':'
comment|'# pragma: no cover'
newline|'\n'
indent|'    '
string|'"""\n    Attempt to fix^H^H^Hhide race conditions like empty object directories\n    being removed by backend processes during uploads, by retrying.\n\n    :param old: old path to be renamed\n    :param new: new path to be renamed to\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'mkdirs'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'new'
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'rename'
op|'('
name|'old'
op|','
name|'new'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'        '
name|'mkdirs'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'new'
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'rename'
op|'('
name|'old'
op|','
name|'new'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|split_path
dedent|''
dedent|''
name|'def'
name|'split_path'
op|'('
name|'path'
op|','
name|'minsegs'
op|'='
number|'1'
op|','
name|'maxsegs'
op|'='
name|'None'
op|','
name|'rest_with_last'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Validate and split the given HTTP request path.\n\n    **Examples**::\n\n        [\'a\'] = split_path(\'/a\')\n        [\'a\', None] = split_path(\'/a\', 1, 2)\n        [\'a\', \'c\'] = split_path(\'/a/c\', 1, 2)\n        [\'a\', \'c\', \'o/r\'] = split_path(\'/a/c/o/r\', 1, 3, True)\n\n    :param path: HTTP Request path to be split\n    :param minsegs: Minimum number of segments to be extracted\n    :param maxsegs: Maximum number of segments to be extracted\n    :param rest_with_last: If True, trailing data will be returned as part\n                           of last segment.  If False, and there is\n                           trailing data, raises ValueError.\n    :returns: list of segments with a length of maxsegs (non-existant\n              segments will return as None)\n    :raises: ValueError if given an invalid path\n    """'
newline|'\n'
name|'if'
name|'not'
name|'maxsegs'
op|':'
newline|'\n'
indent|'        '
name|'maxsegs'
op|'='
name|'minsegs'
newline|'\n'
dedent|''
name|'if'
name|'minsegs'
op|'>'
name|'maxsegs'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|'('
string|"'minsegs > maxsegs: %d > %d'"
op|'%'
op|'('
name|'minsegs'
op|','
name|'maxsegs'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'rest_with_last'
op|':'
newline|'\n'
indent|'        '
name|'segs'
op|'='
name|'path'
op|'.'
name|'split'
op|'('
string|"'/'"
op|','
name|'maxsegs'
op|')'
newline|'\n'
name|'minsegs'
op|'+='
number|'1'
newline|'\n'
name|'maxsegs'
op|'+='
number|'1'
newline|'\n'
name|'count'
op|'='
name|'len'
op|'('
name|'segs'
op|')'
newline|'\n'
name|'if'
name|'segs'
op|'['
number|'0'
op|']'
name|'or'
name|'count'
op|'<'
name|'minsegs'
name|'or'
name|'count'
op|'>'
name|'maxsegs'
name|'or'
string|"''"
name|'in'
name|'segs'
op|'['
number|'1'
op|':'
name|'minsegs'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Invalid path: %s'"
op|'%'
name|'quote'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'minsegs'
op|'+='
number|'1'
newline|'\n'
name|'maxsegs'
op|'+='
number|'1'
newline|'\n'
name|'segs'
op|'='
name|'path'
op|'.'
name|'split'
op|'('
string|"'/'"
op|','
name|'maxsegs'
op|')'
newline|'\n'
name|'count'
op|'='
name|'len'
op|'('
name|'segs'
op|')'
newline|'\n'
name|'if'
name|'segs'
op|'['
number|'0'
op|']'
name|'or'
name|'count'
op|'<'
name|'minsegs'
name|'or'
name|'count'
op|'>'
name|'maxsegs'
op|'+'
number|'1'
name|'or'
string|"''"
name|'in'
name|'segs'
op|'['
number|'1'
op|':'
name|'minsegs'
op|']'
name|'or'
op|'('
name|'count'
op|'=='
name|'maxsegs'
op|'+'
number|'1'
name|'and'
name|'segs'
op|'['
name|'maxsegs'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Invalid path: %s'"
op|'%'
name|'quote'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'segs'
op|'='
name|'segs'
op|'['
number|'1'
op|':'
name|'maxsegs'
op|']'
newline|'\n'
name|'segs'
op|'.'
name|'extend'
op|'('
op|'['
name|'None'
op|']'
op|'*'
op|'('
name|'maxsegs'
op|'-'
number|'1'
op|'-'
name|'len'
op|'('
name|'segs'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'segs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NullLogger
dedent|''
name|'class'
name|'NullLogger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A no-op logger for eventlet wsgi."""'
newline|'\n'
nl|'\n'
DECL|member|write
name|'def'
name|'write'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
comment|'#"Logs" the args to nowhere'
nl|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoggerFileObject
dedent|''
dedent|''
name|'class'
name|'LoggerFileObject'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'logger'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'value'
op|'='
name|'value'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'value'
op|':'
newline|'\n'
indent|'            '
name|'if'
string|"'Connection reset by peer'"
name|'in'
name|'value'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
string|"'STDOUT: Connection reset by peer'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
string|"'STDOUT: %s'"
op|'%'
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|member|writelines
dedent|''
dedent|''
dedent|''
name|'def'
name|'writelines'
op|'('
name|'self'
op|','
name|'values'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
string|"'STDOUT: %s'"
op|'%'
string|"'#012'"
op|'.'
name|'join'
op|'('
name|'values'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|flush
dedent|''
name|'def'
name|'flush'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|next
dedent|''
name|'def'
name|'next'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EBADF'
op|','
string|"'Bad file descriptor'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|','
name|'size'
op|'='
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EBADF'
op|','
string|"'Bad file descriptor'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|readline
dedent|''
name|'def'
name|'readline'
op|'('
name|'self'
op|','
name|'size'
op|'='
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EBADF'
op|','
string|"'Bad file descriptor'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|tell
dedent|''
name|'def'
name|'tell'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
DECL|member|xreadlines
dedent|''
name|'def'
name|'xreadlines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NamedLogger
dedent|''
dedent|''
name|'class'
name|'NamedLogger'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Cheesy version of the LoggerAdapter available in Python 3"""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'logger'
op|','
name|'server'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'server'
op|'='
name|'server'
newline|'\n'
name|'for'
name|'proxied_method'
name|'in'
op|'('
string|"'debug'"
op|','
string|"'info'"
op|','
string|"'log'"
op|','
string|"'warn'"
op|','
string|"'warning'"
op|','
nl|'\n'
string|"'error'"
op|','
string|"'critical'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'setattr'
op|'('
name|'self'
op|','
name|'proxied_method'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_proxy'
op|'('
name|'getattr'
op|'('
name|'logger'
op|','
name|'proxied_method'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_proxy
dedent|''
dedent|''
name|'def'
name|'_proxy'
op|'('
name|'self'
op|','
name|'logger_meth'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|function|_inner_proxy
indent|'        '
name|'def'
name|'_inner_proxy'
op|'('
name|'msg'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|"'%s %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'server'
op|','
name|'msg'
op|')'
newline|'\n'
name|'logger_meth'
op|'('
name|'msg'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'_inner_proxy'
newline|'\n'
nl|'\n'
DECL|member|getEffectiveLevel
dedent|''
name|'def'
name|'getEffectiveLevel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'logger'
op|'.'
name|'getEffectiveLevel'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|exception
dedent|''
name|'def'
name|'exception'
op|'('
name|'self'
op|','
name|'msg'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_'
op|','
name|'exc'
op|','
name|'_'
op|'='
name|'sys'
op|'.'
name|'exc_info'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
newline|'\n'
name|'emsg'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'exc'
op|','
name|'OSError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'exc'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'EIO'
op|','
name|'errno'
op|'.'
name|'ENOSPC'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'emsg'
op|'='
name|'str'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'call'
op|'='
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'exc'
op|','
name|'socket'
op|'.'
name|'error'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'exc'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ECONNREFUSED'
op|':'
newline|'\n'
indent|'                '
name|'emsg'
op|'='
string|"'Connection refused'"
newline|'\n'
dedent|''
name|'elif'
name|'exc'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EHOSTUNREACH'
op|':'
newline|'\n'
indent|'                '
name|'emsg'
op|'='
string|"'Host unreachable'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'call'
op|'='
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'exc'
op|','
name|'eventlet'
op|'.'
name|'Timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'emsg'
op|'='
name|'exc'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'exc'
op|','
string|"'seconds'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'emsg'
op|'+='
string|"' (%ss)'"
op|'%'
name|'exc'
op|'.'
name|'seconds'
newline|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'exc'
op|','
name|'MessageTimeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'exc'
op|'.'
name|'msg'
op|':'
newline|'\n'
indent|'                    '
name|'emsg'
op|'+='
string|"' %s'"
op|'%'
name|'exc'
op|'.'
name|'msg'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'call'
op|'='
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
newline|'\n'
dedent|''
name|'call'
op|'('
string|"'%s %s: %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'server'
op|','
name|'msg'
op|','
name|'emsg'
op|')'
op|','
op|'*'
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_logger
dedent|''
dedent|''
name|'def'
name|'get_logger'
op|'('
name|'conf'
op|','
name|'name'
op|'='
name|'None'
op|','
name|'log_to_console'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get the current system logger using config settings.\n\n    **Log config and defaults**::\n\n        log_facility = LOG_LOCAL0\n        log_level = INFO\n        log_name = swift\n\n    :param conf: Configuration dict to read settings from\n    :param name: Name of the logger\n    :param log_to_console: Add handler which writes to console on stderr\n    """'
newline|'\n'
name|'root_logger'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'get_logger'
op|','
string|"'handler'"
op|')'
name|'and'
name|'get_logger'
op|'.'
name|'handler'
op|':'
newline|'\n'
indent|'        '
name|'root_logger'
op|'.'
name|'removeHandler'
op|'('
name|'get_logger'
op|'.'
name|'handler'
op|')'
newline|'\n'
name|'get_logger'
op|'.'
name|'handler'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'log_to_console'
op|':'
newline|'\n'
comment|'# check if a previous call to get_logger already added a console logger'
nl|'\n'
indent|'        '
name|'if'
name|'hasattr'
op|'('
name|'get_logger'
op|','
string|"'console'"
op|')'
name|'and'
name|'get_logger'
op|'.'
name|'console'
op|':'
newline|'\n'
indent|'            '
name|'root_logger'
op|'.'
name|'removeHandler'
op|'('
name|'get_logger'
op|'.'
name|'console'
op|')'
newline|'\n'
dedent|''
name|'get_logger'
op|'.'
name|'console'
op|'='
name|'logging'
op|'.'
name|'StreamHandler'
op|'('
name|'sys'
op|'.'
name|'__stderr__'
op|')'
newline|'\n'
name|'root_logger'
op|'.'
name|'addHandler'
op|'('
name|'get_logger'
op|'.'
name|'console'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'conf'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'root_logger'
op|'.'
name|'setLevel'
op|'('
name|'logging'
op|'.'
name|'INFO'
op|')'
newline|'\n'
name|'return'
name|'NamedLogger'
op|'('
name|'root_logger'
op|','
name|'name'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'name'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'name'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'log_name'"
op|','
string|"'swift'"
op|')'
newline|'\n'
dedent|''
name|'get_logger'
op|'.'
name|'handler'
op|'='
name|'SysLogHandler'
op|'('
name|'address'
op|'='
string|"'/dev/log'"
op|','
nl|'\n'
name|'facility'
op|'='
name|'getattr'
op|'('
name|'SysLogHandler'
op|','
nl|'\n'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'log_facility'"
op|','
string|"'LOG_LOCAL0'"
op|')'
op|','
nl|'\n'
name|'SysLogHandler'
op|'.'
name|'LOG_LOCAL0'
op|')'
op|')'
newline|'\n'
name|'root_logger'
op|'.'
name|'addHandler'
op|'('
name|'get_logger'
op|'.'
name|'handler'
op|')'
newline|'\n'
name|'root_logger'
op|'.'
name|'setLevel'
op|'('
nl|'\n'
name|'getattr'
op|'('
name|'logging'
op|','
name|'conf'
op|'.'
name|'get'
op|'('
string|"'log_level'"
op|','
string|"'INFO'"
op|')'
op|'.'
name|'upper'
op|'('
op|')'
op|','
name|'logging'
op|'.'
name|'INFO'
op|')'
op|')'
newline|'\n'
name|'return'
name|'NamedLogger'
op|'('
name|'root_logger'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|drop_privileges
dedent|''
name|'def'
name|'drop_privileges'
op|'('
name|'user'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Sets the userid/groupid of the current process, get session leader, etc.\n\n    :param user: User name to change privileges to\n    """'
newline|'\n'
name|'user'
op|'='
name|'pwd'
op|'.'
name|'getpwnam'
op|'('
name|'user'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setgid'
op|'('
name|'user'
op|'['
number|'3'
op|']'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setuid'
op|'('
name|'user'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'setsid'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'chdir'
op|'('
string|"'/'"
op|')'
comment|'# in case you need to rmdir on where you started the daemon'
newline|'\n'
name|'os'
op|'.'
name|'umask'
op|'('
number|'0'
op|')'
comment|'# ensure files are created with the correct privileges'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|capture_stdio
dedent|''
name|'def'
name|'capture_stdio'
op|'('
name|'logger'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Log unhandled exceptions, close stdio, capture stdout and stderr.\n\n    param logger: Logger object to use\n    """'
newline|'\n'
comment|'# log uncaught exceptions'
nl|'\n'
name|'sys'
op|'.'
name|'excepthook'
op|'='
name|'lambda'
op|'*'
name|'exc_info'
op|':'
name|'logger'
op|'.'
name|'critical'
op|'('
string|"'UNCAUGHT EXCEPTION'"
op|','
name|'exc_info'
op|'='
name|'exc_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# collect stdio file desc not in use for logging'
nl|'\n'
name|'stdio_fds'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'get_logger'
op|','
string|"'console'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'stdio_fds'
op|'.'
name|'remove'
op|'('
name|'get_logger'
op|'.'
name|'console'
op|'.'
name|'stream'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'open'
op|'('
name|'os'
op|'.'
name|'devnull'
op|','
string|"'r+b'"
op|')'
name|'as'
name|'nullfile'
op|':'
newline|'\n'
comment|'# close stdio (excludes fds open for logging)'
nl|'\n'
indent|'        '
name|'for'
name|'desc'
name|'in'
name|'stdio_fds'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'dup2'
op|'('
name|'nullfile'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'desc'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# redirect stdio'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'capture_stdout'"
op|','
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sys'
op|'.'
name|'stdout'
op|'='
name|'LoggerFileObject'
op|'('
name|'logger'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'capture_stderr'"
op|','
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sys'
op|'.'
name|'stderr'
op|'='
name|'LoggerFileObject'
op|'('
name|'logger'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_options
dedent|''
dedent|''
name|'def'
name|'parse_options'
op|'('
name|'usage'
op|'='
string|'"%prog CONFIG [options]"'
op|','
name|'once'
op|'='
name|'False'
op|','
name|'test_args'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parse standard swift server/daemon options with optparse.OptionParser.\n\n    :param usage: String describing usage\n    :param once: Boolean indicating the "once" option is available\n    :param test_args: Override sys.argv; used in testing\n\n    :returns : Tuple of (config, options); config is an absolute path to the\n               config file, options is the parser options as a dictionary.\n\n    :raises SystemExit: First arg (CONFIG) is required, file must exist\n    """'
newline|'\n'
name|'parser'
op|'='
name|'OptionParser'
op|'('
name|'usage'
op|')'
newline|'\n'
name|'parser'
op|'.'
name|'add_option'
op|'('
string|'"-v"'
op|','
string|'"--verbose"'
op|','
name|'default'
op|'='
name|'False'
op|','
name|'action'
op|'='
string|'"store_true"'
op|','
nl|'\n'
name|'help'
op|'='
string|'"log to console"'
op|')'
newline|'\n'
name|'if'
name|'once'
op|':'
newline|'\n'
indent|'        '
name|'parser'
op|'.'
name|'add_option'
op|'('
string|'"-o"'
op|','
string|'"--once"'
op|','
name|'default'
op|'='
name|'False'
op|','
name|'action'
op|'='
string|'"store_true"'
op|','
nl|'\n'
name|'help'
op|'='
string|'"only run one pass of daemon"'
op|')'
newline|'\n'
nl|'\n'
comment|'# if test_args is None, optparse will use sys.argv[:1]'
nl|'\n'
dedent|''
name|'options'
op|','
name|'args'
op|'='
name|'parser'
op|'.'
name|'parse_args'
op|'('
name|'args'
op|'='
name|'test_args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'args'
op|':'
newline|'\n'
indent|'        '
name|'parser'
op|'.'
name|'print_usage'
op|'('
op|')'
newline|'\n'
name|'print'
string|'"Error: missing config file argument"'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'config'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'args'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'config'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'parser'
op|'.'
name|'print_usage'
op|'('
op|')'
newline|'\n'
name|'print'
string|'"Error: unable to locate %s"'
op|'%'
name|'config'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'extra_args'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# if any named options appear in remaining args, set the option to True'
nl|'\n'
name|'for'
name|'arg'
name|'in'
name|'args'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'arg'
name|'in'
name|'options'
op|'.'
name|'__dict__'
op|':'
newline|'\n'
indent|'            '
name|'setattr'
op|'('
name|'options'
op|','
name|'arg'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'extra_args'
op|'.'
name|'append'
op|'('
name|'arg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'options'
op|'='
name|'vars'
op|'('
name|'options'
op|')'
newline|'\n'
name|'options'
op|'['
string|"'extra_args'"
op|']'
op|'='
name|'extra_args'
newline|'\n'
name|'return'
name|'config'
op|','
name|'options'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|whataremyips
dedent|''
name|'def'
name|'whataremyips'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get the machine\'s ip addresses using ifconfig\n\n    :returns: list of Strings of IPv4 ip addresses\n    """'
newline|'\n'
name|'proc'
op|'='
name|'subprocess'
op|'.'
name|'Popen'
op|'('
op|'['
string|"'/sbin/ifconfig'"
op|']'
op|','
name|'stdout'
op|'='
name|'subprocess'
op|'.'
name|'PIPE'
op|','
nl|'\n'
name|'stderr'
op|'='
name|'subprocess'
op|'.'
name|'STDOUT'
op|')'
newline|'\n'
name|'ret_val'
op|'='
name|'proc'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'results'
op|'='
name|'proc'
op|'.'
name|'stdout'
op|'.'
name|'read'
op|'('
op|')'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'return'
op|'['
name|'x'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|'['
number|'1'
op|']'
op|'.'
name|'split'
op|'('
op|')'
op|'['
number|'0'
op|']'
name|'for'
name|'x'
name|'in'
name|'results'
name|'if'
string|"'inet addr'"
name|'in'
name|'x'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|storage_directory
dedent|''
name|'def'
name|'storage_directory'
op|'('
name|'datadir'
op|','
name|'partition'
op|','
name|'hash'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get the storage directory\n\n    :param datadir: Base data directory\n    :param partition: Partition\n    :param hash: Account, container or object hash\n    :returns: Storage directory\n    """'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir'
op|','
name|'partition'
op|','
name|'hash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
name|'hash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hash_path
dedent|''
name|'def'
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|'='
name|'None'
op|','
name|'object'
op|'='
name|'None'
op|','
name|'raw_digest'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get the connonical hash for an account/container/object\n\n    :param account: Account\n    :param container: Container\n    :param object: Object\n    :param raw_digest: If True, return the raw version rather than a hex digest\n    :returns: hash string\n    """'
newline|'\n'
name|'if'
name|'object'
name|'and'
name|'not'
name|'container'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|'('
string|"'container is required if object is provided'"
op|')'
newline|'\n'
dedent|''
name|'paths'
op|'='
op|'['
name|'account'
op|']'
newline|'\n'
name|'if'
name|'container'
op|':'
newline|'\n'
indent|'        '
name|'paths'
op|'.'
name|'append'
op|'('
name|'container'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'object'
op|':'
newline|'\n'
indent|'        '
name|'paths'
op|'.'
name|'append'
op|'('
name|'object'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'raw_digest'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'md5'
op|'('
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
name|'paths'
op|')'
op|'+'
name|'HASH_PATH_SUFFIX'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'md5'
op|'('
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
name|'paths'
op|')'
op|'+'
name|'HASH_PATH_SUFFIX'
op|')'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|function|lock_path
name|'def'
name|'lock_path'
op|'('
name|'directory'
op|','
name|'timeout'
op|'='
number|'10'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Context manager that acquires a lock on a directory.  This will block until\n    the lock can be acquired, or the timeout time has expired (whichever occurs\n    first).\n\n    :param directory: directory to be locked\n    :param timeout: timeout (in seconds)\n    """'
newline|'\n'
name|'mkdirs'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'fd'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'directory'
op|','
name|'os'
op|'.'
name|'O_RDONLY'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'LockTimeout'
op|'('
name|'timeout'
op|','
name|'directory'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'fcntl'
op|'.'
name|'flock'
op|'('
name|'fd'
op|','
name|'fcntl'
op|'.'
name|'LOCK_EX'
op|'|'
name|'fcntl'
op|'.'
name|'LOCK_NB'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|','
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'EAGAIN'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'sleep'
op|'('
number|'0.01'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'True'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lock_parent_directory
dedent|''
dedent|''
name|'def'
name|'lock_parent_directory'
op|'('
name|'filename'
op|','
name|'timeout'
op|'='
number|'10'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Context manager that acquires a lock on the parent directory of the given\n    file path.  This will block until the lock can be acquired, or the timeout\n    time has expired (whichever occurs first).\n\n    :param filename: file path of the parent directory to be locked\n    :param timeout: timeout (in seconds)\n    """'
newline|'\n'
name|'return'
name|'lock_path'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'filename'
op|')'
op|','
name|'timeout'
op|'='
name|'timeout'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_time_units
dedent|''
name|'def'
name|'get_time_units'
op|'('
name|'time_amount'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a nomralized length of time in the largest unit of time (hours,\n    minutes, or seconds.)\n\n    :param time_amount: length of time in seconds\n    :returns: A touple of (length of time, unit of time) where unit of time is\n              one of (\'h\', \'m\', \'s\')\n    """'
newline|'\n'
name|'time_unit'
op|'='
string|"'s'"
newline|'\n'
name|'if'
name|'time_amount'
op|'>'
number|'60'
op|':'
newline|'\n'
indent|'        '
name|'time_amount'
op|'/='
number|'60'
newline|'\n'
name|'time_unit'
op|'='
string|"'m'"
newline|'\n'
name|'if'
name|'time_amount'
op|'>'
number|'60'
op|':'
newline|'\n'
indent|'            '
name|'time_amount'
op|'/='
number|'60'
newline|'\n'
name|'time_unit'
op|'='
string|"'h'"
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'time_amount'
op|','
name|'time_unit'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compute_eta
dedent|''
name|'def'
name|'compute_eta'
op|'('
name|'start_time'
op|','
name|'current_value'
op|','
name|'final_value'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Compute an ETA.  Now only if we could also have a progress bar...\n\n    :param start_time: Unix timestamp when the operation began\n    :param current_value: Current value\n    :param final_value: Final value\n    :returns: ETA as a tuple of (length of time, unit of time) where unit of\n              time is one of (\'h\', \'m\', \'s\')\n    """'
newline|'\n'
name|'elapsed'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'start_time'
newline|'\n'
name|'completion'
op|'='
op|'('
name|'float'
op|'('
name|'current_value'
op|')'
op|'/'
name|'final_value'
op|')'
name|'or'
number|'0.00001'
newline|'\n'
name|'return'
name|'get_time_units'
op|'('
number|'1.0'
op|'/'
name|'completion'
op|'*'
name|'elapsed'
op|'-'
name|'elapsed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|iter_devices_partitions
dedent|''
name|'def'
name|'iter_devices_partitions'
op|'('
name|'devices_dir'
op|','
name|'item_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Iterate over partitions accross all devices.\n\n    :param devices_dir: Path to devices\n    :param item_type: One of \'accounts\', \'containers\', or \'objects\'\n    :returns: Each iteration returns a tuple of (device, partition)\n    """'
newline|'\n'
name|'devices'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'devices_dir'
op|')'
newline|'\n'
name|'shuffle'
op|'('
name|'devices'
op|')'
newline|'\n'
name|'devices_partitions'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'device'
name|'in'
name|'devices'
op|':'
newline|'\n'
indent|'        '
name|'partitions'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices_dir'
op|','
name|'device'
op|','
name|'item_type'
op|')'
op|')'
newline|'\n'
name|'shuffle'
op|'('
name|'partitions'
op|')'
newline|'\n'
name|'devices_partitions'
op|'.'
name|'append'
op|'('
op|'('
name|'device'
op|','
name|'iter'
op|'('
name|'partitions'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'yielded'
op|'='
name|'True'
newline|'\n'
name|'while'
name|'yielded'
op|':'
newline|'\n'
indent|'        '
name|'yielded'
op|'='
name|'False'
newline|'\n'
name|'for'
name|'device'
op|','
name|'partitions'
name|'in'
name|'devices_partitions'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'device'
op|','
name|'partitions'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
name|'yielded'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unlink_older_than
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'unlink_older_than'
op|'('
name|'path'
op|','
name|'mtime'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Remove any file in a given path that that was last modified before mtime.\n\n    :param path: path to remove file from\n    :mtime: timestamp of oldest file to keep\n    """'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'fname'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'fpath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'path'
op|','
name|'fname'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'getmtime'
op|'('
name|'fpath'
op|')'
op|'<'
name|'mtime'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'fpath'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|item_from_env
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'item_from_env'
op|'('
name|'env'
op|','
name|'item_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a value from the wsgi environment\n\n    :param env: wsgi environment dict\n    :param item_name: name of item to get\n\n    :returns: the value from the environment\n    """'
newline|'\n'
name|'item'
op|'='
name|'env'
op|'.'
name|'get'
op|'('
name|'item_name'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'item'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'logging'
op|'.'
name|'error'
op|'('
string|'"ERROR: %s could not be found in env!"'
op|'%'
name|'item_name'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'item'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|cache_from_env
dedent|''
name|'def'
name|'cache_from_env'
op|'('
name|'env'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get memcache connection pool from the environment (which had been\n    previously set by the memcache middleware\n\n    :param env: wsgi environment dict\n\n    :returns: swift.common.memcached.MemcacheRing from environment\n    """'
newline|'\n'
name|'return'
name|'item_from_env'
op|'('
name|'env'
op|','
string|"'swift.cache'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|readconf
dedent|''
name|'def'
name|'readconf'
op|'('
name|'conf'
op|','
name|'section_name'
op|'='
name|'None'
op|','
name|'log_name'
op|'='
name|'None'
op|','
name|'defaults'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Read config file and return config items as a dict\n\n    :param conf: path to config file\n    :param section_name: config section to read (will return all sections if\n                     not defined)\n    :param log_name: name to be used with logging (will use section_name if\n                     not defined)\n    :param defaults: dict of default values to pre-populate the config with\n    :returns: dict of config items\n    """'
newline|'\n'
name|'if'
name|'defaults'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'defaults'
op|'='
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'c'
op|'='
name|'ConfigParser'
op|'('
name|'defaults'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'c'
op|'.'
name|'read'
op|'('
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'print'
string|'"Unable to read config file %s"'
op|'%'
name|'conf'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'section_name'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'c'
op|'.'
name|'has_section'
op|'('
name|'section_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'conf'
op|'='
name|'dict'
op|'('
name|'c'
op|'.'
name|'items'
op|'('
name|'section_name'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'print'
string|'"Unable to find %s config section in %s"'
op|'%'
op|'('
name|'section_name'
op|','
nl|'\n'
name|'conf'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'if'
string|'"log_name"'
name|'not'
name|'in'
name|'conf'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'log_name'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'conf'
op|'['
string|"'log_name'"
op|']'
op|'='
name|'log_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'conf'
op|'['
string|"'log_name'"
op|']'
op|'='
name|'section_name'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'conf'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'c'
op|'.'
name|'sections'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'conf'
op|'.'
name|'update'
op|'('
op|'{'
name|'s'
op|':'
name|'dict'
op|'('
name|'c'
op|'.'
name|'items'
op|'('
name|'s'
op|')'
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'log_name'"
name|'not'
name|'in'
name|'conf'
op|':'
newline|'\n'
indent|'            '
name|'conf'
op|'['
string|"'log_name'"
op|']'
op|'='
name|'log_name'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'conf'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|write_pickle
dedent|''
name|'def'
name|'write_pickle'
op|'('
name|'obj'
op|','
name|'dest'
op|','
name|'tmp'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Ensure that a pickle file gets written to disk.  The file\n    is first written to a tmp location, ensure it is synced to disk, then\n    perform a move to its final location\n\n    :param obj: python object to be pickled\n    :param dest: path of final destination file\n    :param tmp: path to tmp to use\n    """'
newline|'\n'
name|'fd'
op|','
name|'tmppath'
op|'='
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'tmp'
op|')'
newline|'\n'
name|'with'
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'fd'
op|','
string|"'wb'"
op|')'
name|'as'
name|'fo'
op|':'
newline|'\n'
indent|'        '
name|'pickle'
op|'.'
name|'dump'
op|'('
name|'obj'
op|','
name|'fo'
op|')'
newline|'\n'
name|'fo'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'fsync'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'renamer'
op|'('
name|'tmppath'
op|','
name|'dest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|audit_location_generator
dedent|''
dedent|''
name|'def'
name|'audit_location_generator'
op|'('
name|'devices'
op|','
name|'datadir'
op|','
name|'mount_check'
op|'='
name|'True'
op|','
name|'logger'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'''\n    Given a devices path and a data directory, yield (path, device,\n    partition) for all files in that directory\n\n    :param devices: parent directory of the devices to be audited\n    :param datadir: a directory located under self.devices. This should be\n                    one of the DATADIR constants defined in the account,\n                    container, and object servers.\n    :param mount_check: Flag to check if a mount check should be performed\n                    on devices\n    :param logger: a logger object\n    '''"
newline|'\n'
name|'for'
name|'device'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'devices'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'mount_check'
name|'and'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'ismount'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                '
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|"'Skipping %s as it is not mounted'"
op|'%'
name|'device'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'datadir_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|','
name|'datadir'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'datadir_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'partitions'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'datadir_path'
op|')'
newline|'\n'
name|'for'
name|'partition'
name|'in'
name|'partitions'
op|':'
newline|'\n'
indent|'            '
name|'part_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir_path'
op|','
name|'partition'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'part_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'suffixes'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'part_path'
op|')'
newline|'\n'
name|'for'
name|'suffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'                '
name|'suff_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'part_path'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'suff_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'hashes'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'suff_path'
op|')'
newline|'\n'
name|'for'
name|'hsh'
name|'in'
name|'hashes'
op|':'
newline|'\n'
indent|'                    '
name|'hash_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suff_path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'hash_path'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'fname'
name|'in'
name|'sorted'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'hash_path'
op|')'
op|','
nl|'\n'
name|'reverse'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'hash_path'
op|','
name|'fname'
op|')'
newline|'\n'
name|'yield'
name|'path'
op|','
name|'device'
op|','
name|'partition'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ratelimit_sleep
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'ratelimit_sleep'
op|'('
name|'running_time'
op|','
name|'max_rate'
op|','
name|'incr_by'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'''\n    Will time.sleep() for the appropriate time so that the max_rate\n    is never exceeded.  If max_rate is 0, will not ratelimit.  The\n    maximum recommended rate should not exceed (1000 * incr_by) a second\n    as time.sleep() does involve at least a millisecond of overhead.\n    Returns running_time that should be used for subsequent calls.\n\n    :param running_time: the running time of the next allowable request. Best\n                         to start at zero.\n    :param max_rate: The maximum rate per second allowed for the process.\n    :param incr_by: How much to increment the counter.  Useful if you want\n                    to ratelimit 1024 bytes/sec and have differing sizes\n                    of requests. Must be >= 0.\n    '''"
newline|'\n'
name|'if'
name|'not'
name|'max_rate'
name|'or'
name|'incr_by'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'clock_accuracy'
op|'='
number|'1000.0'
newline|'\n'
name|'now'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'*'
name|'clock_accuracy'
newline|'\n'
name|'time_per_request'
op|'='
name|'clock_accuracy'
op|'*'
op|'('
name|'float'
op|'('
name|'incr_by'
op|')'
op|'/'
name|'max_rate'
op|')'
newline|'\n'
name|'if'
name|'running_time'
op|'<'
name|'now'
op|':'
newline|'\n'
indent|'        '
name|'running_time'
op|'='
name|'now'
newline|'\n'
dedent|''
name|'elif'
name|'running_time'
op|'-'
name|'now'
op|'>'
name|'time_per_request'
op|':'
newline|'\n'
indent|'        '
name|'time'
op|'.'
name|'sleep'
op|'('
op|'('
name|'running_time'
op|'-'
name|'now'
op|')'
op|'/'
name|'clock_accuracy'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'running_time'
op|'+'
name|'time_per_request'
newline|'\n'
dedent|''
endmarker|''
end_unit
