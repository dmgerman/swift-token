begin_unit
comment|'# Copyright (c) 2010-2013 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
string|'"""\nDisk File Interface for the Swift Object Server\n\nThe `DiskFile`, `DiskFileWriter` and `DiskFileReader` classes combined define\nthe on-disk abstraction layer for supporting the object server REST API\ninterfaces (excluding `REPLICATE`). Other implementations wishing to provide\nan alternative backend for the object server must implement the three\nclasses. An example alternative implementation can be found in the\n`mem_server.py` and `mem_diskfile.py` modules along size this one.\n\nThe `DiskFileManager` is a reference implemenation specific class and is not\npart of the backend API.\n\nThe remaining methods in this module are considered implementation specific and\nare also not considered part of the backend API.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'fcntl'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'import'
name|'hashlib'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'basename'
op|','
name|'dirname'
op|','
name|'exists'
op|','
name|'getmtime'
op|','
name|'join'
newline|'\n'
name|'from'
name|'random'
name|'import'
name|'shuffle'
newline|'\n'
name|'from'
name|'tempfile'
name|'import'
name|'mkstemp'
newline|'\n'
name|'from'
name|'contextlib'
name|'import'
name|'contextmanager'
newline|'\n'
name|'from'
name|'collections'
name|'import'
name|'defaultdict'
newline|'\n'
nl|'\n'
name|'from'
name|'xattr'
name|'import'
name|'getxattr'
op|','
name|'setxattr'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'Timeout'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'hubs'
name|'import'
name|'trampoline'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
name|'import'
name|'gettext_'
name|'as'
name|'_'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'constraints'
name|'import'
name|'check_mount'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'request_helpers'
name|'import'
name|'is_sys_meta'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'mkdirs'
op|','
name|'Timestamp'
op|','
name|'storage_directory'
op|','
name|'hash_path'
op|','
name|'renamer'
op|','
name|'fallocate'
op|','
name|'fsync'
op|','
name|'fdatasync'
op|','
name|'drop_buffer_cache'
op|','
name|'ThreadPool'
op|','
name|'lock_path'
op|','
name|'write_pickle'
op|','
name|'config_true_value'
op|','
name|'listdir'
op|','
name|'split_path'
op|','
name|'ismount'
op|','
name|'remove_file'
op|','
name|'get_md5_socket'
op|','
name|'system_has_splice'
op|','
name|'splice'
op|','
name|'tee'
op|','
name|'SPLICE_F_MORE'
op|','
name|'F_SETPIPE_SZ'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'DiskFileQuarantined'
op|','
name|'DiskFileNotExist'
op|','
name|'DiskFileCollision'
op|','
name|'DiskFileNoSpace'
op|','
name|'DiskFileDeviceUnavailable'
op|','
name|'DiskFileDeleted'
op|','
name|'DiskFileError'
op|','
name|'DiskFileNotOpen'
op|','
name|'PathNotDir'
op|','
name|'ReplicationLockTimeout'
op|','
name|'DiskFileExpired'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'swob'
name|'import'
name|'multi_range_iterator'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'storage_policy'
name|'import'
name|'get_policy_string'
op|','
name|'POLICIES'
newline|'\n'
name|'from'
name|'functools'
name|'import'
name|'partial'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|PICKLE_PROTOCOL
name|'PICKLE_PROTOCOL'
op|'='
number|'2'
newline|'\n'
DECL|variable|ONE_WEEK
name|'ONE_WEEK'
op|'='
number|'604800'
newline|'\n'
DECL|variable|HASH_FILE
name|'HASH_FILE'
op|'='
string|"'hashes.pkl'"
newline|'\n'
DECL|variable|METADATA_KEY
name|'METADATA_KEY'
op|'='
string|"'user.swift.metadata'"
newline|'\n'
DECL|variable|DROP_CACHE_WINDOW
name|'DROP_CACHE_WINDOW'
op|'='
number|'1024'
op|'*'
number|'1024'
newline|'\n'
comment|'# These are system-set metadata keys that cannot be changed with a POST.'
nl|'\n'
comment|'# They should be lowercase.'
nl|'\n'
DECL|variable|DATAFILE_SYSTEM_META
name|'DATAFILE_SYSTEM_META'
op|'='
name|'set'
op|'('
string|"'content-length content-type deleted etag'"
op|'.'
name|'split'
op|'('
op|')'
op|')'
newline|'\n'
DECL|variable|DATADIR_BASE
name|'DATADIR_BASE'
op|'='
string|"'objects'"
newline|'\n'
DECL|variable|ASYNCDIR_BASE
name|'ASYNCDIR_BASE'
op|'='
string|"'async_pending'"
newline|'\n'
DECL|variable|TMP_BASE
name|'TMP_BASE'
op|'='
string|"'tmp'"
newline|'\n'
DECL|variable|get_data_dir
name|'get_data_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'DATADIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_async_dir
name|'get_async_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'ASYNCDIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_tmp_dir
name|'get_tmp_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'TMP_BASE'
op|')'
newline|'\n'
DECL|variable|MD5_OF_EMPTY_STRING
name|'MD5_OF_EMPTY_STRING'
op|'='
string|"'d41d8cd98f00b204e9800998ecf8427e'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|read_metadata
name|'def'
name|'read_metadata'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to read the pickled metadata from an object file.\n\n    :param fd: file descriptor or filename to load the metadata from\n\n    :returns: dictionary of metadata\n    """'
newline|'\n'
name|'metadata'
op|'='
string|"''"
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'+='
name|'getxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
op|'('
name|'key'
name|'or'
string|"''"
op|')'
op|')'
op|')'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|write_metadata
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'fd'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to write pickled metadata for an object file.\n\n    :param fd: file descriptor or filename to write the metadata\n    :param metadata: metadata to write\n    """'
newline|'\n'
name|'metastr'
op|'='
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'metadata'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'metastr'
op|':'
newline|'\n'
indent|'        '
name|'setxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
name|'key'
name|'or'
string|"''"
op|')'
op|','
name|'metastr'
op|'['
op|':'
number|'254'
op|']'
op|')'
newline|'\n'
name|'metastr'
op|'='
name|'metastr'
op|'['
number|'254'
op|':'
op|']'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|extract_policy_index
dedent|''
dedent|''
name|'def'
name|'extract_policy_index'
op|'('
name|'obj_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Extracts the policy index for an object (based on the name of the objects\n    directory) given the device-relative path to the object. Returns 0 in\n    the event that the path is malformed in some way.\n\n    The device-relative path is everything after the mount point; for example:\n\n    /srv/node/d42/objects-5/179/\n        485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    would have device-relative path:\n\n    objects-5/179/485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    :param obj_path: device-relative path of an object\n    :returns: storage policy index\n    """'
newline|'\n'
name|'policy_idx'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'obj_portion'
op|'='
name|'obj_path'
op|'['
name|'obj_path'
op|'.'
name|'index'
op|'('
name|'DATADIR_BASE'
op|')'
op|':'
op|']'
newline|'\n'
name|'obj_dirname'
op|'='
name|'obj_portion'
op|'['
op|':'
name|'obj_portion'
op|'.'
name|'index'
op|'('
string|"'/'"
op|')'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'policy_idx'
newline|'\n'
dedent|''
name|'if'
string|"'-'"
name|'in'
name|'obj_dirname'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|','
name|'policy_idx'
op|'='
name|'obj_dirname'
op|'.'
name|'split'
op|'('
string|"'-'"
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_idx'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'policy_idx'
op|'='
number|'0'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'int'
op|'('
name|'policy_idx'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|quarantine_renamer
dedent|''
name|'def'
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'corrupted_file_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    In the case that a file is corrupted, move it to a quarantined\n    area to allow replication to fix it.\n\n    :params device_path: The path to the device the corrupted file is on.\n    :params corrupted_file_path: The path to the file you want quarantined.\n\n    :returns: path (str) of directory the file was moved to\n    :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY\n                     exceptions from rename\n    """'
newline|'\n'
name|'from_dir'
op|'='
name|'dirname'
op|'('
name|'corrupted_file_path'
op|')'
newline|'\n'
name|'to_dir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
string|"'quarantined'"
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'extract_policy_index'
op|'('
name|'corrupted_file_path'
op|')'
op|')'
op|','
nl|'\n'
name|'basename'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e'
op|'.'
name|'errno'
name|'not'
name|'in'
op|'('
name|'errno'
op|'.'
name|'EEXIST'
op|','
name|'errno'
op|'.'
name|'ENOTEMPTY'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'to_dir'
op|'='
string|'"%s-%s"'
op|'%'
op|'('
name|'to_dir'
op|','
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|')'
newline|'\n'
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'to_dir'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_ondisk_files
dedent|''
name|'def'
name|'get_ondisk_files'
op|'('
name|'files'
op|','
name|'datadir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a simple list of files names, determine the files to use.\n\n    :params files: simple set of files as a python list\n    :params datadir: directory name files are from for convenience\n    :returns: a tuple of data, meta and ts (tombstone) files, in one of\n              two states:\n\n    * ts_file is not None, data_file is None, meta_file is None\n\n      object is considered deleted\n\n    * data_file is not None, ts_file is None\n\n      object exists, and optionally has fast-POST metadata\n    """'
newline|'\n'
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'data_file'
op|'='
name|'meta_file'
op|'='
name|'ts_file'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'afile'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'ts_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after tombstone, %s, encountered"'
op|'%'
name|'ts_file'
newline|'\n'
name|'assert'
name|'data_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after data file, %s, encountered"'
op|'%'
name|'data_file'
newline|'\n'
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'meta_file'
op|'='
name|'None'
newline|'\n'
name|'ts_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.meta'"
op|')'
name|'and'
name|'not'
name|'meta_file'
op|':'
newline|'\n'
indent|'            '
name|'meta_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
comment|'# NOTE: this does not exit this loop, since a fast-POST'
nl|'\n'
comment|'# operation just updates metadata, writing one or more'
nl|'\n'
comment|'# .meta files, the data file will have an older timestamp,'
nl|'\n'
comment|'# so we keep looking.'
nl|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'data_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'assert'
op|'('
op|'('
name|'data_file'
name|'is'
name|'None'
name|'and'
name|'meta_file'
name|'is'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'ts_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'data_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'meta_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'data_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
op|')'
op|','
string|'"On-disk file search algorithm contract is broken: data_file:"'
string|'" %s, meta_file: %s, ts_file: %s"'
op|'%'
op|'('
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|')'
newline|'\n'
name|'return'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hash_cleanup_listdir
dedent|''
name|'def'
name|'hash_cleanup_listdir'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    List contents of a hash directory and clean up any old files.\n\n    :param hsh_path: object hash path\n    :param reclaim_age: age in seconds at which to remove tombstones\n    :returns: list of files remaining in the directory, reverse sorted\n    """'
newline|'\n'
name|'files'
op|'='
name|'listdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'files'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'files'
op|'['
number|'0'
op|']'
op|'.'
name|'endswith'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
comment|'# remove tombstones older than reclaim_age'
nl|'\n'
indent|'            '
name|'ts'
op|'='
name|'files'
op|'['
number|'0'
op|']'
op|'.'
name|'rsplit'
op|'('
string|"'.'"
op|','
number|'1'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'float'
op|'('
name|'Timestamp'
op|'('
name|'ts'
op|')'
op|')'
op|')'
op|'>'
name|'reclaim_age'
op|':'
newline|'\n'
indent|'                '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'files'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'files'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'elif'
name|'files'
op|':'
newline|'\n'
indent|'        '
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|'='
name|'get_ondisk_files'
op|'('
name|'files'
op|','
string|"''"
op|')'
newline|'\n'
name|'newest_file'
op|'='
name|'data_file'
name|'or'
name|'ts_file'
newline|'\n'
name|'for'
name|'filename'
name|'in'
name|'list'
op|'('
name|'files'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'filename'
op|'<'
name|'newest_file'
op|')'
nl|'\n'
name|'or'
op|'('
name|'meta_file'
nl|'\n'
name|'and'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'.meta'"
op|')'
nl|'\n'
name|'and'
name|'filename'
op|'<'
name|'meta_file'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'filename'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'files'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hash_suffix
dedent|''
name|'def'
name|'hash_suffix'
op|'('
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Performs reclamation and returns an md5 of all (remaining) files.\n\n    :param reclaim_age: age in seconds at which to remove tombstones\n    :raises PathNotDir: if given path is not a valid directory\n    :raises OSError: for non-ENOTDIR errors\n    """'
newline|'\n'
name|'md5'
op|'='
name|'hashlib'
op|'.'
name|'md5'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'path_contents'
op|'='
name|'sorted'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOTDIR'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'path_contents'
op|':'
newline|'\n'
indent|'        '
name|'hsh_path'
op|'='
name|'join'
op|'('
name|'path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'hash_cleanup_listdir'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                '
name|'partition_path'
op|'='
name|'dirname'
op|'('
name|'path'
op|')'
newline|'\n'
name|'objects_path'
op|'='
name|'dirname'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'device_path'
op|'='
name|'dirname'
op|'('
name|'objects_path'
op|')'
newline|'\n'
name|'quar_path'
op|'='
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'hsh_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(hsh_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'hsh_path'"
op|':'
name|'hsh_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'filename'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'md5'
op|'.'
name|'update'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'md5'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|invalidate_hash
dedent|''
name|'def'
name|'invalidate_hash'
op|'('
name|'suffix_dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Invalidates the hash for a suffix_dir in the partition\'s hashes file.\n\n    :param suffix_dir: absolute path to suffix dir whose hash needs\n                       invalidating\n    """'
newline|'\n'
nl|'\n'
name|'suffix'
op|'='
name|'basename'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'partition_dir'
op|'='
name|'dirname'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffix'
name|'in'
name|'hashes'
name|'and'
name|'not'
name|'hashes'
op|'['
name|'suffix'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'None'
newline|'\n'
name|'write_pickle'
op|'('
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_dir'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_hashes
dedent|''
dedent|''
name|'def'
name|'get_hashes'
op|'('
name|'partition_dir'
op|','
name|'recalculate'
op|'='
name|'None'
op|','
name|'do_listdir'
op|'='
name|'False'
op|','
nl|'\n'
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a list of hashes for the suffix dir.  do_listdir causes it to mistrust\n    the hash cache for suffix existence at the (unexpectedly high) cost of a\n    listdir.  reclaim_age is just passed on to hash_suffix.\n\n    :param partition_dir: absolute path of partition to get hashes for\n    :param recalculate: list of suffixes which should be recalculated when got\n    :param do_listdir: force existence check for all hashes in the partition\n    :param reclaim_age: age at which to remove tombstones\n\n    :returns: tuple of (number of suffix dirs hashed, dictionary of hashes)\n    """'
newline|'\n'
nl|'\n'
name|'hashed'
op|'='
number|'0'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'modified'
op|'='
name|'False'
newline|'\n'
name|'force_rewrite'
op|'='
name|'False'
newline|'\n'
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'mtime'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'recalculate'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'recalculate'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'mtime'
op|'='
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'do_listdir'
op|'='
name|'True'
newline|'\n'
name|'force_rewrite'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'if'
name|'do_listdir'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'suff'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'suff'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'.'
name|'setdefault'
op|'('
name|'suff'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'hashes'
op|'.'
name|'update'
op|'('
op|'('
name|'suffix'
op|','
name|'None'
op|')'
name|'for'
name|'suffix'
name|'in'
name|'recalculate'
op|')'
newline|'\n'
name|'for'
name|'suffix'
op|','
name|'hash_'
name|'in'
name|'hashes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'hash_'
op|':'
newline|'\n'
indent|'            '
name|'suffix_dir'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'hash_suffix'
op|'('
name|'suffix_dir'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'hashed'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'PathNotDir'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'hashes'
op|'['
name|'suffix'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Error hashing suffix'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'modified'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'force_rewrite'
name|'or'
name|'not'
name|'exists'
op|'('
name|'hashes_file'
op|')'
name|'or'
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
op|'=='
name|'mtime'
op|':'
newline|'\n'
indent|'                '
name|'write_pickle'
op|'('
nl|'\n'
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_dir'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'get_hashes'
op|'('
name|'partition_dir'
op|','
name|'recalculate'
op|','
name|'do_listdir'
op|','
nl|'\n'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AuditLocation
dedent|''
dedent|''
name|'class'
name|'AuditLocation'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents an object location to be audited.\n\n    Other than being a bucket of data, the only useful thing this does is\n    stringify to a filesystem path so the auditor\'s logs look okay.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'device'
op|','
name|'partition'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'device'
op|','
name|'self'
op|'.'
name|'partition'
op|'='
name|'path'
op|','
name|'device'
op|','
name|'partition'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|object_audit_location_generator
dedent|''
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'devices'
op|','
name|'mount_check'
op|'='
name|'True'
op|','
name|'logger'
op|'='
name|'None'
op|','
nl|'\n'
name|'device_dirs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a devices path (e.g. "/srv/node"), yield an AuditLocation for all\n    objects stored under that directory if device_dirs isn\'t set.  If\n    device_dirs is set, only yield AuditLocation for the objects under the\n    entries in device_dirs. The AuditLocation only knows the path to the hash\n    directory, not to the .data file therein (if any). This is to avoid a\n    double listdir(hash_dir); the DiskFile object will always do one, so\n    we don\'t.\n\n    :param devices: parent directory of the devices to be audited\n    :param mount_check: flag to check if a mount check should be performed\n                        on devices\n    :param logger: a logger object\n    :device_dirs: a list of directories under devices to traverse\n    """'
newline|'\n'
name|'if'
name|'not'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'listdir'
op|'('
name|'devices'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# remove bogus devices and duplicates from device_dirs'
nl|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'list'
op|'('
nl|'\n'
name|'set'
op|'('
name|'listdir'
op|'('
name|'devices'
op|')'
op|')'
op|'.'
name|'intersection'
op|'('
name|'set'
op|'('
name|'device_dirs'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# randomize devices in case of process restart before sweep completed'
nl|'\n'
dedent|''
name|'shuffle'
op|'('
name|'device_dirs'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'device'
name|'in'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'mount_check'
name|'and'
name|'not'
name|'ismount'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                '
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Skipping %s as it is not mounted'"
op|')'
op|','
name|'device'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
comment|'# loop through object dirs for all policies'
nl|'\n'
dedent|''
name|'for'
name|'dir'
name|'in'
op|'['
name|'dir'
name|'for'
name|'dir'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
nl|'\n'
name|'if'
name|'dir'
op|'.'
name|'startswith'
op|'('
name|'DATADIR_BASE'
op|')'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'datadir_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|','
name|'dir'
op|')'
newline|'\n'
comment|"# warn if the object dir doesn't match with a policy"
nl|'\n'
name|'policy_idx'
op|'='
number|'0'
newline|'\n'
name|'if'
string|"'-'"
name|'in'
name|'dir'
op|':'
newline|'\n'
indent|'                '
name|'base'
op|','
name|'policy_idx'
op|'='
name|'dir'
op|'.'
name|'split'
op|'('
string|"'-'"
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                    '
name|'logger'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'Directory %s does not map to a '"
nl|'\n'
string|"'valid policy'"
op|')'
op|'%'
name|'dir'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'partitions'
op|'='
name|'listdir'
op|'('
name|'datadir_path'
op|')'
newline|'\n'
name|'for'
name|'partition'
name|'in'
name|'partitions'
op|':'
newline|'\n'
indent|'                '
name|'part_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir_path'
op|','
name|'partition'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'suffixes'
op|'='
name|'listdir'
op|'('
name|'part_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'asuffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'                    '
name|'suff_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'part_path'
op|','
name|'asuffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'hashes'
op|'='
name|'listdir'
op|'('
name|'suff_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'hashes'
op|':'
newline|'\n'
indent|'                        '
name|'hsh_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suff_path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'yield'
name|'AuditLocation'
op|'('
name|'hsh_path'
op|','
name|'device'
op|','
name|'partition'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileManager
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFileManager'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Management class for devices, providing common place for shared parameters\n    and methods not provided by the DiskFile class (which primarily services\n    the object server REST API layer).\n\n    The `get_diskfile()` method is how this implementation creates a `DiskFile`\n    object.\n\n    .. note::\n\n        This class is reference implementation specific and not part of the\n        pluggable on-disk backend API.\n\n    .. note::\n\n        TODO(portante): Not sure what the right name to recommend here, as\n        "manager" seemed generic enough, though suggestions are welcome.\n\n    :param conf: caller provided configuration object\n    :param logger: caller provided logger\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'conf'
op|','
name|'logger'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'devices'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'devices'"
op|','
string|"'/srv/node'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'disk_chunk_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'disk_chunk_size'"
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'keep_cache_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'keep_cache_size'"
op|','
number|'5242880'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bytes_per_sync'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mb_per_sync'"
op|','
number|'512'
op|')'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'self'
op|'.'
name|'mount_check'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mount_check'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reclaim_age'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'reclaim_age'"
op|','
name|'ONE_WEEK'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_one_per_device'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'replication_one_per_device'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_lock_timeout'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'replication_lock_timeout'"
op|','
number|'15'
op|')'
op|')'
newline|'\n'
name|'threads_per_disk'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'threads_per_disk'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'='
name|'defaultdict'
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
name|'threads_per_disk'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'splice_available'
op|'='
name|'system_has_splice'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'conf_wants_splice'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|','
string|"'no'"
op|')'
op|')'
newline|'\n'
comment|"# If the operator wants zero-copy with splice() but we don't have the"
nl|'\n'
comment|'# requisite kernel support, complain so they can go fix it.'
nl|'\n'
name|'if'
name|'conf_wants_splice'
name|'and'
name|'not'
name|'splice_available'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warn'
op|'('
nl|'\n'
string|'"Use of splice() requested (config says \\"splice = %s\\"), "'
nl|'\n'
string|'"but the system does not support it. "'
nl|'\n'
string|'"splice() will not be used."'
op|'%'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'conf_wants_splice'
name|'and'
name|'splice_available'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'sockfd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|'# AF_ALG socket support was introduced in kernel 2.6.38; on'
nl|'\n'
comment|'# systems with older kernels (or custom-built kernels lacking'
nl|'\n'
comment|"# AF_ALG support), we can't use zero-copy."
nl|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'EAFNOSUPPORT'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warn'
op|'('
string|'"MD5 sockets not supported. "'
nl|'\n'
string|'"splice() will not be used."'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'True'
newline|'\n'
name|'with'
name|'open'
op|'('
string|"'/proc/sys/fs/pipe-max-size'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'                    '
name|'max_pipe_size'
op|'='
name|'int'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'min'
op|'('
name|'max_pipe_size'
op|','
name|'self'
op|'.'
name|'disk_chunk_size'
op|')'
newline|'\n'
nl|'\n'
DECL|member|construct_dev_path
dedent|''
dedent|''
dedent|''
name|'def'
name|'construct_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Construct the path to a device without checking if it is mounted.\n\n        :param device: name of target device\n        :returns: full path to the device\n        """'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_dev_path
dedent|''
name|'def'
name|'get_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'mount_check'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the path to a device, checking to see that it is a proper mount\n        point based on a configuration parameter.\n\n        :param device: name of target device\n        :param mount_check: whether or not to check mountedness of device.\n                            Defaults to bool(self.mount_check).\n        :returns: full path to the device, None if the path to the device is\n                  not a proper mount point.\n        """'
newline|'\n'
name|'should_check'
op|'='
name|'self'
op|'.'
name|'mount_check'
name|'if'
name|'mount_check'
name|'is'
name|'None'
name|'else'
name|'mount_check'
newline|'\n'
name|'if'
name|'should_check'
name|'and'
name|'not'
name|'check_mount'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'dev_path'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|replication_lock
name|'def'
name|'replication_lock'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A context manager that will lock on the device given, if\n        configured to do so.\n\n        :raises ReplicationLockTimeout: If the lock on the device\n            cannot be granted within the configured timeout.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'replication_one_per_device'
op|':'
newline|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'with'
name|'lock_path'
op|'('
nl|'\n'
name|'dev_path'
op|','
nl|'\n'
name|'timeout'
op|'='
name|'self'
op|'.'
name|'replication_lock_timeout'
op|','
nl|'\n'
name|'timeout_class'
op|'='
name|'ReplicationLockTimeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|pickle_async_update
dedent|''
dedent|''
name|'def'
name|'pickle_async_update'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
name|'data'
op|','
nl|'\n'
name|'timestamp'
op|','
name|'policy_idx'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'device_path'
op|'='
name|'self'
op|'.'
name|'construct_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'async_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_async_dir'
op|'('
name|'policy_idx'
op|')'
op|')'
newline|'\n'
name|'ohash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'write_pickle'
op|','
nl|'\n'
name|'data'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'async_dir'
op|','
name|'ohash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
name|'ohash'
op|'+'
string|"'-'"
op|'+'
nl|'\n'
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
op|'.'
name|'internal'
op|')'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy_idx'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'async_pendings'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile
dedent|''
name|'def'
name|'get_diskfile'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy_idx'
op|'='
number|'0'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'DiskFile'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy_idx'
op|'='
name|'policy_idx'
op|','
nl|'\n'
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'use_splice'
op|','
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'pipe_size'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|object_audit_location_generator
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'self'
op|','
name|'device_dirs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'object_audit_location_generator'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'self'
op|'.'
name|'mount_check'
op|','
nl|'\n'
name|'self'
op|'.'
name|'logger'
op|','
name|'device_dirs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_audit_location
dedent|''
name|'def'
name|'get_diskfile_from_audit_location'
op|'('
name|'self'
op|','
name|'audit_location'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'audit_location'
op|'.'
name|'device'
op|','
name|'mount_check'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'DiskFile'
op|'.'
name|'from_hash_dir'
op|'('
nl|'\n'
name|'self'
op|','
name|'audit_location'
op|'.'
name|'path'
op|','
name|'dev_path'
op|','
nl|'\n'
name|'audit_location'
op|'.'
name|'partition'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_hash
dedent|''
name|'def'
name|'get_diskfile_from_hash'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'object_hash'
op|','
nl|'\n'
name|'policy_idx'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a DiskFile instance for an object at the given\n        object_hash. Just in case someone thinks of refactoring, be\n        sure DiskFileDeleted is *not* raised, but the DiskFile\n        instance representing the tombstoned object is returned\n        instead.\n\n        :raises DiskFileNotExist: if the object does not exist\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
name|'partition'
op|','
name|'object_hash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
nl|'\n'
name|'object_hash'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'filenames'
op|'='
name|'hash_cleanup_listdir'
op|'('
name|'object_path'
op|','
name|'self'
op|'.'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                '
name|'quar_path'
op|'='
name|'quarantine_renamer'
op|'('
name|'dev_path'
op|','
name|'object_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(object_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'object_path'"
op|':'
name|'object_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'filenames'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'='
name|'read_metadata'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'object_path'
op|','
name|'filenames'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'EOFError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'split_path'
op|'('
nl|'\n'
name|'metadata'
op|'.'
name|'get'
op|'('
string|"'name'"
op|','
string|"''"
op|')'
op|','
number|'3'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'DiskFile'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy_idx'
op|'='
name|'policy_idx'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hashes
dedent|''
name|'def'
name|'get_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'suffix'
op|','
name|'policy_idx'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'partition_path'
op|')'
newline|'\n'
dedent|''
name|'suffixes'
op|'='
name|'suffix'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
name|'if'
name|'suffix'
name|'else'
op|'['
op|']'
newline|'\n'
name|'_junk'
op|','
name|'hashes'
op|'='
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'get_hashes'
op|','
name|'partition_path'
op|','
name|'recalculate'
op|'='
name|'suffixes'
op|')'
newline|'\n'
name|'return'
name|'hashes'
newline|'\n'
nl|'\n'
DECL|member|_listdir
dedent|''
name|'def'
name|'_listdir'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
nl|'\n'
string|"'ERROR: Skipping %r due to error with listdir attempt: %s'"
op|','
nl|'\n'
name|'path'
op|','
name|'err'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|yield_suffixes
dedent|''
name|'def'
name|'yield_suffixes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy_idx'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, suffix_only) for suffixes stored\n        on the given device and partition.\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'for'
name|'suffix'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'suffix'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'int'
op|'('
name|'suffix'
op|','
number|'16'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|member|yield_hashes
dedent|''
dedent|''
name|'def'
name|'yield_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy_idx'
op|','
name|'suffixes'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, hash_only, timestamp) for object\n        information stored for the given device, partition, and\n        (optionally) suffixes. If suffixes is None, all stored\n        suffixes will be searched for object hashes. Note that if\n        suffixes is not None but empty, such as [], then nothing will\n        be yielded.\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffixes'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'suffixes'
op|'='
name|'self'
op|'.'
name|'yield_suffixes'
op|'('
name|'device'
op|','
name|'partition'
op|','
name|'policy_idx'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'suffixes'
op|'='
op|'('
nl|'\n'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
nl|'\n'
name|'for'
name|'suffix'
name|'in'
name|'suffixes'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'suffix_path'
op|','
name|'suffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'object_hash'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'suffix_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suffix_path'
op|','
name|'object_hash'
op|')'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'hash_cleanup_listdir'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'self'
op|'.'
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ts'
op|','
name|'ext'
op|'='
name|'name'
op|'.'
name|'rsplit'
op|'('
string|"'.'"
op|','
number|'1'
op|')'
newline|'\n'
name|'yield'
op|'('
name|'object_path'
op|','
name|'object_hash'
op|','
name|'ts'
op|')'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileWriter
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFileWriter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the write context for servicing PUT REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.create` method.\n\n    .. note::\n\n        It is the responsibility of the\n        :func:`swift.obj.diskfile.DiskFile.create` method context manager to\n        close the open file descriptor.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param name: name of object from REST API\n    :param datadir: on-disk directory object will end up in on\n                    :func:`swift.obj.diskfile.DiskFileWriter.put`\n    :param fd: open file descriptor of temporary file to receive data\n    :param tmppath: full path name of the opened file descriptor\n    :param bytes_per_sync: number bytes written between sync calls\n    :param threadpool: internal thread pool to use for disk operations\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
name|'bytes_per_sync'
op|','
name|'threadpool'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'datadir'
newline|'\n'
name|'self'
op|'.'
name|'_fd'
op|'='
name|'fd'
newline|'\n'
name|'self'
op|'.'
name|'_tmppath'
op|'='
name|'tmppath'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
nl|'\n'
comment|'# Internal attributes'
nl|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_extension'
op|'='
string|"'.data'"
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a chunk of data to disk. All invocations of this method must\n        come before invoking the :func:\n\n        For this implementation, the data is written into a temporary file.\n\n        :param chunk: the chunk of data to write as a string object\n\n        :returns: the total number of bytes written to an object\n        """'
newline|'\n'
nl|'\n'
DECL|function|_write_entire_chunk
name|'def'
name|'_write_entire_chunk'
op|'('
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'chunk'
op|':'
newline|'\n'
indent|'                '
name|'written'
op|'='
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'chunk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'+='
name|'written'
newline|'\n'
name|'chunk'
op|'='
name|'chunk'
op|'['
name|'written'
op|':'
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
name|'_write_entire_chunk'
op|','
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
comment|'# For large files sync every 512MB (by default) written'
nl|'\n'
name|'diff'
op|'='
name|'self'
op|'.'
name|'_upload_size'
op|'-'
name|'self'
op|'.'
name|'_last_sync'
newline|'\n'
name|'if'
name|'diff'
op|'>='
name|'self'
op|'.'
name|'_bytes_per_sync'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
name|'fdatasync'
op|','
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'self'
op|'.'
name|'_last_sync'
op|','
name|'diff'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
DECL|member|_finalize_put
dedent|''
name|'def'
name|'_finalize_put'
op|'('
name|'self'
op|','
name|'metadata'
op|','
name|'target_path'
op|')'
op|':'
newline|'\n'
comment|'# Write the metadata before calling fsync() so that both data and'
nl|'\n'
comment|'# metadata are flushed to disk.'
nl|'\n'
indent|'        '
name|'write_metadata'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'metadata'
op|')'
newline|'\n'
comment|'# We call fsync() before calling drop_cache() to lower the amount of'
nl|'\n'
comment|'# redundant work the drop cache code will perform on the pages (now'
nl|'\n'
comment|'# that after fsync the pages will be all clean).'
nl|'\n'
name|'fsync'
op|'('
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
comment|'# From the Department of the Redundancy Department, make sure we call'
nl|'\n'
comment|'# drop_cache() after fsync() to avoid redundant work (pages all'
nl|'\n'
comment|'# clean).'
nl|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
number|'0'
op|','
name|'self'
op|'.'
name|'_upload_size'
op|')'
newline|'\n'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|')'
newline|'\n'
comment|'# After the rename completes, this object will be available for other'
nl|'\n'
comment|'# requests to reference.'
nl|'\n'
name|'renamer'
op|'('
name|'self'
op|'.'
name|'_tmppath'
op|','
name|'target_path'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'hash_cleanup_listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Problem cleaning up %s'"
op|')'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
nl|'\n'
DECL|member|put
dedent|''
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize writing the file on disk.\n\n        For this implementation, this method is responsible for renaming the\n        temporary file to the final name and directory location.  This method\n        should be called after the final call to\n        :func:`swift.obj.diskfile.DiskFileWriter.write`.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        """'
newline|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'metadata'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
op|'.'
name|'internal'
newline|'\n'
name|'metadata'
op|'['
string|"'name'"
op|']'
op|'='
name|'self'
op|'.'
name|'_name'
newline|'\n'
name|'target_path'
op|'='
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'timestamp'
op|'+'
name|'self'
op|'.'
name|'_extension'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_put'
op|','
name|'metadata'
op|','
name|'target_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileReader
dedent|''
dedent|''
name|'class'
name|'DiskFileReader'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the WSGI read context for servicing GET REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.reader` method.\n\n    .. note::\n\n        The quarantining behavior of this method is considered implementation\n        specific, and is not required of the API.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param fp: open file object pointer reference\n    :param data_file: on-disk data file name for the object\n    :param obj_size: verified on-disk size of the object\n    :param etag: expected metadata etag value for entire file\n    :param threadpool: thread pool to use for read operations\n    :param disk_chunk_size: size of reads from disk in bytes\n    :param keep_cache_size: maximum object size that will be kept in cache\n    :param device_path: on-disk device path, used when quarantining an obj\n    :param logger: logger caller wants this object to use\n    :param quarantine_hook: 1-arg callable called w/reason when quarantined\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    :param keep_cache: should resulting reads be kept in the buffer cache\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'fp'
op|','
name|'data_file'
op|','
name|'obj_size'
op|','
name|'etag'
op|','
name|'threadpool'
op|','
nl|'\n'
name|'disk_chunk_size'
op|','
name|'keep_cache_size'
op|','
name|'device_path'
op|','
name|'logger'
op|','
nl|'\n'
name|'quarantine_hook'
op|','
name|'use_splice'
op|','
name|'pipe_size'
op|','
name|'keep_cache'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_fp'
op|'='
name|'fp'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'data_file'
newline|'\n'
name|'self'
op|'.'
name|'_obj_size'
op|'='
name|'obj_size'
newline|'\n'
name|'self'
op|'.'
name|'_etag'
op|'='
name|'etag'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'='
name|'quarantine_hook'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'if'
name|'keep_cache'
op|':'
newline|'\n'
comment|'# Caller suggests we keep this in cache, only do it if the'
nl|'\n'
comment|"# object's size is less than the maximum."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'obj_size'
op|'<'
name|'keep_cache_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Internal Attributes'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'tell'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'hashlib'
op|'.'
name|'md5'
op|'('
op|')'
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'read'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|')'
newline|'\n'
name|'if'
name|'chunk'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'update'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|can_zero_copy_send
dedent|''
dedent|''
dedent|''
name|'def'
name|'can_zero_copy_send'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_use_splice'
newline|'\n'
nl|'\n'
DECL|member|zero_copy_send
dedent|''
name|'def'
name|'zero_copy_send'
op|'('
name|'self'
op|','
name|'wsockfd'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Does some magic with splice() and tee() to move stuff from disk to\n        network without ever touching userspace.\n\n        :param wsockfd: file descriptor (integer) of the socket out which to\n                        send data\n        """'
newline|'\n'
comment|'# Note: if we ever add support for zero-copy ranged GET responses,'
nl|'\n'
comment|"# we'll have to make this conditional."
nl|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'rfd'
op|'='
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'client_rpipe'
op|','
name|'client_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'hash_rpipe'
op|','
name|'hash_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'md5_sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The actual amount allocated to the pipe may be rounded up to the'
nl|'\n'
comment|'# nearest multiple of the page size. If we have the memory allocated,'
nl|'\n'
comment|'# we may as well use it.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note: this will raise IOError on failure, so we don't bother"
nl|'\n'
comment|'# checking the return value.'
nl|'\n'
name|'pipe_size'
op|'='
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'client_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'self'
op|'.'
name|'_pipe_size'
op|')'
newline|'\n'
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'hash_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'pipe_size'
op|')'
newline|'\n'
nl|'\n'
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'True'
op|':'
newline|'\n'
comment|'# Read data from disk to pipe'
nl|'\n'
indent|'                '
name|'bytes_in_pipe'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'splice'
op|','
name|'rfd'
op|','
number|'0'
op|','
name|'client_wpipe'
op|','
number|'0'
op|','
name|'pipe_size'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_in_pipe'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'bytes_in_pipe'
newline|'\n'
nl|'\n'
comment|'# "Copy" data from pipe A to pipe B (really just some pointer'
nl|'\n'
comment|'# manipulation in the kernel, not actual copying).'
nl|'\n'
name|'bytes_copied'
op|'='
name|'tee'
op|'('
name|'client_rpipe'
op|','
name|'hash_wpipe'
op|','
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_copied'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
comment|'# We teed data between two pipes of equal size, and the'
nl|'\n'
comment|'# destination pipe was empty. If, somehow, the destination'
nl|'\n'
comment|'# pipe was full before all the data was teed, we should'
nl|'\n'
comment|"# fail here. If we don't raise an exception, then we will"
nl|'\n'
comment|'# have the incorrect MD5 hash once the object has been'
nl|'\n'
comment|'# sent out, causing a false-positive quarantine.'
nl|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"tee() failed: tried to move %d bytes, "'
nl|'\n'
string|'"but only moved %d"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'bytes_copied'
op|')'
op|')'
newline|'\n'
comment|'# Take the data and feed it into an in-kernel MD5 socket. The'
nl|'\n'
comment|'# MD5 socket hashes data that is written to it. Reading from'
nl|'\n'
comment|'# it yields the MD5 checksum of the written data.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note that we don't have to worry about splice() returning"
nl|'\n'
comment|"# None here (which happens on EWOULDBLOCK); we're splicing"
nl|'\n'
comment|'# $bytes_in_pipe bytes from a pipe with exactly that many'
nl|'\n'
comment|"# bytes in it, so read won't block, and we're splicing it into"
nl|'\n'
comment|'# an MD5 socket, which synchronously hashes any data sent to'
nl|'\n'
comment|"# it, so writing won't block either."
nl|'\n'
dedent|''
name|'hashed'
op|'='
name|'splice'
op|'('
name|'hash_rpipe'
op|','
number|'0'
op|','
name|'md5_sockfd'
op|','
number|'0'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
name|'SPLICE_F_MORE'
op|')'
newline|'\n'
name|'if'
name|'hashed'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"md5 socket didn\'t take all the data? "'
nl|'\n'
string|'"(tried to write %d, but wrote %d)"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'hashed'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'bytes_in_pipe'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'sent'
op|'='
name|'splice'
op|'('
name|'client_rpipe'
op|','
number|'0'
op|','
name|'wsockfd'
op|','
number|'0'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'sent'
name|'is'
name|'None'
op|':'
comment|'# would have blocked'
newline|'\n'
indent|'                        '
name|'trampoline'
op|'('
name|'wsockfd'
op|','
name|'write'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'bytes_in_pipe'
op|'-='
name|'sent'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|"# Linux MD5 sockets return '00000000000000000000000000000000' for"
nl|'\n'
comment|"# the checksum if you didn't write any bytes to them, instead of"
nl|'\n'
comment|'# returning the correct value.'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'bin_checksum'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'md5_sockfd'
op|','
number|'16'
op|')'
newline|'\n'
name|'hex_checksum'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
string|'"%02x"'
op|'%'
name|'ord'
op|'('
name|'c'
op|')'
name|'for'
name|'c'
name|'in'
name|'bin_checksum'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'hex_checksum'
op|'='
name|'MD5_OF_EMPTY_STRING'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'hex_checksum'
newline|'\n'
nl|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'md5_sockfd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_range
dedent|''
dedent|''
name|'def'
name|'app_iter_range'
op|'('
name|'self'
op|','
name|'start'
op|','
name|'stop'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file for range (start, stop)"""'
newline|'\n'
name|'if'
name|'start'
name|'or'
name|'start'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'seek'
op|'('
name|'start'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stop'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'stop'
op|'-'
name|'start'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'chunk'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'length'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'length'
op|'-='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'length'
op|'<'
number|'0'
op|':'
newline|'\n'
comment|'# Chop off the extra:'
nl|'\n'
indent|'                        '
name|'yield'
name|'chunk'
op|'['
op|':'
name|'length'
op|']'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_ranges
dedent|''
dedent|''
dedent|''
name|'def'
name|'app_iter_ranges'
op|'('
name|'self'
op|','
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file for a set of ranges"""'
newline|'\n'
name|'if'
name|'not'
name|'ranges'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"''"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'True'
newline|'\n'
name|'for'
name|'chunk'
name|'in'
name|'multi_range_iterator'
op|'('
nl|'\n'
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app_iter_range'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_drop_cache
dedent|''
dedent|''
dedent|''
name|'def'
name|'_drop_cache'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Method for no-oping buffer cache drop method."""'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_keep_cache'
op|':'
newline|'\n'
indent|'            '
name|'drop_buffer_cache'
op|'('
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'self'
op|'.'
name|'_data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warn'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handle_close_quarantine
dedent|''
name|'def'
name|'_handle_close_quarantine'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if file needs to be quarantined"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'!='
name|'self'
op|'.'
name|'_obj_size'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"Bytes read: %s, does not match metadata: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|','
name|'self'
op|'.'
name|'_obj_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
name|'and'
name|'self'
op|'.'
name|'_etag'
op|'!='
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"ETag %s and file\'s md5 %s do not match"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_etag'
op|','
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the open file handle if present.\n\n        For this specific implementation, this method will handle quarantining\n        the file if necessary.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_started_at_0'
name|'and'
name|'self'
op|'.'
name|'_read_to_eof'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_handle_close_quarantine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
nl|'\n'
string|"'ERROR DiskFile %(data_file)s'"
nl|'\n'
string|"' close failure: %(exc)s : %(stack)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'exc'"
op|':'
name|'e'
op|','
string|"'stack'"
op|':'
string|"''"
op|'.'
name|'join'
op|'('
name|'traceback'
op|'.'
name|'format_stack'
op|'('
op|')'
op|')'
op|','
nl|'\n'
string|"'data_file'"
op|':'
name|'self'
op|'.'
name|'_data_file'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFile
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFile'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Manage object files.\n\n    This specific implementation manages object files on a disk formatted with\n    a POSIX-compliant file system that supports extended attributes as\n    metadata on a file or directory.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param mgr: associated DiskFileManager instance\n    :param device_path: path to the target device or drive\n    :param threadpool: thread pool to use for blocking operations\n    :param partition: partition on the device in which the object lives\n    :param account: account name for the object\n    :param container: container name for the object\n    :param obj: object name for the object\n    :param _datadir: override the full datadir otherwise constructed here\n    :param policy_idx: used to get the data dir when constructing it here\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'mgr'
op|','
name|'device_path'
op|','
name|'threadpool'
op|','
name|'partition'
op|','
nl|'\n'
name|'account'
op|'='
name|'None'
op|','
name|'container'
op|'='
name|'None'
op|','
name|'obj'
op|'='
name|'None'
op|','
name|'_datadir'
op|'='
name|'None'
op|','
nl|'\n'
name|'policy_idx'
op|'='
number|'0'
op|','
name|'use_splice'
op|'='
name|'False'
op|','
name|'pipe_size'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_mgr'
op|'='
name|'mgr'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
name|'or'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'mgr'
op|'.'
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'mgr'
op|'.'
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'mgr'
op|'.'
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'if'
name|'account'
name|'and'
name|'container'
name|'and'
name|'obj'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'account'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'container'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'obj'
newline|'\n'
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# gets populated when we read the metadata'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tmpdir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy_idx'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'_datadir'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'_datadir'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy_idx'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|account
name|'def'
name|'account'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_account'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|container
name|'def'
name|'container'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_container'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|obj
name|'def'
name|'obj'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_obj'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|content_length
name|'def'
name|'content_length'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_content_length'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|timestamp
name|'def'
name|'timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Timestamp'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_hash_dir
name|'def'
name|'from_hash_dir'
op|'('
name|'cls'
op|','
name|'mgr'
op|','
name|'hash_dir_path'
op|','
name|'device_path'
op|','
name|'partition'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cls'
op|'('
name|'mgr'
op|','
name|'device_path'
op|','
name|'None'
op|','
name|'partition'
op|','
name|'_datadir'
op|'='
name|'hash_dir_path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|open
dedent|''
name|'def'
name|'open'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the object.\n\n        This implementation opens the data file representing the object, reads\n        the associated metadata in the extended attributes, additionally\n        combining metadata from fast-POST `.meta` files.\n\n        .. note::\n\n            An implementation is allowed to raise any of the following\n            exceptions, but is only required to raise `DiskFileNotExist` when\n            the object representation does not exist.\n\n        :raises DiskFileCollision: on name mis-match with metadata\n        :raises DiskFileNotExist: if the object does not exist\n        :raises DiskFileDeleted: if the object was previously deleted\n        :raises DiskFileQuarantined: if while reading metadata of the file\n                                     some data did pass cross checks\n        :returns: itself for use as a context manager\n        """'
newline|'\n'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|'='
name|'self'
op|'.'
name|'_get_ondisk_file'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'data_file'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_construct_exception_from_ts_file'
op|'('
name|'ts_file'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_construct_from_data_file'
op|'('
nl|'\n'
name|'data_file'
op|','
name|'meta_file'
op|')'
newline|'\n'
comment|'# This method must populate the internal _metadata attribute.'
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'data_file'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context enter.\n\n        .. note::\n\n            An implemenation shall raise `DiskFileNotOpen` when has not\n            previously invoked the :func:`swift.obj.diskfile.DiskFile.open`\n            method.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'t'
op|','
name|'v'
op|','
name|'tb'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context exit.\n\n        .. note::\n\n            This method will be invoked by the object server while servicing\n            the REST API *before* the object has actually been read. It is the\n            responsibility of the implementation to properly handle that.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Quarantine a file; responsible for incrementing the associated logger\'s\n        count of quarantines.\n\n        :param data_file: full path of data file to quarantine\n        :param msg: reason for quarantining to be included in the exception\n        :returns: DiskFileQuarantined exception object\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warn'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'return'
name|'DiskFileQuarantined'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_file
dedent|''
name|'def'
name|'_get_ondisk_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do the work to figure out if the data directory exists, and if so,\n        determine the on-disk files to use.\n\n        :returns: a tuple of data, meta and ts (tombstone) files, in one of\n                  three states:\n\n        * all three are None\n\n          data directory does not exist, or there are no files in\n          that directory\n\n        * ts_file is not None, data_file is None, meta_file is None\n\n          object is considered deleted\n\n        * data_file is not None, ts_file is None\n\n          object exists, and optionally has fast-POST metadata\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
comment|"# If there's a file here instead of a directory, quarantine"
nl|'\n'
comment|"# it; something's gone wrong somewhere."
nl|'\n'
indent|'                '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
comment|'# hack: quarantine_renamer actually renames the directory'
nl|'\n'
comment|'# enclosing the filename you give it, but here we just'
nl|'\n'
comment|'# want this one file and not its parent.'
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
string|'"made-up-filename"'
op|')'
op|','
nl|'\n'
string|'"Expected directory, found file at %s"'
op|'%'
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|'"Error listing directory %s: %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
comment|'# The data directory does not exist, so the object cannot exist.'
nl|'\n'
dedent|''
name|'fileset'
op|'='
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'fileset'
op|'='
name|'get_ondisk_files'
op|'('
name|'files'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'fileset'
newline|'\n'
nl|'\n'
DECL|member|_construct_exception_from_ts_file
dedent|''
name|'def'
name|'_construct_exception_from_ts_file'
op|'('
name|'self'
op|','
name|'ts_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a tombstone is present it means the object is considered\n        deleted. We just need to pull the metadata from the tombstone file\n        which has the timestamp to construct the deleted exception. If there\n        was no tombstone, just report it does not exist.\n\n        :param ts_file: the tombstone file name found on disk\n        :returns: DiskFileDeleted if the ts_file was provided, else\n                  DiskFileNotExist\n        """'
newline|'\n'
name|'if'
name|'not'
name|'ts_file'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'ts_file'
op|','
name|'ts_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
comment|"# If the tombstone's corrupted, quarantine it and pretend it"
nl|'\n'
comment|"# wasn't there"
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# All well and good that we have found a tombstone file, but'
nl|'\n'
comment|"# we don't have a data file so we are just going to raise an"
nl|'\n'
comment|'# exception that we could not find the object, providing the'
nl|'\n'
comment|"# tombstone's timestamp."
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileDeleted'
op|'('
name|'metadata'
op|'='
name|'metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'exc'
newline|'\n'
nl|'\n'
DECL|member|_verify_name_matches_hash
dedent|''
name|'def'
name|'_verify_name_matches_hash'
op|'('
name|'self'
op|','
name|'data_file'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'hash_from_fs'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
name|'hash_from_name'
op|'='
name|'hash_path'
op|'('
name|'self'
op|'.'
name|'_name'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'hash_from_fs'
op|'!='
name|'hash_from_name'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
nl|'\n'
string|'"Hash of name in metadata does not match directory name"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_verify_data_file
dedent|''
dedent|''
name|'def'
name|'_verify_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'fp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify the metadata\'s name value matches what we think the object is\n        named.\n\n        :param data_file: data file name being consider, used when quarantines\n                          occur\n        :param fp: open file pointer so that we can `fstat()` the file to\n                   verify the on-disk size with Content-Length metadata value\n        :raises DiskFileCollision: if the metadata stored name does not match\n                                   the referenced name of the file\n        :raises DiskFileExpired: if the object has expired\n        :raises DiskFileQuarantined: if data inconsistencies were detected\n                                     between the metadata and the file-system\n                                     metadata\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mname'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"missing name metadata"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mname'
op|'!='
name|'self'
op|'.'
name|'_name'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client path %(client)s does not match '"
nl|'\n'
string|"'path stored in object metadata %(meta)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'client'"
op|':'
name|'self'
op|'.'
name|'_name'
op|','
string|"'meta'"
op|':'
name|'mname'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileCollision'
op|'('
string|"'Client path does not match path '"
nl|'\n'
string|"'stored in object metadata'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'x_delete_at'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the x-delete-at key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata x-delete-at value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'x_delete_at'
op|'<='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileExpired'
op|'('
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata_size'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"missing content-length in metadata"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the content-length key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata content-length value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'fd'
op|'='
name|'fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'statbuf'
op|'='
name|'os'
op|'.'
name|'fstat'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|"# Quarantine, we can't successfully stat the file."
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"not stat-able: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'obj_size'
op|'='
name|'statbuf'
op|'.'
name|'st_size'
newline|'\n'
dedent|''
name|'if'
name|'obj_size'
op|'!='
name|'metadata_size'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"metadata content-length %s does"'
nl|'\n'
string|'" not match actual object size %s"'
op|'%'
op|'('
nl|'\n'
name|'metadata_size'
op|','
name|'statbuf'
op|'.'
name|'st_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'obj_size'
newline|'\n'
name|'return'
name|'obj_size'
newline|'\n'
nl|'\n'
DECL|member|_failsafe_read_metadata
dedent|''
name|'def'
name|'_failsafe_read_metadata'
op|'('
name|'self'
op|','
name|'source'
op|','
name|'quarantine_filename'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# Takes source and filename separately so we can read from an open'
nl|'\n'
comment|'# file if we have one'
nl|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'read_metadata'
op|'('
name|'source'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'quarantine_filename'
op|','
nl|'\n'
string|'"Exception reading metadata: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_construct_from_data_file
dedent|''
dedent|''
name|'def'
name|'_construct_from_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'meta_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the `.data` file to fetch its metadata, and fetch the metadata\n        from the fast-POST `.meta` file as well if it exists, merging them\n        properly.\n\n        :param data_file: on-disk `.data` file being considered\n        :param meta_file: on-disk fast-POST `.meta` file being considered\n        :returns: an opened data file pointer\n        :raises DiskFileError: various exceptions from\n                    :func:`swift.obj.diskfile.DiskFile._verify_data_file`\n        """'
newline|'\n'
name|'fp'
op|'='
name|'open'
op|'('
name|'data_file'
op|','
string|"'rb'"
op|')'
newline|'\n'
name|'datafile_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'fp'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'if'
name|'meta_file'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'meta_file'
op|','
name|'meta_file'
op|')'
newline|'\n'
name|'sys_metadata'
op|'='
name|'dict'
op|'('
nl|'\n'
op|'['
op|'('
name|'key'
op|','
name|'val'
op|')'
name|'for'
name|'key'
op|','
name|'val'
name|'in'
name|'datafile_metadata'
op|'.'
name|'iteritems'
op|'('
op|')'
nl|'\n'
name|'if'
name|'key'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
name|'DATAFILE_SYSTEM_META'
nl|'\n'
name|'or'
name|'is_sys_meta'
op|'('
string|"'object'"
op|','
name|'key'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'update'
op|'('
name|'sys_metadata'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'datafile_metadata'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_name'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# If we don't know our name, we were just given a hash dir at"
nl|'\n'
comment|"# instantiation, so we'd better validate that the name hashes back"
nl|'\n'
comment|'# to us'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_verify_name_matches_hash'
op|'('
name|'data_file'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_verify_data_file'
op|'('
name|'data_file'
op|','
name|'fp'
op|')'
newline|'\n'
name|'return'
name|'fp'
newline|'\n'
nl|'\n'
DECL|member|get_metadata
dedent|''
name|'def'
name|'get_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provide the metadata for a previously opened object as a dictionary.\n\n        :returns: object\'s metadata dictionary\n        :raises DiskFileNotOpen: if the\n            :func:`swift.obj.diskfile.DiskFile.open` method was not previously\n            invoked\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_metadata'
newline|'\n'
nl|'\n'
DECL|member|read_metadata
dedent|''
name|'def'
name|'read_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the metadata for an object without requiring the caller to open\n        the object first.\n\n        :returns: metadata dictionary for an object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `open()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'open'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'get_metadata'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|reader
dedent|''
dedent|''
name|'def'
name|'reader'
op|'('
name|'self'
op|','
name|'keep_cache'
op|'='
name|'False'
op|','
nl|'\n'
name|'_quarantine_hook'
op|'='
name|'lambda'
name|'m'
op|':'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a :class:`swift.common.swob.Response` class compatible\n        "`app_iter`" object as defined by\n        :class:`swift.obj.diskfile.DiskFileReader`.\n\n        For this implementation, the responsibility of closing the open file\n        is passed to the :class:`swift.obj.diskfile.DiskFileReader` object.\n\n        :param keep_cache: caller\'s preference for keeping data read in the\n                           OS buffer cache\n        :param _quarantine_hook: 1-arg callable called when obj quarantined;\n                                 the arg is the reason for quarantine.\n                                 Default is to ignore it.\n                                 Not needed by the REST layer.\n        :returns: a :class:`swift.obj.diskfile.DiskFileReader` object\n        """'
newline|'\n'
name|'dr'
op|'='
name|'DiskFileReader'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|','
name|'self'
op|'.'
name|'_data_file'
op|','
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'ETag'"
op|']'
op|','
name|'self'
op|'.'
name|'_threadpool'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_mgr'
op|'.'
name|'keep_cache_size'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'self'
op|'.'
name|'_logger'
op|','
nl|'\n'
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'_use_splice'
op|','
name|'quarantine_hook'
op|'='
name|'_quarantine_hook'
op|','
nl|'\n'
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'_pipe_size'
op|','
name|'keep_cache'
op|'='
name|'keep_cache'
op|')'
newline|'\n'
comment|'# At this point the reader object is now responsible for closing'
nl|'\n'
comment|'# the file pointer.'
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'return'
name|'dr'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|create
name|'def'
name|'create'
op|'('
name|'self'
op|','
name|'size'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context manager to create a file. We create a temporary file first, and\n        then return a DiskFileWriter object to encapsulate the state.\n\n        .. note::\n\n            An implementation is not required to perform on-disk\n            preallocations even if the parameter is specified. But if it does\n            and it fails, it must raise a `DiskFileNoSpace` exception.\n\n        :param size: optional initial size of file to explicitly allocate on\n                     disk\n        :raises DiskFileNoSpace: if a size is specified and allocation fails\n        """'
newline|'\n'
name|'if'
name|'not'
name|'exists'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
dedent|''
name|'fd'
op|','
name|'tmppath'
op|'='
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'size'
name|'is'
name|'not'
name|'None'
name|'and'
name|'size'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'fallocate'
op|'('
name|'fd'
op|','
name|'size'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'DiskFileWriter'
op|'('
name|'self'
op|'.'
name|'_name'
op|','
name|'self'
op|'.'
name|'_datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|','
name|'self'
op|'.'
name|'_threadpool'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmppath'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|write_metadata
dedent|''
dedent|''
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a block of metadata to an object without requiring the caller to\n        create the object first. Supports fast-POST behavior semantics.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'writer'
op|':'
newline|'\n'
indent|'            '
name|'writer'
op|'.'
name|'_extension'
op|'='
string|"'.meta'"
newline|'\n'
name|'writer'
op|'.'
name|'put'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete
dedent|''
dedent|''
name|'def'
name|'delete'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delete the object.\n\n        This implementation creates a tombstone file using the given\n        timestamp, and removes any older versions of the object file. Any\n        file that has an older timestamp than timestamp will be deleted.\n\n        .. note::\n\n            An implementation is free to use or ignore the timestamp\n            parameter.\n\n        :param timestamp: timestamp to compare with each file\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
op|'.'
name|'internal'
newline|'\n'
nl|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'deleter'
op|':'
newline|'\n'
indent|'            '
name|'deleter'
op|'.'
name|'_extension'
op|'='
string|"'.ts'"
newline|'\n'
name|'deleter'
op|'.'
name|'put'
op|'('
op|'{'
string|"'X-Timestamp'"
op|':'
name|'timestamp'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
