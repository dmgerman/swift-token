begin_unit
comment|'# Copyright (c) 2010 OpenStack, LLC.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
name|'from'
name|'time'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'timeout'
name|'import'
name|'Timeout'
newline|'\n'
name|'from'
name|'webob'
op|'.'
name|'exc'
name|'import'
name|'HTTPForbidden'
op|','
name|'HTTPUnauthorized'
op|','
name|'HTTPNotFound'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'bufferedhttp'
name|'import'
name|'http_connect_raw'
name|'as'
name|'http_connect'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'middleware'
op|'.'
name|'acl'
name|'import'
name|'clean_acl'
op|','
name|'parse_acl'
op|','
name|'referrer_allowed'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'cache_from_env'
op|','
name|'split_path'
op|','
name|'TRUE_VALUES'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'InvalidPathError'
newline|'\n'
nl|'\n'
DECL|class|DevAuth
name|'class'
name|'DevAuth'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Auth Middleware that uses the dev auth server."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'app'
op|','
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'app'
op|'='
name|'app'
newline|'\n'
name|'self'
op|'.'
name|'conf'
op|'='
name|'conf'
newline|'\n'
name|'self'
op|'.'
name|'reseller_prefix'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'reseller_prefix'"
op|','
string|"'AUTH'"
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'reseller_prefix'
name|'and'
name|'self'
op|'.'
name|'reseller_prefix'
op|'['
op|'-'
number|'1'
op|']'
op|'!='
string|"'_'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'reseller_prefix'
op|'+='
string|"'_'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'auth_host'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'ip'"
op|','
string|"'127.0.0.1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auth_port'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'port'"
op|','
number|'11000'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ssl'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'ssl'"
op|','
string|"'false'"
op|')'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
name|'TRUE_VALUES'
newline|'\n'
name|'self'
op|'.'
name|'timeout'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'node_timeout'"
op|','
number|'10'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'env'
op|','
name|'start_response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Accepts a standard WSGI application call, authenticating the request\n        and installing callback hooks for authorization and ACL header\n        validation. For an authenticated request, REMOTE_USER will be set to a\n        comma separated list of the user\'s groups.\n\n        With a non-empty reseller prefix, acts as the definitive auth service\n        for just tokens and accounts that begin with that prefix, but will deny\n        requests outside this prefix if no other auth middleware overrides it.\n\n        With an empty reseller prefix, acts as the definitive auth service only\n        for tokens that validate to a non-empty set of groups. For all other\n        requests, acts as the fallback auth service when no other auth\n        middleware overrides it.\n        """'
newline|'\n'
name|'token'
op|'='
name|'env'
op|'.'
name|'get'
op|'('
string|"'HTTP_X_AUTH_TOKEN'"
op|','
name|'env'
op|'.'
name|'get'
op|'('
string|"'HTTP_X_STORAGE_TOKEN'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'token'
name|'and'
name|'token'
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'reseller_prefix'
op|')'
op|':'
newline|'\n'
comment|'# Note: Empty reseller_prefix will match all tokens.'
nl|'\n'
comment|'# Attempt to auth my token with my auth server'
nl|'\n'
indent|'            '
name|'groups'
op|'='
name|'self'
op|'.'
name|'get_groups'
op|'('
name|'token'
op|','
name|'memcache_client'
op|'='
name|'cache_from_env'
op|'('
name|'env'
op|')'
op|')'
newline|'\n'
name|'if'
name|'groups'
op|':'
newline|'\n'
indent|'                '
name|'env'
op|'['
string|"'REMOTE_USER'"
op|']'
op|'='
name|'groups'
newline|'\n'
name|'user'
op|'='
name|'groups'
name|'and'
name|'groups'
op|'.'
name|'split'
op|'('
string|"','"
op|','
number|'1'
op|')'
op|'['
number|'0'
op|']'
name|'or'
string|"''"
newline|'\n'
comment|'# We know the proxy logs the token, so we augment it just a bit'
nl|'\n'
comment|'# to also log the authenticated user.'
nl|'\n'
name|'env'
op|'['
string|"'HTTP_X_AUTH_TOKEN'"
op|']'
op|'='
string|"'%s,%s'"
op|'%'
op|'('
name|'user'
op|','
name|'token'
op|')'
newline|'\n'
name|'env'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'self'
op|'.'
name|'authorize'
newline|'\n'
name|'env'
op|'['
string|"'swift.clean_acl'"
op|']'
op|'='
name|'clean_acl'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Unauthorized token'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'reseller_prefix'
op|':'
newline|'\n'
comment|"# Because I know I'm the definitive auth for this token, I"
nl|'\n'
comment|'# can deny it outright.'
nl|'\n'
indent|'                    '
name|'return'
name|'HTTPUnauthorized'
op|'('
op|')'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
comment|"# Because I'm not certain if I'm the definitive auth for empty"
nl|'\n'
comment|"# reseller_prefixed tokens, I won't overwrite swift.authorize."
nl|'\n'
dedent|''
name|'elif'
string|"'swift.authorize'"
name|'not'
name|'in'
name|'env'
op|':'
newline|'\n'
indent|'                    '
name|'env'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'self'
op|'.'
name|'denied_response'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'reseller_prefix'
op|':'
newline|'\n'
comment|'# With a non-empty reseller_prefix, I would like to be called'
nl|'\n'
comment|"# back for anonymous access to accounts I know I'm the"
nl|'\n'
comment|'# definitive auth for.'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'version'
op|','
name|'rest'
op|'='
name|'split_path'
op|'('
name|'env'
op|'.'
name|'get'
op|'('
string|"'PATH_INFO'"
op|','
string|"''"
op|')'
op|','
nl|'\n'
number|'1'
op|','
number|'2'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'InvalidPathError'
op|','
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'HTTPNotFound'
op|'('
op|')'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'rest'
name|'and'
name|'rest'
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'reseller_prefix'
op|')'
op|':'
newline|'\n'
comment|"# Handle anonymous access to accounts I'm the definitive"
nl|'\n'
comment|'# auth for.'
nl|'\n'
indent|'                    '
name|'env'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'self'
op|'.'
name|'authorize'
newline|'\n'
name|'env'
op|'['
string|"'swift.clean_acl'"
op|']'
op|'='
name|'clean_acl'
newline|'\n'
comment|"# Not my token, not my account, I can't authorize this request,"
nl|'\n'
comment|'# deny all is a good idea if not already set...'
nl|'\n'
dedent|''
name|'elif'
string|"'swift.authorize'"
name|'not'
name|'in'
name|'env'
op|':'
newline|'\n'
indent|'                    '
name|'env'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'self'
op|'.'
name|'denied_response'
newline|'\n'
comment|"# Because I'm not certain if I'm the definitive auth for empty"
nl|'\n'
comment|"# reseller_prefixed accounts, I won't overwrite swift.authorize."
nl|'\n'
dedent|''
dedent|''
name|'elif'
string|"'swift.authorize'"
name|'not'
name|'in'
name|'env'
op|':'
newline|'\n'
indent|'                '
name|'env'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'self'
op|'.'
name|'authorize'
newline|'\n'
name|'env'
op|'['
string|"'swift.clean_acl'"
op|']'
op|'='
name|'clean_acl'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'app'
op|'('
name|'env'
op|','
name|'start_response'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_groups
dedent|''
name|'def'
name|'get_groups'
op|'('
name|'self'
op|','
name|'token'
op|','
name|'memcache_client'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get groups for the given token.\n        \n        If memcache_client is set, token credentials will be cached\n        appropriately.\n        \n        With a cache miss, or no memcache_client, the configurated external\n        authentication server will be queried for the group information.\n\n        :param token: Token to validate and return a group string for.\n        :param memcache_client: Memcached client to use for caching token\n                                credentials; None if no caching is desired.\n        :returns: None if the token is invalid or a string containing a comma\n                  separated list of groups the authenticated user is a member\n                  of. The first group in the list is also considered a unique\n                  identifier for that user.\n        """'
newline|'\n'
name|'groups'
op|'='
name|'None'
newline|'\n'
name|'key'
op|'='
string|"'%s/token/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'reseller_prefix'
op|','
name|'token'
op|')'
newline|'\n'
name|'cached_auth_data'
op|'='
name|'memcache_client'
name|'and'
name|'memcache_client'
op|'.'
name|'get'
op|'('
name|'key'
op|')'
newline|'\n'
name|'if'
name|'cached_auth_data'
op|':'
newline|'\n'
indent|'            '
name|'start'
op|','
name|'expiration'
op|','
name|'groups'
op|'='
name|'cached_auth_data'
newline|'\n'
name|'if'
name|'time'
op|'('
op|')'
op|'-'
name|'start'
op|'>'
name|'expiration'
op|':'
newline|'\n'
indent|'                '
name|'groups'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'groups'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'Timeout'
op|'('
name|'self'
op|'.'
name|'timeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'conn'
op|'='
name|'http_connect'
op|'('
name|'self'
op|'.'
name|'auth_host'
op|','
name|'self'
op|'.'
name|'auth_port'
op|','
string|"'GET'"
op|','
nl|'\n'
string|"'/token/%s'"
op|'%'
name|'token'
op|','
name|'ssl'
op|'='
name|'self'
op|'.'
name|'ssl'
op|')'
newline|'\n'
name|'resp'
op|'='
name|'conn'
op|'.'
name|'getresponse'
op|'('
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'conn'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'resp'
op|'.'
name|'status'
op|'//'
number|'100'
op|'!='
number|'2'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'expiration'
op|'='
name|'float'
op|'('
name|'resp'
op|'.'
name|'getheader'
op|'('
string|"'x-auth-ttl'"
op|')'
op|')'
newline|'\n'
name|'groups'
op|'='
name|'resp'
op|'.'
name|'getheader'
op|'('
string|"'x-auth-groups'"
op|')'
newline|'\n'
name|'if'
name|'memcache_client'
op|':'
newline|'\n'
indent|'                '
name|'memcache_client'
op|'.'
name|'set'
op|'('
name|'key'
op|','
op|'('
name|'time'
op|'('
op|')'
op|','
name|'expiration'
op|','
name|'groups'
op|')'
op|','
nl|'\n'
name|'timeout'
op|'='
name|'expiration'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'groups'
newline|'\n'
nl|'\n'
DECL|member|authorize
dedent|''
name|'def'
name|'authorize'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns None if the request is authorized to continue or a standard\n        WSGI response callable if not.\n\n        :raises: InvalidPathError (thrown by split_path) if given invalid path\n        """'
newline|'\n'
name|'version'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'split_path'
op|'('
name|'req'
op|'.'
name|'path'
op|','
number|'1'
op|','
number|'4'
op|','
name|'True'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'account'
name|'or'
name|'not'
name|'account'
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'reseller_prefix'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'denied_response'
op|'('
name|'req'
op|')'
newline|'\n'
dedent|''
name|'user_groups'
op|'='
op|'('
name|'req'
op|'.'
name|'remote_user'
name|'or'
string|"''"
op|')'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
name|'if'
string|"'.reseller_admin'"
name|'in'
name|'user_groups'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'account'
name|'in'
name|'user_groups'
name|'and'
op|'('
name|'req'
op|'.'
name|'method'
op|'!='
string|"'PUT'"
name|'or'
name|'container'
op|')'
op|':'
newline|'\n'
comment|'# If the user is admin for the account and is not trying to do an'
nl|'\n'
comment|'# account PUT...'
nl|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'referrers'
op|','
name|'groups'
op|'='
name|'parse_acl'
op|'('
name|'getattr'
op|'('
name|'req'
op|','
string|"'acl'"
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'if'
name|'referrer_allowed'
op|'('
name|'req'
op|'.'
name|'referer'
op|','
name|'referrers'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'req'
op|'.'
name|'remote_user'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'denied_response'
op|'('
name|'req'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'user_group'
name|'in'
name|'user_groups'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'user_group'
name|'in'
name|'groups'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'denied_response'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
DECL|member|denied_response
dedent|''
name|'def'
name|'denied_response'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a standard WSGI response callable with the status of 403 or 401\n        depending on whether the REMOTE_USER is set or not.\n        """'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'remote_user'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPForbidden'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPUnauthorized'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|filter_factory
dedent|''
dedent|''
dedent|''
name|'def'
name|'filter_factory'
op|'('
name|'global_conf'
op|','
op|'**'
name|'local_conf'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns a WSGI filter app for use with paste.deploy."""'
newline|'\n'
name|'conf'
op|'='
name|'global_conf'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'conf'
op|'.'
name|'update'
op|'('
name|'local_conf'
op|')'
newline|'\n'
nl|'\n'
DECL|function|auth_filter
name|'def'
name|'auth_filter'
op|'('
name|'app'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'DevAuth'
op|'('
name|'app'
op|','
name|'conf'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'auth_filter'
newline|'\n'
dedent|''
endmarker|''
end_unit
