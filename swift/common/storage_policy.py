begin_unit
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
name|'from'
name|'ConfigParser'
name|'import'
name|'ConfigParser'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'string'
newline|'\n'
name|'import'
name|'textwrap'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
op|'('
nl|'\n'
name|'config_true_value'
op|','
name|'SWIFT_CONF_FILE'
op|','
name|'whataremyips'
op|')'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'ring'
name|'import'
name|'Ring'
op|','
name|'RingData'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'quorum_size'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'RingValidationError'
newline|'\n'
name|'from'
name|'pyeclib'
op|'.'
name|'ec_iface'
name|'import'
name|'ECDriver'
op|','
name|'ECDriverError'
op|','
name|'VALID_EC_TYPES'
newline|'\n'
nl|'\n'
DECL|variable|LEGACY_POLICY_NAME
name|'LEGACY_POLICY_NAME'
op|'='
string|"'Policy-0'"
newline|'\n'
DECL|variable|VALID_CHARS
name|'VALID_CHARS'
op|'='
string|"'-'"
op|'+'
name|'string'
op|'.'
name|'letters'
op|'+'
name|'string'
op|'.'
name|'digits'
newline|'\n'
nl|'\n'
name|'DEFAULT_POLICY_TYPE'
op|'='
name|'REPL_POLICY'
op|'='
string|"'replication'"
newline|'\n'
DECL|variable|EC_POLICY
name|'EC_POLICY'
op|'='
string|"'erasure_coding'"
newline|'\n'
nl|'\n'
DECL|variable|DEFAULT_EC_OBJECT_SEGMENT_SIZE
name|'DEFAULT_EC_OBJECT_SEGMENT_SIZE'
op|'='
number|'1048576'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BindPortsCache
name|'class'
name|'BindPortsCache'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'swift_dir'
op|','
name|'bind_ip'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'swift_dir'
op|'='
name|'swift_dir'
newline|'\n'
name|'self'
op|'.'
name|'mtimes_by_ring_path'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'portsets_by_ring_path'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'my_ips'
op|'='
name|'set'
op|'('
name|'whataremyips'
op|'('
name|'bind_ip'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|all_bind_ports_for_node
dedent|''
name|'def'
name|'all_bind_ports_for_node'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given an iterable of IP addresses identifying a storage backend server,\n        return a set of all bind ports defined in all rings for this storage\n        backend server.\n\n        The caller is responsible for not calling this method (which performs\n        at least a stat on all ring files) too frequently.\n        """'
newline|'\n'
comment|"# NOTE: we don't worry about disappearing rings here because you can't"
nl|'\n'
comment|'# ever delete a storage policy.'
nl|'\n'
nl|'\n'
name|'for'
name|'policy'
name|'in'
name|'POLICIES'
op|':'
newline|'\n'
comment|'# NOTE: we must NOT use policy.load_ring to load the ring.  Users'
nl|'\n'
comment|'# of this utility function will not need the actual ring data, just'
nl|'\n'
comment|'# the bind ports.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This is duplicated with Ring.__init__ just a bit...'
nl|'\n'
indent|'            '
name|'serialized_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'swift_dir'
op|','
nl|'\n'
name|'policy'
op|'.'
name|'ring_name'
op|'+'
string|"'.ring.gz'"
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'new_mtime'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'getmtime'
op|'('
name|'serialized_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'old_mtime'
op|'='
name|'self'
op|'.'
name|'mtimes_by_ring_path'
op|'.'
name|'get'
op|'('
name|'serialized_path'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'old_mtime'
name|'or'
name|'old_mtime'
op|'!='
name|'new_mtime'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'portsets_by_ring_path'
op|'['
name|'serialized_path'
op|']'
op|'='
name|'set'
op|'('
nl|'\n'
name|'dev'
op|'['
string|"'port'"
op|']'
nl|'\n'
name|'for'
name|'dev'
name|'in'
name|'RingData'
op|'.'
name|'load'
op|'('
name|'serialized_path'
op|','
nl|'\n'
name|'metadata_only'
op|'='
name|'True'
op|')'
op|'.'
name|'devs'
nl|'\n'
name|'if'
name|'dev'
name|'and'
name|'dev'
op|'['
string|"'ip'"
op|']'
name|'in'
name|'self'
op|'.'
name|'my_ips'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'mtimes_by_ring_path'
op|'['
name|'serialized_path'
op|']'
op|'='
name|'new_mtime'
newline|'\n'
comment|'# No "break" here so that the above line will update the'
nl|'\n'
comment|'# mtimes_by_ring_path entry for any ring that changes, not just'
nl|'\n'
comment|'# the first one we notice.'
nl|'\n'
nl|'\n'
comment|'# Return the requested set of ports from our (now-freshened) cache'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'reduce'
op|'('
name|'set'
op|'.'
name|'union'
op|','
nl|'\n'
name|'self'
op|'.'
name|'portsets_by_ring_path'
op|'.'
name|'values'
op|'('
op|')'
op|','
name|'set'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PolicyError
dedent|''
dedent|''
name|'class'
name|'PolicyError'
op|'('
name|'ValueError'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'msg'
op|','
name|'index'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'+='
string|"', for index %r'"
op|'%'
name|'index'
newline|'\n'
dedent|''
name|'super'
op|'('
name|'PolicyError'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_policy_string
dedent|''
dedent|''
name|'def'
name|'_get_policy_string'
op|'('
name|'base'
op|','
name|'policy_index'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'policy_index'
op|'=='
number|'0'
name|'or'
name|'policy_index'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'return_string'
op|'='
name|'base'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return_string'
op|'='
name|'base'
op|'+'
string|'"-%d"'
op|'%'
name|'int'
op|'('
name|'policy_index'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'return_string'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_policy_string
dedent|''
name|'def'
name|'get_policy_string'
op|'('
name|'base'
op|','
name|'policy_or_index'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to construct a string from a base and the policy.\n    Used to encode the policy index into either a file name or a\n    directory name by various modules.\n\n    :param base: the base string\n    :param policy_or_index: StoragePolicy instance, or an index\n                            (string or int), if None the legacy\n                            storage Policy-0 is assumed.\n\n    :returns: base name with policy index added\n    :raises: PolicyError if no policy exists with the given policy_index\n    """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'policy_or_index'
op|','
name|'BaseStoragePolicy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'policy'
op|'='
name|'policy_or_index'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_or_index'
op|')'
newline|'\n'
name|'if'
name|'policy'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|'"Unknown policy"'
op|','
name|'index'
op|'='
name|'policy_or_index'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'_get_policy_string'
op|'('
name|'base'
op|','
name|'int'
op|'('
name|'policy'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|split_policy_string
dedent|''
name|'def'
name|'split_policy_string'
op|'('
name|'policy_string'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to convert a string representing a base and a\n    policy.  Used to decode the policy from either a file name or\n    a directory name by various modules.\n\n    :param policy_string: base name with policy index added\n\n    :raises: PolicyError if given index does not map to a valid policy\n    :returns: a tuple, in the form (base, policy) where base is the base\n              string and policy is the StoragePolicy instance for the\n              index encoded in the policy_string.\n    """'
newline|'\n'
name|'if'
string|"'-'"
name|'in'
name|'policy_string'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|','
name|'policy_index'
op|'='
name|'policy_string'
op|'.'
name|'rsplit'
op|'('
string|"'-'"
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|','
name|'policy_index'
op|'='
name|'policy_string'
op|','
name|'None'
newline|'\n'
dedent|''
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'if'
name|'get_policy_string'
op|'('
name|'base'
op|','
name|'policy'
op|')'
op|'!='
name|'policy_string'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'PolicyError'
op|'('
string|'"Unknown policy"'
op|','
name|'index'
op|'='
name|'policy_index'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'base'
op|','
name|'policy'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseStoragePolicy
dedent|''
name|'class'
name|'BaseStoragePolicy'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents a storage policy.  Not meant to be instantiated directly;\n    implement a derived subclasses (e.g. StoragePolicy, ECStoragePolicy, etc)\n    or use :func:`~swift.common.storage_policy.reload_storage_policies` to\n    load POLICIES from ``swift.conf``.\n\n    The object_ring property is lazy loaded once the service\'s ``swift_dir``\n    is known via :meth:`~StoragePolicyCollection.get_object_ring`, but it may\n    be over-ridden via object_ring kwarg at create time for testing or\n    actively loaded with :meth:`~StoragePolicy.load_ring`.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|policy_type_to_policy_cls
name|'policy_type_to_policy_cls'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'idx'
op|','
name|'name'
op|'='
string|"''"
op|','
name|'is_default'
op|'='
name|'False'
op|','
name|'is_deprecated'
op|'='
name|'False'
op|','
nl|'\n'
name|'object_ring'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# do not allow BaseStoragePolicy class to be instantiated directly'
nl|'\n'
indent|'        '
name|'if'
name|'type'
op|'('
name|'self'
op|')'
op|'=='
name|'BaseStoragePolicy'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"Can\'t instantiate BaseStoragePolicy directly"'
op|')'
newline|'\n'
comment|'# policy parameter validation'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'idx'
op|'='
name|'int'
op|'('
name|'idx'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid index'"
op|','
name|'idx'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'idx'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid index'"
op|','
name|'idx'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'name'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid name %r'"
op|'%'
name|'name'
op|','
name|'idx'
op|')'
newline|'\n'
comment|'# this is defensively restrictive, but could be expanded in the future'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'all'
op|'('
name|'c'
name|'in'
name|'VALID_CHARS'
name|'for'
name|'c'
name|'in'
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Names are used as HTTP headers, and can not '"
nl|'\n'
string|"'reliably contain any characters not in %r. '"
nl|'\n'
string|"'Invalid name %r'"
op|'%'
op|'('
name|'VALID_CHARS'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'name'
op|'.'
name|'upper'
op|'('
op|')'
op|'=='
name|'LEGACY_POLICY_NAME'
op|'.'
name|'upper'
op|'('
op|')'
name|'and'
name|'self'
op|'.'
name|'idx'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|"'The name %s is reserved for policy index 0. '"
string|"'Invalid name %r'"
op|'%'
op|'('
name|'LEGACY_POLICY_NAME'
op|','
name|'name'
op|')'
newline|'\n'
name|'raise'
name|'PolicyError'
op|'('
name|'msg'
op|','
name|'idx'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'is_deprecated'
op|'='
name|'config_true_value'
op|'('
name|'is_deprecated'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'is_default'
op|'='
name|'config_true_value'
op|'('
name|'is_default'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'policy_type'
name|'not'
name|'in'
name|'BaseStoragePolicy'
op|'.'
name|'policy_type_to_policy_cls'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid type'"
op|','
name|'self'
op|'.'
name|'policy_type'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'is_deprecated'
name|'and'
name|'self'
op|'.'
name|'is_default'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Deprecated policy can not be default.  '"
nl|'\n'
string|"'Invalid config'"
op|','
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'ring_name'
op|'='
name|'_get_policy_string'
op|'('
string|"'object'"
op|','
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'object_ring'
op|'='
name|'object_ring'
newline|'\n'
nl|'\n'
DECL|member|__int__
dedent|''
name|'def'
name|'__int__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'idx'
newline|'\n'
nl|'\n'
DECL|member|__cmp__
dedent|''
name|'def'
name|'__cmp__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cmp'
op|'('
name|'self'
op|'.'
name|'idx'
op|','
name|'int'
op|'('
name|'other'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%s(%d, %r, is_default=%s, "'
nl|'\n'
string|'"is_deprecated=%s, policy_type=%r)"'
op|')'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
name|'self'
op|'.'
name|'idx'
op|','
name|'self'
op|'.'
name|'name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'is_default'
op|','
name|'self'
op|'.'
name|'is_deprecated'
op|','
name|'self'
op|'.'
name|'policy_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|register
name|'def'
name|'register'
op|'('
name|'cls'
op|','
name|'policy_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Decorator for Storage Policy implementations to register\n        their StoragePolicy class.  This will also set the policy_type\n        attribute on the registered implementation.\n        """'
newline|'\n'
DECL|function|register_wrapper
name|'def'
name|'register_wrapper'
op|'('
name|'policy_cls'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'policy_type'
name|'in'
name|'cls'
op|'.'
name|'policy_type_to_policy_cls'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
nl|'\n'
string|"'%r is already registered for the policy_type %r'"
op|'%'
op|'('
nl|'\n'
name|'cls'
op|'.'
name|'policy_type_to_policy_cls'
op|'['
name|'policy_type'
op|']'
op|','
nl|'\n'
name|'policy_type'
op|')'
op|')'
newline|'\n'
dedent|''
name|'cls'
op|'.'
name|'policy_type_to_policy_cls'
op|'['
name|'policy_type'
op|']'
op|'='
name|'policy_cls'
newline|'\n'
name|'policy_cls'
op|'.'
name|'policy_type'
op|'='
name|'policy_type'
newline|'\n'
name|'return'
name|'policy_cls'
newline|'\n'
dedent|''
name|'return'
name|'register_wrapper'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|_config_options_map
name|'def'
name|'_config_options_map'
op|'('
name|'cls'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Map config option name to StoragePolicy parameter name.\n        """'
newline|'\n'
name|'return'
op|'{'
nl|'\n'
string|"'name'"
op|':'
string|"'name'"
op|','
nl|'\n'
string|"'policy_type'"
op|':'
string|"'policy_type'"
op|','
nl|'\n'
string|"'default'"
op|':'
string|"'is_default'"
op|','
nl|'\n'
string|"'deprecated'"
op|':'
string|"'is_deprecated'"
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_config
name|'def'
name|'from_config'
op|'('
name|'cls'
op|','
name|'policy_index'
op|','
name|'options'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'config_to_policy_option_map'
op|'='
name|'cls'
op|'.'
name|'_config_options_map'
op|'('
op|')'
newline|'\n'
name|'policy_options'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'config_option'
op|','
name|'value'
name|'in'
name|'options'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'policy_option'
op|'='
name|'config_to_policy_option_map'
op|'['
name|'config_option'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid option %r in '"
nl|'\n'
string|"'storage-policy section'"
op|'%'
name|'config_option'
op|','
nl|'\n'
name|'index'
op|'='
name|'policy_index'
op|')'
newline|'\n'
dedent|''
name|'policy_options'
op|'['
name|'policy_option'
op|']'
op|'='
name|'value'
newline|'\n'
dedent|''
name|'return'
name|'cls'
op|'('
name|'policy_index'
op|','
op|'**'
name|'policy_options'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'config'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the info dict and conf file options for this policy.\n\n        :param config: boolean, if True all config options are returned\n        """'
newline|'\n'
name|'info'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'config_option'
op|','
name|'policy_attribute'
name|'in'
name|'self'
op|'.'
name|'_config_options_map'
op|'('
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'['
name|'config_option'
op|']'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
name|'policy_attribute'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'config'
op|':'
newline|'\n'
comment|'# remove some options for public consumption'
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'is_default'
op|':'
newline|'\n'
indent|'                '
name|'info'
op|'.'
name|'pop'
op|'('
string|"'default'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'is_deprecated'
op|':'
newline|'\n'
indent|'                '
name|'info'
op|'.'
name|'pop'
op|'('
string|"'deprecated'"
op|')'
newline|'\n'
dedent|''
name|'info'
op|'.'
name|'pop'
op|'('
string|"'policy_type'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
DECL|member|_validate_ring
dedent|''
name|'def'
name|'_validate_ring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Hook, called when the ring is loaded.  Can be used to\n        validate the ring against the StoragePolicy configuration.\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|load_ring
dedent|''
name|'def'
name|'load_ring'
op|'('
name|'self'
op|','
name|'swift_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Load the ring for this policy immediately.\n\n        :param swift_dir: path to rings\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'object_ring'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'object_ring'
op|'='
name|'Ring'
op|'('
name|'swift_dir'
op|','
name|'ring_name'
op|'='
name|'self'
op|'.'
name|'ring_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# Validate ring to make sure it conforms to policy requirements'
nl|'\n'
name|'self'
op|'.'
name|'_validate_ring'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|quorum
name|'def'
name|'quorum'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Number of successful backend requests needed for the proxy to\n        consider the client request successful.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'BaseStoragePolicy'
op|'.'
name|'register'
op|'('
name|'REPL_POLICY'
op|')'
newline|'\n'
DECL|class|StoragePolicy
name|'class'
name|'StoragePolicy'
op|'('
name|'BaseStoragePolicy'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents a storage policy of type \'replication\'.  Default storage policy\n    class unless otherwise overridden from swift.conf.\n\n    Not meant to be instantiated directly; use\n    :func:`~swift.common.storage_policy.reload_storage_policies` to load\n    POLICIES from ``swift.conf``.\n    """'
newline|'\n'
nl|'\n'
op|'@'
name|'property'
newline|'\n'
DECL|member|quorum
name|'def'
name|'quorum'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Quorum concept in the replication case:\n            floor(number of replica / 2) + 1\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'object_ring'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Ring is not loaded'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'quorum_size'
op|'('
name|'self'
op|'.'
name|'object_ring'
op|'.'
name|'replica_count'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'BaseStoragePolicy'
op|'.'
name|'register'
op|'('
name|'EC_POLICY'
op|')'
newline|'\n'
DECL|class|ECStoragePolicy
name|'class'
name|'ECStoragePolicy'
op|'('
name|'BaseStoragePolicy'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents a storage policy of type \'erasure_coding\'.\n\n    Not meant to be instantiated directly; use\n    :func:`~swift.common.storage_policy.reload_storage_policies` to load\n    POLICIES from ``swift.conf``.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'idx'
op|','
name|'name'
op|'='
string|"''"
op|','
name|'is_default'
op|'='
name|'False'
op|','
nl|'\n'
name|'is_deprecated'
op|'='
name|'False'
op|','
name|'object_ring'
op|'='
name|'None'
op|','
nl|'\n'
name|'ec_segment_size'
op|'='
name|'DEFAULT_EC_OBJECT_SEGMENT_SIZE'
op|','
nl|'\n'
name|'ec_type'
op|'='
name|'None'
op|','
name|'ec_ndata'
op|'='
name|'None'
op|','
name|'ec_nparity'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'super'
op|'('
name|'ECStoragePolicy'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
nl|'\n'
name|'idx'
op|','
name|'name'
op|','
name|'is_default'
op|','
name|'is_deprecated'
op|','
name|'object_ring'
op|')'
newline|'\n'
nl|'\n'
comment|'# Validate erasure_coding policy specific members'
nl|'\n'
comment|'# ec_type is one of the EC implementations supported by PyEClib'
nl|'\n'
name|'if'
name|'ec_type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Missing ec_type'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'ec_type'
name|'not'
name|'in'
name|'VALID_EC_TYPES'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Wrong ec_type %s for policy %s, should be one'"
nl|'\n'
string|'\' of "%s"\''
op|'%'
op|'('
name|'ec_type'
op|','
name|'self'
op|'.'
name|'name'
op|','
nl|'\n'
string|"', '"
op|'.'
name|'join'
op|'('
name|'VALID_EC_TYPES'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ec_type'
op|'='
name|'ec_type'
newline|'\n'
nl|'\n'
comment|'# Define _ec_ndata as the number of EC data fragments'
nl|'\n'
comment|'# Accessible as the property "ec_ndata"'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'int'
op|'('
name|'ec_ndata'
op|')'
newline|'\n'
name|'if'
name|'value'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ec_ndata'
op|'='
name|'value'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid ec_num_data_fragments %r'"
op|'%'
nl|'\n'
name|'ec_ndata'
op|','
name|'index'
op|'='
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
nl|'\n'
comment|'# Define _ec_nparity as the number of EC parity fragments'
nl|'\n'
comment|'# Accessible as the property "ec_nparity"'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'int'
op|'('
name|'ec_nparity'
op|')'
newline|'\n'
name|'if'
name|'value'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ec_nparity'
op|'='
name|'value'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid ec_num_parity_fragments %r'"
nl|'\n'
op|'%'
name|'ec_nparity'
op|','
name|'index'
op|'='
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
nl|'\n'
comment|'# Define _ec_segment_size as the encode segment unit size'
nl|'\n'
comment|'# Accessible as the property "ec_segment_size"'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'int'
op|'('
name|'ec_segment_size'
op|')'
newline|'\n'
name|'if'
name|'value'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ec_segment_size'
op|'='
name|'value'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Invalid ec_object_segment_size %r'"
op|'%'
nl|'\n'
name|'ec_segment_size'
op|','
name|'index'
op|'='
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initialize PyECLib EC backend'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pyeclib_driver'
op|'='
name|'ECDriver'
op|'('
name|'k'
op|'='
name|'self'
op|'.'
name|'_ec_ndata'
op|','
name|'m'
op|'='
name|'self'
op|'.'
name|'_ec_nparity'
op|','
nl|'\n'
name|'ec_type'
op|'='
name|'self'
op|'.'
name|'_ec_type'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ECDriverError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|'"Error creating EC policy (%s)"'
op|'%'
name|'e'
op|','
nl|'\n'
name|'index'
op|'='
name|'self'
op|'.'
name|'idx'
op|')'
newline|'\n'
nl|'\n'
comment|'# quorum size in the EC case depends on the choice of EC scheme.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_ec_quorum_size'
op|'='
name|'self'
op|'.'
name|'_ec_ndata'
op|'+'
name|'self'
op|'.'
name|'pyeclib_driver'
op|'.'
name|'min_parity_fragments_needed'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|ec_type
name|'def'
name|'ec_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_ec_type'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|ec_ndata
name|'def'
name|'ec_ndata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_ec_ndata'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|ec_nparity
name|'def'
name|'ec_nparity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_ec_nparity'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|ec_segment_size
name|'def'
name|'ec_segment_size'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_ec_segment_size'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|fragment_size
name|'def'
name|'fragment_size'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Maximum length of a fragment, including header.\n\n        NB: a fragment archive is a sequence of 0 or more max-length\n        fragments followed by one possibly-shorter fragment.\n        """'
newline|'\n'
comment|"# Technically pyeclib's get_segment_info signature calls for"
nl|'\n'
comment|"# (data_len, segment_size) but on a ranged GET we don't know the"
nl|'\n'
comment|'# ec-content-length header before we need to compute where in the'
nl|'\n'
comment|'# object we should request to align with the fragment size.  So we'
nl|'\n'
comment|"# tell pyeclib a lie - from it's perspective, as long as data_len >="
nl|'\n'
comment|"# segment_size it'll give us the answer we want.  From our"
nl|'\n'
comment|'# perspective, because we only use this answer to calculate the'
nl|'\n'
comment|'# *minimum* size we should read from an object body even if data_len <'
nl|'\n'
comment|"# segment_size we'll still only read *the whole one and only last"
nl|'\n'
comment|'# fragment* and pass than into pyeclib who will know what to do with'
nl|'\n'
comment|'# it just as it always does when the last fragment is < fragment_size.'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'pyeclib_driver'
op|'.'
name|'get_segment_info'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'ec_segment_size'
op|','
name|'self'
op|'.'
name|'ec_segment_size'
op|')'
op|'['
string|"'fragment_size'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|ec_scheme_description
name|'def'
name|'ec_scheme_description'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This short hand form of the important parts of the ec schema is stored\n        in Object System Metadata on the EC Fragment Archives for debugging.\n        """'
newline|'\n'
name|'return'
string|'"%s %d+%d"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_ec_type'
op|','
name|'self'
op|'.'
name|'_ec_ndata'
op|','
name|'self'
op|'.'
name|'_ec_nparity'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%s, EC config(ec_type=%s, ec_segment_size=%d, "'
nl|'\n'
string|'"ec_ndata=%d, ec_nparity=%d)"'
op|')'
op|'%'
op|'('
nl|'\n'
name|'super'
op|'('
name|'ECStoragePolicy'
op|','
name|'self'
op|')'
op|'.'
name|'__repr__'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'ec_type'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ec_segment_size'
op|','
name|'self'
op|'.'
name|'ec_ndata'
op|','
name|'self'
op|'.'
name|'ec_nparity'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|_config_options_map
name|'def'
name|'_config_options_map'
op|'('
name|'cls'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'options'
op|'='
name|'super'
op|'('
name|'ECStoragePolicy'
op|','
name|'cls'
op|')'
op|'.'
name|'_config_options_map'
op|'('
op|')'
newline|'\n'
name|'options'
op|'.'
name|'update'
op|'('
op|'{'
nl|'\n'
string|"'ec_type'"
op|':'
string|"'ec_type'"
op|','
nl|'\n'
string|"'ec_object_segment_size'"
op|':'
string|"'ec_segment_size'"
op|','
nl|'\n'
string|"'ec_num_data_fragments'"
op|':'
string|"'ec_ndata'"
op|','
nl|'\n'
string|"'ec_num_parity_fragments'"
op|':'
string|"'ec_nparity'"
op|','
nl|'\n'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'options'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'config'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'info'
op|'='
name|'super'
op|'('
name|'ECStoragePolicy'
op|','
name|'self'
op|')'
op|'.'
name|'get_info'
op|'('
name|'config'
op|'='
name|'config'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'config'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'.'
name|'pop'
op|'('
string|"'ec_object_segment_size'"
op|')'
newline|'\n'
name|'info'
op|'.'
name|'pop'
op|'('
string|"'ec_num_data_fragments'"
op|')'
newline|'\n'
name|'info'
op|'.'
name|'pop'
op|'('
string|"'ec_num_parity_fragments'"
op|')'
newline|'\n'
name|'info'
op|'.'
name|'pop'
op|'('
string|"'ec_type'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
DECL|member|_validate_ring
dedent|''
name|'def'
name|'_validate_ring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        EC specific validation\n\n        Replica count check - we need _at_least_ (#data + #parity) replicas\n        configured.  Also if the replica count is larger than exactly that\n        number there\'s a non-zero risk of error for code that is considering\n        the number of nodes in the primary list from the ring.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'object_ring'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|"'Ring is not loaded'"
op|')'
newline|'\n'
dedent|''
name|'nodes_configured'
op|'='
name|'self'
op|'.'
name|'object_ring'
op|'.'
name|'replica_count'
newline|'\n'
name|'if'
name|'nodes_configured'
op|'!='
op|'('
name|'self'
op|'.'
name|'ec_ndata'
op|'+'
name|'self'
op|'.'
name|'ec_nparity'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RingValidationError'
op|'('
nl|'\n'
string|"'EC ring for policy %s needs to be configured with '"
nl|'\n'
string|"'exactly %d nodes. Got %d.'"
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'name'
op|','
name|'self'
op|'.'
name|'ec_ndata'
op|'+'
name|'self'
op|'.'
name|'ec_nparity'
op|','
nl|'\n'
name|'nodes_configured'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|quorum
name|'def'
name|'quorum'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Number of successful backend requests needed for the proxy to consider\n        the client request successful.\n\n        The quorum size for EC policies defines the minimum number\n        of data + parity elements required to be able to guarantee\n        the desired fault tolerance, which is the number of data\n        elements supplemented by the minimum number of parity\n        elements required by the chosen erasure coding scheme.\n\n        For example, for Reed-Solomon, the minimum number parity\n        elements required is 1, and thus the quorum_size requirement\n        is ec_ndata + 1.\n\n        Given the number of parity elements required is not the same\n        for every erasure coding scheme, consult PyECLib for\n        min_parity_fragments_needed()\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_ec_quorum_size'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StoragePolicyCollection
dedent|''
dedent|''
name|'class'
name|'StoragePolicyCollection'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This class represents the collection of valid storage policies for the\n    cluster and is instantiated as :class:`StoragePolicy` objects are added to\n    the collection when ``swift.conf`` is parsed by\n    :func:`parse_storage_policies`.\n\n    When a StoragePolicyCollection is created, the following validation\n    is enforced:\n\n    * If a policy with index 0 is not declared and no other policies defined,\n      Swift will create one\n    * The policy index must be a non-negative integer\n    * If no policy is declared as the default and no other policies are\n      defined, the policy with index 0 is set as the default\n    * Policy indexes must be unique\n    * Policy names are required\n    * Policy names are case insensitive\n    * Policy names must contain only letters, digits or a dash\n    * Policy names must be unique\n    * The policy name \'Policy-0\' can only be used for the policy with index 0\n    * If any policies are defined, exactly one policy must be declared default\n    * Deprecated policies can not be declared the default\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'pols'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'default'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'by_name'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'by_index'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_validate_policies'
op|'('
name|'pols'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_policy
dedent|''
name|'def'
name|'_add_policy'
op|'('
name|'self'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add pre-validated policies to internal indexes.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'by_name'
op|'['
name|'policy'
op|'.'
name|'name'
op|'.'
name|'upper'
op|'('
op|')'
op|']'
op|'='
name|'policy'
newline|'\n'
name|'self'
op|'.'
name|'by_index'
op|'['
name|'int'
op|'('
name|'policy'
op|')'
op|']'
op|'='
name|'policy'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'textwrap'
op|'.'
name|'dedent'
op|'('
string|'"""\n    StoragePolicyCollection([\n        %s\n    ])\n    """'
op|')'
op|'%'
string|"',\\n    '"
op|'.'
name|'join'
op|'('
name|'repr'
op|'('
name|'p'
op|')'
name|'for'
name|'p'
name|'in'
name|'self'
op|')'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__len__
dedent|''
name|'def'
name|'__len__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'len'
op|'('
name|'self'
op|'.'
name|'by_index'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'by_index'
op|'['
name|'key'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'iter'
op|'('
name|'self'
op|'.'
name|'by_index'
op|'.'
name|'values'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_validate_policies
dedent|''
name|'def'
name|'_validate_policies'
op|'('
name|'self'
op|','
name|'policies'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        :param policies: list of policies\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'policy'
name|'in'
name|'policies'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'int'
op|'('
name|'policy'
op|')'
name|'in'
name|'self'
op|'.'
name|'by_index'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
string|"'Duplicate index %s conflicts with %s'"
op|'%'
op|'('
nl|'\n'
name|'policy'
op|','
name|'self'
op|'.'
name|'get_by_index'
op|'('
name|'int'
op|'('
name|'policy'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'policy'
op|'.'
name|'name'
op|'.'
name|'upper'
op|'('
op|')'
name|'in'
name|'self'
op|'.'
name|'by_name'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
string|"'Duplicate name %s conflicts with %s'"
op|'%'
op|'('
nl|'\n'
name|'policy'
op|','
name|'self'
op|'.'
name|'get_by_name'
op|'('
name|'policy'
op|'.'
name|'name'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'policy'
op|'.'
name|'is_default'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'self'
op|'.'
name|'default'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'default'
op|'='
name|'policy'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'PolicyError'
op|'('
nl|'\n'
string|"'Duplicate default %s conflicts with %s'"
op|'%'
op|'('
nl|'\n'
name|'policy'
op|','
name|'self'
op|'.'
name|'default'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_add_policy'
op|'('
name|'policy'
op|')'
newline|'\n'
nl|'\n'
comment|"# If a 0 policy wasn't explicitly given, or nothing was"
nl|'\n'
comment|'# provided, create the 0 policy now'
nl|'\n'
dedent|''
name|'if'
number|'0'
name|'not'
name|'in'
name|'self'
op|'.'
name|'by_index'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'self'
op|')'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
string|"'You must specify a storage policy '"
nl|'\n'
string|"'section for policy index 0 in order '"
nl|'\n'
string|"'to define multiple policies'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_add_policy'
op|'('
name|'StoragePolicy'
op|'('
number|'0'
op|','
name|'name'
op|'='
name|'LEGACY_POLICY_NAME'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# at least one policy must be enabled'
nl|'\n'
dedent|''
name|'enabled_policies'
op|'='
op|'['
name|'p'
name|'for'
name|'p'
name|'in'
name|'self'
name|'if'
name|'not'
name|'p'
op|'.'
name|'is_deprecated'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'enabled_policies'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|'"Unable to find policy that\'s not deprecated!"'
op|')'
newline|'\n'
nl|'\n'
comment|'# if needed, specify default'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'default'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'self'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
string|'"Unable to find default policy"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'default'
op|'='
name|'self'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'default'
op|'.'
name|'is_default'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|get_by_name
dedent|''
dedent|''
name|'def'
name|'get_by_name'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Find a storage policy by its name.\n\n        :param name: name of the policy\n        :returns: storage policy, or None\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'by_name'
op|'.'
name|'get'
op|'('
name|'name'
op|'.'
name|'upper'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_by_index
dedent|''
name|'def'
name|'get_by_index'
op|'('
name|'self'
op|','
name|'index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Find a storage policy by its index.\n\n        An index of None will be treated as 0.\n\n        :param index: numeric index of the storage policy\n        :returns: storage policy, or None if no such policy\n        """'
newline|'\n'
comment|'# makes it easier for callers to just pass in a header value'
nl|'\n'
name|'if'
name|'index'
name|'in'
op|'('
string|"''"
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'index'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'index'
op|'='
name|'int'
op|'('
name|'index'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'by_index'
op|'.'
name|'get'
op|'('
name|'index'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|legacy
name|'def'
name|'legacy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'get_by_index'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_object_ring
dedent|''
name|'def'
name|'get_object_ring'
op|'('
name|'self'
op|','
name|'policy_idx'
op|','
name|'swift_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the ring object to use to handle a request based on its policy.\n\n        An index of None will be treated as 0.\n\n        :param policy_idx: policy index as defined in swift.conf\n        :param swift_dir: swift_dir used by the caller\n        :returns: appropriate ring object\n        """'
newline|'\n'
name|'policy'
op|'='
name|'self'
op|'.'
name|'get_by_index'
op|'('
name|'policy_idx'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'policy'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PolicyError'
op|'('
string|'"No policy with index %s"'
op|'%'
name|'policy_idx'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'policy'
op|'.'
name|'object_ring'
op|':'
newline|'\n'
indent|'            '
name|'policy'
op|'.'
name|'load_ring'
op|'('
name|'swift_dir'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'policy'
op|'.'
name|'object_ring'
newline|'\n'
nl|'\n'
DECL|member|get_policy_info
dedent|''
name|'def'
name|'get_policy_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Build info about policies for the /info endpoint\n\n        :returns: list of dicts containing relevant policy information\n        """'
newline|'\n'
name|'policy_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'pol'
name|'in'
name|'self'
op|':'
newline|'\n'
comment|'# delete from /info if deprecated'
nl|'\n'
indent|'            '
name|'if'
name|'pol'
op|'.'
name|'is_deprecated'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'policy_entry'
op|'='
name|'pol'
op|'.'
name|'get_info'
op|'('
op|')'
newline|'\n'
name|'policy_info'
op|'.'
name|'append'
op|'('
name|'policy_entry'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'policy_info'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_storage_policies
dedent|''
dedent|''
name|'def'
name|'parse_storage_policies'
op|'('
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parse storage policies in ``swift.conf`` - note that validation\n    is done when the :class:`StoragePolicyCollection` is instantiated.\n\n    :param conf: ConfigParser parser object for swift.conf\n    """'
newline|'\n'
name|'policies'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'section'
name|'in'
name|'conf'
op|'.'
name|'sections'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'section'
op|'.'
name|'startswith'
op|'('
string|"'storage-policy:'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'policy_index'
op|'='
name|'section'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'config_options'
op|'='
name|'dict'
op|'('
name|'conf'
op|'.'
name|'items'
op|'('
name|'section'
op|')'
op|')'
newline|'\n'
name|'policy_type'
op|'='
name|'config_options'
op|'.'
name|'pop'
op|'('
string|"'policy_type'"
op|','
name|'DEFAULT_POLICY_TYPE'
op|')'
newline|'\n'
name|'policy_cls'
op|'='
name|'BaseStoragePolicy'
op|'.'
name|'policy_type_to_policy_cls'
op|'['
name|'policy_type'
op|']'
newline|'\n'
name|'policy'
op|'='
name|'policy_cls'
op|'.'
name|'from_config'
op|'('
name|'policy_index'
op|','
name|'config_options'
op|')'
newline|'\n'
name|'policies'
op|'.'
name|'append'
op|'('
name|'policy'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'StoragePolicyCollection'
op|'('
name|'policies'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StoragePolicySingleton
dedent|''
name|'class'
name|'StoragePolicySingleton'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An instance of this class is the primary interface to storage policies\n    exposed as a module level global named ``POLICIES``.  This global\n    reference wraps ``_POLICIES`` which is normally instantiated by parsing\n    ``swift.conf`` and will result in an instance of\n    :class:`StoragePolicyCollection`.\n\n    You should never patch this instance directly, instead patch the module\n    level ``_POLICIES`` instance so that swift code which imported\n    ``POLICIES`` directly will reference the patched\n    :class:`StoragePolicyCollection`.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__iter__
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'iter'
op|'('
name|'_POLICIES'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__len__
dedent|''
name|'def'
name|'__len__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'len'
op|'('
name|'_POLICIES'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_POLICIES'
op|'['
name|'key'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__getattribute__
dedent|''
name|'def'
name|'__getattribute__'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'getattr'
op|'('
name|'_POLICIES'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'repr'
op|'('
name|'_POLICIES'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|reload_storage_policies
dedent|''
dedent|''
name|'def'
name|'reload_storage_policies'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Reload POLICIES from ``swift.conf``.\n    """'
newline|'\n'
name|'global'
name|'_POLICIES'
newline|'\n'
name|'policy_conf'
op|'='
name|'ConfigParser'
op|'('
op|')'
newline|'\n'
name|'policy_conf'
op|'.'
name|'read'
op|'('
name|'SWIFT_CONF_FILE'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_POLICIES'
op|'='
name|'parse_storage_policies'
op|'('
name|'policy_conf'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PolicyError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'SystemExit'
op|'('
string|"'ERROR: Invalid Storage Policy Configuration '"
nl|'\n'
string|"'in %s (%s)'"
op|'%'
op|'('
name|'SWIFT_CONF_FILE'
op|','
name|'e'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# parse configuration and setup singleton'
nl|'\n'
DECL|variable|_POLICIES
dedent|''
dedent|''
name|'_POLICIES'
op|'='
name|'None'
newline|'\n'
name|'reload_storage_policies'
op|'('
op|')'
newline|'\n'
DECL|variable|POLICIES
name|'POLICIES'
op|'='
name|'StoragePolicySingleton'
op|'('
op|')'
newline|'\n'
endmarker|''
end_unit
