begin_unit
comment|'# Copyright (c) 2010-2013 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
string|'"""\nDisk File Interface for the Swift Object Server\n\nThe `DiskFile`, `DiskFileWriter` and `DiskFileReader` classes combined define\nthe on-disk abstraction layer for supporting the object server REST API\ninterfaces (excluding `REPLICATE`). Other implementations wishing to provide\nan alternative backend for the object server must implement the three\nclasses. An example alternative implementation can be found in the\n`mem_server.py` and `mem_diskfile.py` modules along size this one.\n\nThe `DiskFileManager` is a reference implemenation specific class and is not\npart of the backend API.\n\nThe remaining methods in this module are considered implementation specific and\nare also not considered part of the backend API.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'fcntl'
newline|'\n'
name|'import'
name|'json'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'import'
name|'hashlib'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
name|'import'
name|'xattr'
newline|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'basename'
op|','
name|'dirname'
op|','
name|'exists'
op|','
name|'getmtime'
op|','
name|'join'
op|','
name|'splitext'
newline|'\n'
name|'from'
name|'random'
name|'import'
name|'shuffle'
newline|'\n'
name|'from'
name|'tempfile'
name|'import'
name|'mkstemp'
newline|'\n'
name|'from'
name|'contextlib'
name|'import'
name|'contextmanager'
newline|'\n'
name|'from'
name|'collections'
name|'import'
name|'defaultdict'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'Timeout'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'hubs'
name|'import'
name|'trampoline'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
name|'import'
name|'gettext_'
name|'as'
name|'_'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'constraints'
name|'import'
name|'check_mount'
op|','
name|'check_dir'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'request_helpers'
name|'import'
name|'is_sys_meta'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'mkdirs'
op|','
name|'Timestamp'
op|','
name|'storage_directory'
op|','
name|'hash_path'
op|','
name|'renamer'
op|','
name|'fallocate'
op|','
name|'fsync'
op|','
name|'fdatasync'
op|','
name|'fsync_dir'
op|','
name|'drop_buffer_cache'
op|','
name|'ThreadPool'
op|','
name|'lock_path'
op|','
name|'write_pickle'
op|','
name|'config_true_value'
op|','
name|'listdir'
op|','
name|'split_path'
op|','
name|'ismount'
op|','
name|'remove_file'
op|','
name|'get_md5_socket'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'decode_timestamps'
op|','
name|'encode_timestamps'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'splice'
name|'import'
name|'splice'
op|','
name|'tee'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'DiskFileQuarantined'
op|','
name|'DiskFileNotExist'
op|','
name|'DiskFileCollision'
op|','
name|'DiskFileNoSpace'
op|','
name|'DiskFileDeviceUnavailable'
op|','
name|'DiskFileDeleted'
op|','
name|'DiskFileError'
op|','
name|'DiskFileNotOpen'
op|','
name|'PathNotDir'
op|','
name|'ReplicationLockTimeout'
op|','
name|'DiskFileExpired'
op|','
name|'DiskFileXattrNotSupported'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'swob'
name|'import'
name|'multi_range_iterator'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'storage_policy'
name|'import'
op|'('
nl|'\n'
name|'get_policy_string'
op|','
name|'split_policy_string'
op|','
name|'PolicyError'
op|','
name|'POLICIES'
op|','
nl|'\n'
name|'REPL_POLICY'
op|','
name|'EC_POLICY'
op|')'
newline|'\n'
name|'from'
name|'functools'
name|'import'
name|'partial'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|PICKLE_PROTOCOL
name|'PICKLE_PROTOCOL'
op|'='
number|'2'
newline|'\n'
DECL|variable|ONE_WEEK
name|'ONE_WEEK'
op|'='
number|'604800'
newline|'\n'
DECL|variable|HASH_FILE
name|'HASH_FILE'
op|'='
string|"'hashes.pkl'"
newline|'\n'
DECL|variable|HASH_INVALIDATIONS_FILE
name|'HASH_INVALIDATIONS_FILE'
op|'='
string|"'hashes.invalid'"
newline|'\n'
DECL|variable|METADATA_KEY
name|'METADATA_KEY'
op|'='
string|"'user.swift.metadata'"
newline|'\n'
DECL|variable|DROP_CACHE_WINDOW
name|'DROP_CACHE_WINDOW'
op|'='
number|'1024'
op|'*'
number|'1024'
newline|'\n'
comment|'# These are system-set metadata keys that cannot be changed with a POST.'
nl|'\n'
comment|'# They should be lowercase.'
nl|'\n'
DECL|variable|DATAFILE_SYSTEM_META
name|'DATAFILE_SYSTEM_META'
op|'='
name|'set'
op|'('
string|"'content-length deleted etag'"
op|'.'
name|'split'
op|'('
op|')'
op|')'
newline|'\n'
DECL|variable|DATADIR_BASE
name|'DATADIR_BASE'
op|'='
string|"'objects'"
newline|'\n'
DECL|variable|ASYNCDIR_BASE
name|'ASYNCDIR_BASE'
op|'='
string|"'async_pending'"
newline|'\n'
DECL|variable|TMP_BASE
name|'TMP_BASE'
op|'='
string|"'tmp'"
newline|'\n'
DECL|variable|get_data_dir
name|'get_data_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'DATADIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_async_dir
name|'get_async_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'ASYNCDIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_tmp_dir
name|'get_tmp_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'TMP_BASE'
op|')'
newline|'\n'
DECL|variable|MD5_OF_EMPTY_STRING
name|'MD5_OF_EMPTY_STRING'
op|'='
string|"'d41d8cd98f00b204e9800998ecf8427e'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_filename
name|'def'
name|'_get_filename'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to get to file name from a file descriptor or filename.\n\n    :param fd: file descriptor or filename.\n\n    :returns: the filename.\n    """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'fd'
op|','
string|"'name'"
op|')'
op|':'
newline|'\n'
comment|'# fd object'
nl|'\n'
indent|'        '
name|'return'
name|'fd'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
comment|'# fd is a filename'
nl|'\n'
dedent|''
name|'return'
name|'fd'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|read_metadata
dedent|''
name|'def'
name|'read_metadata'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to read the pickled metadata from an object file.\n\n    :param fd: file descriptor or filename to load the metadata from\n\n    :returns: dictionary of metadata\n    """'
newline|'\n'
name|'metadata'
op|'='
string|"''"
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'+='
name|'xattr'
op|'.'
name|'getxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
nl|'\n'
op|'('
name|'key'
name|'or'
string|"''"
op|')'
op|')'
op|')'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'IOError'
op|','
name|'OSError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'err'
name|'in'
string|"'ENOTSUP'"
op|','
string|"'EOPNOTSUPP'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
name|'and'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'getattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
string|'"Filesystem at %s does not support xattr"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileXattrNotSupported'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
comment|"# TODO: we might want to re-raise errors that don't denote a missing"
nl|'\n'
comment|'# xattr here.  Seems to be ENODATA on linux and ENOATTR on BSD/OSX.'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|write_metadata
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'fd'
op|','
name|'metadata'
op|','
name|'xattr_size'
op|'='
number|'65536'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to write pickled metadata for an object file.\n\n    :param fd: file descriptor or filename to write the metadata\n    :param metadata: metadata to write\n    """'
newline|'\n'
name|'metastr'
op|'='
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'metadata'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'metastr'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'xattr'
op|'.'
name|'setxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
name|'key'
name|'or'
string|"''"
op|')'
op|','
nl|'\n'
name|'metastr'
op|'['
op|':'
name|'xattr_size'
op|']'
op|')'
newline|'\n'
name|'metastr'
op|'='
name|'metastr'
op|'['
name|'xattr_size'
op|':'
op|']'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'err'
name|'in'
string|"'ENOTSUP'"
op|','
string|"'EOPNOTSUPP'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'hasattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
name|'and'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'getattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'msg'
op|'='
string|'"Filesystem at %s does not support xattr"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileXattrNotSupported'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'e'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
string|'"No space left on device for %s"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|extract_policy
dedent|''
dedent|''
dedent|''
name|'def'
name|'extract_policy'
op|'('
name|'obj_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Extracts the policy for an object (based on the name of the objects\n    directory) given the device-relative path to the object. Returns None in\n    the event that the path is malformed in some way.\n\n    The device-relative path is everything after the mount point; for example:\n\n    /srv/node/d42/objects-5/179/\n        485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    would have device-relative path:\n\n    objects-5/179/485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    :param obj_path: device-relative path of an object, or the full path\n    :returns: a :class:`~swift.common.storage_policy.BaseStoragePolicy` or None\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'obj_portion'
op|'='
name|'obj_path'
op|'['
name|'obj_path'
op|'.'
name|'rindex'
op|'('
name|'DATADIR_BASE'
op|')'
op|':'
op|']'
newline|'\n'
name|'obj_dirname'
op|'='
name|'obj_portion'
op|'['
op|':'
name|'obj_portion'
op|'.'
name|'index'
op|'('
string|"'/'"
op|')'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|','
name|'policy'
op|'='
name|'split_policy_string'
op|'('
name|'obj_dirname'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PolicyError'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'policy'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|quarantine_renamer
dedent|''
name|'def'
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'corrupted_file_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    In the case that a file is corrupted, move it to a quarantined\n    area to allow replication to fix it.\n\n    :params device_path: The path to the device the corrupted file is on.\n    :params corrupted_file_path: The path to the file you want quarantined.\n\n    :returns: path (str) of directory the file was moved to\n    :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY\n                     exceptions from rename\n    """'
newline|'\n'
name|'policy'
op|'='
name|'extract_policy'
op|'('
name|'corrupted_file_path'
op|')'
newline|'\n'
name|'if'
name|'policy'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# TODO: support a quarantine-unknown location'
nl|'\n'
indent|'        '
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'legacy'
newline|'\n'
dedent|''
name|'from_dir'
op|'='
name|'dirname'
op|'('
name|'corrupted_file_path'
op|')'
newline|'\n'
name|'to_dir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
string|"'quarantined'"
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'basename'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|','
name|'fsync'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e'
op|'.'
name|'errno'
name|'not'
name|'in'
op|'('
name|'errno'
op|'.'
name|'EEXIST'
op|','
name|'errno'
op|'.'
name|'ENOTEMPTY'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'to_dir'
op|'='
string|'"%s-%s"'
op|'%'
op|'('
name|'to_dir'
op|','
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|')'
newline|'\n'
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|','
name|'fsync'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'to_dir'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|consolidate_hashes
dedent|''
name|'def'
name|'consolidate_hashes'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Take what\'s in hashes.pkl and hashes.invalid, combine them, write the\n    result back to hashes.pkl, and clear out hashes.invalid.\n\n    :param suffix_dir: absolute path to partition dir containing hashes.pkl\n                       and hashes.invalid\n\n    :returns: the hashes, or None if there\'s no hashes.pkl.\n    """'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'invalidations_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_INVALIDATIONS_FILE'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'hashes_file'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'invalidations_file'
op|')'
op|':'
newline|'\n'
comment|"# no hashes at all -> everything's invalid, so empty the file with"
nl|'\n'
comment|'# the invalid suffixes in it, if it exists'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'open'
op|'('
name|'invalidations_file'
op|','
string|"'wb'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'hashes_fp'
op|':'
newline|'\n'
indent|'                '
name|'pickled_hashes'
op|'='
name|'hashes_fp'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'IOError'
op|','
name|'OSError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'pickled_hashes'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
comment|'# pickle.loads() can raise a wide variety of exceptions when'
nl|'\n'
comment|'# given invalid input depending on the way in which the'
nl|'\n'
comment|'# input is invalid.'
nl|'\n'
indent|'                '
name|'hashes'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'modified'
op|'='
name|'False'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'invalidations_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'inv_fh'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'line'
name|'in'
name|'inv_fh'
op|':'
newline|'\n'
indent|'                    '
name|'suffix'
op|'='
name|'line'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hashes'
name|'is'
name|'not'
name|'None'
name|'and'
name|'hashes'
op|'.'
name|'get'
op|'('
name|'suffix'
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'None'
newline|'\n'
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
op|'('
name|'IOError'
op|','
name|'OSError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'modified'
op|':'
newline|'\n'
indent|'            '
name|'write_pickle'
op|'('
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_dir'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
nl|'\n'
comment|"# Now that all the invalidations are reflected in hashes.pkl, it's"
nl|'\n'
comment|'# safe to clear out the invalidations file.'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'invalidations_file'
op|','
string|"'w'"
op|')'
name|'as'
name|'inv_fh'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'hashes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|invalidate_hash
dedent|''
dedent|''
name|'def'
name|'invalidate_hash'
op|'('
name|'suffix_dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Invalidates the hash for a suffix_dir in the partition\'s hashes file.\n\n    :param suffix_dir: absolute path to suffix dir whose hash needs\n                       invalidating\n    """'
newline|'\n'
nl|'\n'
name|'suffix'
op|'='
name|'basename'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'partition_dir'
op|'='
name|'dirname'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'hashes_file'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'invalidations_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_INVALIDATIONS_FILE'
op|')'
newline|'\n'
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'invalidations_file'
op|','
string|"'ab'"
op|')'
name|'as'
name|'inv_fh'
op|':'
newline|'\n'
indent|'            '
name|'inv_fh'
op|'.'
name|'write'
op|'('
name|'suffix'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AuditLocation
dedent|''
dedent|''
dedent|''
name|'class'
name|'AuditLocation'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents an object location to be audited.\n\n    Other than being a bucket of data, the only useful thing this does is\n    stringify to a filesystem path so the auditor\'s logs look okay.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'device'
op|','
name|'self'
op|'.'
name|'partition'
op|','
name|'self'
op|'.'
name|'policy'
op|'='
op|'('
nl|'\n'
name|'path'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|object_audit_location_generator
dedent|''
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'devices'
op|','
name|'mount_check'
op|'='
name|'True'
op|','
name|'logger'
op|'='
name|'None'
op|','
nl|'\n'
name|'device_dirs'
op|'='
name|'None'
op|','
name|'auditor_type'
op|'='
string|'"ALL"'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a devices path (e.g. "/srv/node"), yield an AuditLocation for all\n    objects stored under that directory if device_dirs isn\'t set.  If\n    device_dirs is set, only yield AuditLocation for the objects under the\n    entries in device_dirs. The AuditLocation only knows the path to the hash\n    directory, not to the .data file therein (if any). This is to avoid a\n    double listdir(hash_dir); the DiskFile object will always do one, so\n    we don\'t.\n\n    :param devices: parent directory of the devices to be audited\n    :param mount_check: flag to check if a mount check should be performed\n                        on devices\n    :param logger: a logger object\n    :param device_dirs: a list of directories under devices to traverse\n    :param auditor_type: either ALL or ZBF\n    """'
newline|'\n'
name|'if'
name|'not'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'listdir'
op|'('
name|'devices'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# remove bogus devices and duplicates from device_dirs'
nl|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'list'
op|'('
nl|'\n'
name|'set'
op|'('
name|'listdir'
op|'('
name|'devices'
op|')'
op|')'
op|'.'
name|'intersection'
op|'('
name|'set'
op|'('
name|'device_dirs'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# randomize devices in case of process restart before sweep completed'
nl|'\n'
dedent|''
name|'shuffle'
op|'('
name|'device_dirs'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'device'
name|'in'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'mount_check'
name|'and'
name|'not'
name|'ismount'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                '
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Skipping %s as it is not mounted'"
op|')'
op|','
name|'device'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
comment|'# loop through object dirs for all policies'
nl|'\n'
dedent|''
name|'device_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dirs'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'device_dir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                '
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Skipping %(dir)s: %(err)s'"
op|')'
op|'%'
op|'{'
string|"'dir'"
op|':'
name|'device_dir'
op|','
nl|'\n'
string|"'err'"
op|':'
name|'e'
op|'.'
name|'strerror'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'dir_'
name|'in'
name|'dirs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dir_'
op|'.'
name|'startswith'
op|'('
name|'DATADIR_BASE'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'base'
op|','
name|'policy'
op|'='
name|'split_policy_string'
op|'('
name|'dir_'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PolicyError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                    '
name|'logger'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|"'Directory %r does not map '"
nl|'\n'
string|"'to a valid policy (%s)'"
op|')'
op|'%'
op|'('
name|'dir_'
op|','
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'datadir_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|','
name|'dir_'
op|')'
newline|'\n'
nl|'\n'
name|'partitions'
op|'='
name|'get_auditor_status'
op|'('
name|'datadir_path'
op|','
name|'logger'
op|','
name|'auditor_type'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'pos'
op|','
name|'partition'
name|'in'
name|'enumerate'
op|'('
name|'partitions'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'update_auditor_status'
op|'('
name|'datadir_path'
op|','
name|'logger'
op|','
nl|'\n'
name|'partitions'
op|'['
name|'pos'
op|':'
op|']'
op|','
name|'auditor_type'
op|')'
newline|'\n'
name|'part_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir_path'
op|','
name|'partition'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'suffixes'
op|'='
name|'listdir'
op|'('
name|'part_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'asuffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'                    '
name|'suff_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'part_path'
op|','
name|'asuffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'hashes'
op|'='
name|'listdir'
op|'('
name|'suff_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'hashes'
op|':'
newline|'\n'
indent|'                        '
name|'hsh_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suff_path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'yield'
name|'AuditLocation'
op|'('
name|'hsh_path'
op|','
name|'device'
op|','
name|'partition'
op|','
nl|'\n'
name|'policy'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'update_auditor_status'
op|'('
name|'datadir_path'
op|','
name|'logger'
op|','
op|'['
op|']'
op|','
name|'auditor_type'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_auditor_status
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_auditor_status'
op|'('
name|'datadir_path'
op|','
name|'logger'
op|','
name|'auditor_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'auditor_status'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'datadir_path'
op|','
string|'"auditor_status_%s.json"'
op|'%'
name|'auditor_type'
op|')'
newline|'\n'
name|'status'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'auditor_status'
op|')'
name|'as'
name|'statusfile'
op|':'
newline|'\n'
indent|'            '
name|'status'
op|'='
name|'statusfile'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
name|'and'
name|'logger'
op|':'
newline|'\n'
indent|'            '
name|'logger'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|"'Cannot read %(auditor_status)s (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'auditor_status'"
op|':'
name|'auditor_status'
op|','
string|"'err'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'listdir'
op|'('
name|'datadir_path'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'status'
op|'='
name|'json'
op|'.'
name|'loads'
op|'('
name|'status'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'logger'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|"'Loading JSON from %(auditor_status)s failed'"
nl|'\n'
string|"' (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'auditor_status'"
op|':'
name|'auditor_status'
op|','
string|"'err'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'listdir'
op|'('
name|'datadir_path'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'status'
op|'['
string|"'partitions'"
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|update_auditor_status
dedent|''
name|'def'
name|'update_auditor_status'
op|'('
name|'datadir_path'
op|','
name|'logger'
op|','
name|'partitions'
op|','
name|'auditor_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'status'
op|'='
name|'json'
op|'.'
name|'dumps'
op|'('
op|'{'
string|"'partitions'"
op|':'
name|'partitions'
op|'}'
op|')'
newline|'\n'
name|'auditor_status'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'datadir_path'
op|','
string|'"auditor_status_%s.json"'
op|'%'
name|'auditor_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'auditor_status'
op|','
string|'"wb"'
op|')'
name|'as'
name|'statusfile'
op|':'
newline|'\n'
indent|'            '
name|'statusfile'
op|'.'
name|'write'
op|'('
name|'status'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'            '
name|'logger'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|"'Cannot write %(auditor_status)s (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'auditor_status'"
op|':'
name|'auditor_status'
op|','
string|"'err'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|clear_auditor_status
dedent|''
dedent|''
dedent|''
name|'def'
name|'clear_auditor_status'
op|'('
name|'devices'
op|','
name|'auditor_type'
op|'='
string|'"ALL"'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'device'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'devices'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'dir_'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dir_'
op|'.'
name|'startswith'
op|'('
string|'"objects"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'datadir_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|','
name|'dir_'
op|')'
newline|'\n'
name|'auditor_status'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'datadir_path'
op|','
string|'"auditor_status_%s.json"'
op|'%'
name|'auditor_type'
op|')'
newline|'\n'
name|'remove_file'
op|'('
name|'auditor_status'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|strip_self
dedent|''
dedent|''
dedent|''
name|'def'
name|'strip_self'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Wrapper to attach module level functions to base class.\n    """'
newline|'\n'
DECL|function|wrapper
name|'def'
name|'wrapper'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'f'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'wrapper'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileRouter
dedent|''
name|'class'
name|'DiskFileRouter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|policy_type_to_manager_cls
indent|'    '
name|'policy_type_to_manager_cls'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|register
name|'def'
name|'register'
op|'('
name|'cls'
op|','
name|'policy_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Decorator for Storage Policy implementations to register\n        their DiskFile implementation.\n        """'
newline|'\n'
DECL|function|register_wrapper
name|'def'
name|'register_wrapper'
op|'('
name|'diskfile_cls'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'policy_type'
name|'in'
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
nl|'\n'
string|"'%r is already registered for the policy_type %r'"
op|'%'
op|'('
nl|'\n'
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy_type'
op|']'
op|','
nl|'\n'
name|'policy_type'
op|')'
op|')'
newline|'\n'
dedent|''
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy_type'
op|']'
op|'='
name|'diskfile_cls'
newline|'\n'
name|'return'
name|'diskfile_cls'
newline|'\n'
dedent|''
name|'return'
name|'register_wrapper'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'policy_to_manager'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'policy'
name|'in'
name|'POLICIES'
op|':'
newline|'\n'
indent|'            '
name|'manager_cls'
op|'='
name|'self'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy'
op|'.'
name|'policy_type'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'policy_to_manager'
op|'['
name|'policy'
op|']'
op|'='
name|'manager_cls'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'policy_to_manager'
op|'['
name|'policy'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseDiskFileManager
dedent|''
dedent|''
name|'class'
name|'BaseDiskFileManager'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Management class for devices, providing common place for shared parameters\n    and methods not provided by the DiskFile class (which primarily services\n    the object server REST API layer).\n\n    The `get_diskfile()` method is how this implementation creates a `DiskFile`\n    object.\n\n    .. note::\n\n        This class is reference implementation specific and not part of the\n        pluggable on-disk backend API.\n\n    .. note::\n\n        TODO(portante): Not sure what the right name to recommend here, as\n        "manager" seemed generic enough, though suggestions are welcome.\n\n    :param conf: caller provided configuration object\n    :param logger: caller provided logger\n    """'
newline|'\n'
nl|'\n'
DECL|variable|diskfile_cls
name|'diskfile_cls'
op|'='
name|'None'
comment|'# must be set by subclasses'
newline|'\n'
nl|'\n'
DECL|variable|invalidate_hash
name|'invalidate_hash'
op|'='
name|'strip_self'
op|'('
name|'invalidate_hash'
op|')'
newline|'\n'
DECL|variable|consolidate_hashes
name|'consolidate_hashes'
op|'='
name|'strip_self'
op|'('
name|'consolidate_hashes'
op|')'
newline|'\n'
DECL|variable|quarantine_renamer
name|'quarantine_renamer'
op|'='
name|'strip_self'
op|'('
name|'quarantine_renamer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'conf'
op|','
name|'logger'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'devices'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'devices'"
op|','
string|"'/srv/node'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'disk_chunk_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'disk_chunk_size'"
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'keep_cache_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'keep_cache_size'"
op|','
number|'5242880'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bytes_per_sync'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mb_per_sync'"
op|','
number|'512'
op|')'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'self'
op|'.'
name|'mount_check'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mount_check'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reclaim_age'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'reclaim_age'"
op|','
name|'ONE_WEEK'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_one_per_device'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'replication_one_per_device'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_lock_timeout'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'replication_lock_timeout'"
op|','
number|'15'
op|')'
op|')'
newline|'\n'
name|'threads_per_disk'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'threads_per_disk'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'='
name|'defaultdict'
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
name|'threads_per_disk'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'conf_wants_splice'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|','
string|"'no'"
op|')'
op|')'
newline|'\n'
comment|"# If the operator wants zero-copy with splice() but we don't have the"
nl|'\n'
comment|'# requisite kernel support, complain so they can go fix it.'
nl|'\n'
name|'if'
name|'conf_wants_splice'
name|'and'
name|'not'
name|'splice'
op|'.'
name|'available'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
string|'"Use of splice() requested (config says \\"splice = %s\\"), "'
nl|'\n'
string|'"but the system does not support it. "'
nl|'\n'
string|'"splice() will not be used."'
op|'%'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'conf_wants_splice'
name|'and'
name|'splice'
op|'.'
name|'available'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'sockfd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|'# AF_ALG socket support was introduced in kernel 2.6.38; on'
nl|'\n'
comment|'# systems with older kernels (or custom-built kernels lacking'
nl|'\n'
comment|"# AF_ALG support), we can't use zero-copy."
nl|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'EAFNOSUPPORT'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
string|'"MD5 sockets not supported. "'
nl|'\n'
string|'"splice() will not be used."'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'True'
newline|'\n'
name|'with'
name|'open'
op|'('
string|"'/proc/sys/fs/pipe-max-size'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'                    '
name|'max_pipe_size'
op|'='
name|'int'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'min'
op|'('
name|'max_pipe_size'
op|','
name|'self'
op|'.'
name|'disk_chunk_size'
op|')'
newline|'\n'
nl|'\n'
DECL|member|make_on_disk_filename
dedent|''
dedent|''
dedent|''
name|'def'
name|'make_on_disk_filename'
op|'('
name|'self'
op|','
name|'timestamp'
op|','
name|'ext'
op|'='
name|'None'
op|','
nl|'\n'
name|'ctype_timestamp'
op|'='
name|'None'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns filename for given timestamp.\n\n        :param timestamp: the object timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        :param ext: an optional string representing a file extension to be\n                    appended to the returned file name\n        :param ctype_timestamp: an optional content-type timestamp, an instance\n                                of :class:`~swift.common.utils.Timestamp`\n        :returns: a file name\n        """'
newline|'\n'
name|'rv'
op|'='
name|'timestamp'
op|'.'
name|'internal'
newline|'\n'
name|'if'
name|'ext'
op|'=='
string|"'.meta'"
name|'and'
name|'ctype_timestamp'
op|':'
newline|'\n'
comment|'# If ctype_timestamp is None then the filename is simply the'
nl|'\n'
comment|'# internal form of the timestamp. If ctype_timestamp is not None'
nl|'\n'
comment|'# then the difference between the raw values of the two timestamps'
nl|'\n'
comment|'# is appended as a hex number, with its sign.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# There are two reasons for encoding the content-type timestamp'
nl|'\n'
comment|'# in the filename in this way. First, it means that two .meta files'
nl|'\n'
comment|'# having the same timestamp but different content-type timestamps'
nl|'\n'
comment|'# (and potentially different content-type values) will be distinct'
nl|'\n'
comment|'# and therefore will be independently replicated when rsync'
nl|'\n'
comment|'# replication is used. That ensures that all nodes end up having'
nl|'\n'
comment|'# all content-type values after replication (with the most recent'
nl|'\n'
comment|'# value being selected when the diskfile is opened). Second, having'
nl|'\n'
comment|'# the content-type encoded in timestamp in the filename makes it'
nl|'\n'
comment|'# possible for the  on disk file search code to determine that'
nl|'\n'
comment|'# timestamp by inspecting only the filename, and not needing to'
nl|'\n'
comment|'# open the file and read its xattrs.'
nl|'\n'
indent|'            '
name|'rv'
op|'='
name|'encode_timestamps'
op|'('
name|'timestamp'
op|','
name|'ctype_timestamp'
op|','
name|'explicit'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'ext'
op|':'
newline|'\n'
indent|'            '
name|'rv'
op|'='
string|"'%s%s'"
op|'%'
op|'('
name|'rv'
op|','
name|'ext'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'rv'
newline|'\n'
nl|'\n'
DECL|member|parse_on_disk_filename
dedent|''
name|'def'
name|'parse_on_disk_filename'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Parse an on disk file name.\n\n        :param filename: the file name including extension\n        :returns: a dict, with keys for timestamp, ext and ctype_timestamp:\n\n            * timestamp is a :class:`~swift.common.utils.Timestamp`\n            * ctype_timestamp is a :class:`~swift.common.utils.Timestamp` or\n              None for .meta files, otherwise None\n            * ext is a string, the file extension including the leading dot or\n              the empty string if the filename has no extension.\n\n            Subclasses may override this method to add further keys to the\n            returned dict.\n\n        :raises DiskFileError: if any part of the filename is not able to be\n                               validated.\n        """'
newline|'\n'
name|'ts_ctype'
op|'='
name|'None'
newline|'\n'
name|'fname'
op|','
name|'ext'
op|'='
name|'splitext'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ext'
op|'=='
string|"'.meta'"
op|':'
newline|'\n'
indent|'                '
name|'timestamp'
op|','
name|'ts_ctype'
op|'='
name|'decode_timestamps'
op|'('
nl|'\n'
name|'fname'
op|','
name|'explicit'
op|'='
name|'True'
op|')'
op|'['
op|':'
number|'2'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'fname'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileError'
op|'('
string|"'Invalid Timestamp value in filename %r'"
nl|'\n'
op|'%'
name|'filename'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'{'
nl|'\n'
string|"'timestamp'"
op|':'
name|'timestamp'
op|','
nl|'\n'
string|"'ext'"
op|':'
name|'ext'
op|','
nl|'\n'
string|"'ctype_timestamp'"
op|':'
name|'ts_ctype'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_process_ondisk_files
dedent|''
name|'def'
name|'_process_ondisk_files'
op|'('
name|'self'
op|','
name|'exts'
op|','
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by get_ondisk_files(). Should be over-ridden to implement\n        subclass specific handling of files.\n\n        :param exts: dict of lists of file info, keyed by extension\n        :param results: a dict that may be updated with results\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|_verify_ondisk_files
dedent|''
name|'def'
name|'_verify_ondisk_files'
op|'('
name|'self'
op|','
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the final combination of on disk files complies with the\n        diskfile contract.\n\n        :param results: files that have been found and accepted\n        :returns: True if the file combination is compliant, False otherwise\n        """'
newline|'\n'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|'='
name|'tuple'
op|'('
nl|'\n'
op|'['
name|'results'
op|'['
name|'key'
op|']'
nl|'\n'
name|'for'
name|'key'
name|'in'
op|'('
string|"'data_file'"
op|','
string|"'meta_file'"
op|','
string|"'ts_file'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'('
op|'('
name|'data_file'
name|'is'
name|'None'
name|'and'
name|'meta_file'
name|'is'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'ts_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'data_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'meta_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'data_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_split_list
dedent|''
name|'def'
name|'_split_list'
op|'('
name|'self'
op|','
name|'original_list'
op|','
name|'condition'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Split a list into two lists. The first list contains the first N items\n        of the original list, in their original order,  where 0 < N <=\n        len(original list). The second list contains the remaining items of the\n        original list, in their original order.\n\n        The index, N, at which the original list is split is the index of the\n        first item in the list that does not satisfy the given condition. Note\n        that the original list should be appropriately sorted if the second\n        list is to contain no items that satisfy the given condition.\n\n        :param original_list: the list to be split.\n        :param condition: a single argument function that will be used to test\n                          for the list item to split on.\n        :return: a tuple of two lists.\n        """'
newline|'\n'
name|'for'
name|'i'
op|','
name|'item'
name|'in'
name|'enumerate'
op|'('
name|'original_list'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'condition'
op|'('
name|'item'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'original_list'
op|'['
op|':'
name|'i'
op|']'
op|','
name|'original_list'
op|'['
name|'i'
op|':'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'original_list'
op|','
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|_split_gt_timestamp
dedent|''
name|'def'
name|'_split_gt_timestamp'
op|'('
name|'self'
op|','
name|'file_info_list'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a list of file info dicts, reverse sorted by timestamp, split the\n        list into two: items newer than timestamp, and items at same time or\n        older than timestamp.\n\n        :param file_info_list: a list of file_info dicts.\n        :param timestamp: a Timestamp.\n        :return: a tuple of two lists.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_split_list'
op|'('
nl|'\n'
name|'file_info_list'
op|','
name|'lambda'
name|'x'
op|':'
name|'x'
op|'['
string|"'timestamp'"
op|']'
op|'>'
name|'timestamp'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_split_gte_timestamp
dedent|''
name|'def'
name|'_split_gte_timestamp'
op|'('
name|'self'
op|','
name|'file_info_list'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a list of file info dicts, reverse sorted by timestamp, split the\n        list into two: items newer than or at same time as the timestamp, and\n        items older than timestamp.\n\n        :param file_info_list: a list of file_info dicts.\n        :param timestamp: a Timestamp.\n        :return: a tuple of two lists.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_split_list'
op|'('
nl|'\n'
name|'file_info_list'
op|','
name|'lambda'
name|'x'
op|':'
name|'x'
op|'['
string|"'timestamp'"
op|']'
op|'>='
name|'timestamp'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_ondisk_files
dedent|''
name|'def'
name|'get_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|','
name|'datadir'
op|','
name|'verify'
op|'='
name|'True'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a simple list of files names, determine the files that constitute\n        a valid fileset i.e. a set of files that defines the state of an\n        object, and determine the files that are obsolete and could be deleted.\n        Note that some files may fall into neither category.\n\n        If a file is considered part of a valid fileset then its info dict will\n        be added to the results dict, keyed by <extension>_info. Any files that\n        are no longer required will have their info dicts added to a list\n        stored under the key \'obsolete\'.\n\n        The results dict will always contain entries with keys \'ts_file\',\n        \'data_file\' and \'meta_file\'. Their values will be the fully qualified\n        path to a file of the corresponding type if there is such a file in the\n        valid fileset, or None.\n\n        :param files: a list of file names.\n        :param datadir: directory name files are from.\n        :param verify: if True verify that the ondisk file contract has not\n                       been violated, otherwise do not verify.\n        :returns: a dict that will contain keys:\n                    ts_file   -> path to a .ts file or None\n                    data_file -> path to a .data file or None\n                    meta_file -> path to a .meta file or None\n                  and may contain keys:\n                    ts_info   -> a file info dict for a .ts file\n                    data_info -> a file info dict for a .data file\n                    meta_info -> a file info dict for a .meta file\n                    obsolete  -> a list of file info dicts for obsolete files\n        """'
newline|'\n'
comment|'# Build the exts data structure:'
nl|'\n'
comment|'# exts is a dict that maps file extensions to a list of file_info'
nl|'\n'
comment|'# dicts for the files having that extension. The file_info dicts are of'
nl|'\n'
comment|'# the form returned by parse_on_disk_filename, with the filename added.'
nl|'\n'
comment|'# Each list is sorted in reverse timestamp order.'
nl|'\n'
nl|'\n'
comment|'# the results dict is used to collect results of file filtering'
nl|'\n'
name|'results'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# The exts dict will be modified during subsequent processing as files'
nl|'\n'
comment|'# are removed to be discarded or ignored.'
nl|'\n'
name|'exts'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'for'
name|'afile'
name|'in'
name|'files'
op|':'
newline|'\n'
comment|'# Categorize files by extension'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'file_info'
op|'='
name|'self'
op|'.'
name|'parse_on_disk_filename'
op|'('
name|'afile'
op|')'
newline|'\n'
name|'file_info'
op|'['
string|"'filename'"
op|']'
op|'='
name|'afile'
newline|'\n'
name|'exts'
op|'['
name|'file_info'
op|'['
string|"'ext'"
op|']'
op|']'
op|'.'
name|'append'
op|'('
name|'file_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir'
name|'or'
string|"''"
op|','
name|'afile'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
string|"'Unexpected file %s: %s'"
op|','
nl|'\n'
name|'file_path'
op|','
name|'e'
op|')'
newline|'\n'
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'unexpected'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'file_path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'ext'
name|'in'
name|'exts'
op|':'
newline|'\n'
comment|'# For each extension sort files into reverse chronological order.'
nl|'\n'
indent|'            '
name|'exts'
op|'['
name|'ext'
op|']'
op|'='
name|'sorted'
op|'('
nl|'\n'
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'key'
op|'='
name|'lambda'
name|'info'
op|':'
name|'info'
op|'['
string|"'timestamp'"
op|']'
op|','
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
comment|'# non-tombstones older than or equal to latest tombstone are'
nl|'\n'
comment|'# obsolete'
nl|'\n'
indent|'            '
name|'for'
name|'ext'
name|'in'
name|'filter'
op|'('
name|'lambda'
name|'ext'
op|':'
name|'ext'
op|'!='
string|"'.ts'"
op|','
name|'exts'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'older'
op|'='
name|'self'
op|'.'
name|'_split_gt_timestamp'
op|'('
nl|'\n'
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'exts'
op|'['
string|"'.ts'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
newline|'\n'
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'older'
op|')'
newline|'\n'
comment|'# all but most recent .ts are obsolete'
nl|'\n'
dedent|''
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'exts'
op|'['
string|"'.ts'"
op|']'
op|'['
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
name|'exts'
op|'['
string|"'.ts'"
op|']'
op|'='
name|'exts'
op|'['
string|"'.ts'"
op|']'
op|'['
op|':'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
op|':'
newline|'\n'
comment|'# retain the newest meta file'
nl|'\n'
indent|'            '
name|'retain'
op|'='
number|'1'
newline|'\n'
name|'if'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|':'
op|']'
op|':'
newline|'\n'
comment|'# there are other meta files so find the one with newest'
nl|'\n'
comment|'# ctype_timestamp...'
nl|'\n'
indent|'                '
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|':'
op|']'
op|'='
name|'sorted'
op|'('
nl|'\n'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|':'
op|']'
op|','
nl|'\n'
name|'key'
op|'='
name|'lambda'
name|'info'
op|':'
name|'info'
op|'['
string|"'ctype_timestamp'"
op|']'
op|','
nl|'\n'
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# ...and retain this IFF its ctype_timestamp is greater than'
nl|'\n'
comment|'# newest meta file'
nl|'\n'
name|'if'
op|'('
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|']'
op|'['
string|"'ctype_timestamp'"
op|']'
op|'>'
nl|'\n'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'ctype_timestamp'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
op|'('
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|'=='
nl|'\n'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
op|':'
newline|'\n'
comment|'# both at same timestamp so retain only the one with'
nl|'\n'
comment|'# newest ctype'
nl|'\n'
indent|'                        '
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
op|':'
number|'2'
op|']'
op|'='
op|'['
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'retain'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# retain both - first has newest metadata, second has'
nl|'\n'
comment|'# newest ctype'
nl|'\n'
indent|'                        '
name|'retain'
op|'='
number|'2'
newline|'\n'
comment|'# discard all meta files not being retained...'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
name|'retain'
op|':'
op|']'
op|')'
newline|'\n'
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'='
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
op|':'
name|'retain'
op|']'
newline|'\n'
nl|'\n'
comment|'# delegate to subclass handler'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_process_ondisk_files'
op|'('
name|'exts'
op|','
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
comment|'# set final choice of files'
nl|'\n'
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'['
string|"'ts_info'"
op|']'
op|'='
name|'exts'
op|'['
string|"'.ts'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
string|"'data_info'"
name|'in'
name|'results'
name|'and'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
op|':'
newline|'\n'
comment|'# only report a meta file if a data file has been chosen'
nl|'\n'
indent|'            '
name|'results'
op|'['
string|"'meta_info'"
op|']'
op|'='
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'ctype_info'
op|'='
name|'exts'
op|'['
string|"'.meta'"
op|']'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
name|'ctype_info'
op|'['
string|"'ctype_timestamp'"
op|']'
nl|'\n'
op|'>'
name|'results'
op|'['
string|"'data_info'"
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'results'
op|'['
string|"'ctype_info'"
op|']'
op|'='
name|'ctype_info'
newline|'\n'
nl|'\n'
comment|'# set ts_file, data_file, meta_file and ctype_file with path to'
nl|'\n'
comment|'# chosen file or None'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'info_key'
name|'in'
op|'('
string|"'data_info'"
op|','
string|"'meta_info'"
op|','
string|"'ts_info'"
op|','
string|"'ctype_info'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'results'
op|'.'
name|'get'
op|'('
name|'info_key'
op|')'
newline|'\n'
name|'key'
op|'='
name|'info_key'
op|'['
op|':'
op|'-'
number|'5'
op|']'
op|'+'
string|"'_file'"
newline|'\n'
name|'results'
op|'['
name|'key'
op|']'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'info'
op|'['
string|"'filename'"
op|']'
op|')'
name|'if'
name|'info'
name|'else'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'verify'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'self'
op|'.'
name|'_verify_ondisk_files'
op|'('
nl|'\n'
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
op|','
string|'"On-disk file search algorithm contract is broken: %s"'
op|'%'
name|'str'
op|'('
name|'results'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'results'
newline|'\n'
nl|'\n'
DECL|member|cleanup_ondisk_files
dedent|''
name|'def'
name|'cleanup_ondisk_files'
op|'('
name|'self'
op|','
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Clean up on-disk files that are obsolete and gather the set of valid\n        on-disk files for an object.\n\n        :param hsh_path: object hash path\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :param frag_index: if set, search for a specific fragment index .data\n                           file, otherwise accept the first valid .data file\n        :returns: a dict that may contain: valid on disk files keyed by their\n                  filename extension; a list of obsolete files stored under the\n                  key \'obsolete\'; a list of files remaining in the directory,\n                  reverse sorted, stored under the key \'files\'.\n        """'
newline|'\n'
DECL|function|is_reclaimable
name|'def'
name|'is_reclaimable'
op|'('
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'float'
op|'('
name|'timestamp'
op|')'
op|')'
op|'>'
name|'reclaim_age'
newline|'\n'
nl|'\n'
dedent|''
name|'files'
op|'='
name|'listdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'results'
op|'='
name|'self'
op|'.'
name|'get_ondisk_files'
op|'('
nl|'\n'
name|'files'
op|','
name|'hsh_path'
op|','
name|'verify'
op|'='
name|'False'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'if'
string|"'ts_info'"
name|'in'
name|'results'
name|'and'
name|'is_reclaimable'
op|'('
nl|'\n'
name|'results'
op|'['
string|"'ts_info'"
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'results'
op|'['
string|"'ts_info'"
op|']'
op|'['
string|"'filename'"
op|']'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'results'
op|'.'
name|'pop'
op|'('
string|"'ts_info'"
op|')'
op|'['
string|"'filename'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'file_info'
name|'in'
name|'results'
op|'.'
name|'get'
op|'('
string|"'possible_reclaim'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
comment|'# stray files are not deleted until reclaim-age'
nl|'\n'
indent|'            '
name|'if'
name|'is_reclaimable'
op|'('
name|'file_info'
op|'['
string|"'timestamp'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'file_info'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'file_info'
name|'in'
name|'results'
op|'.'
name|'get'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'file_info'
op|'['
string|"'filename'"
op|']'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'file_info'
op|'['
string|"'filename'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'results'
op|'['
string|"'files'"
op|']'
op|'='
name|'files'
newline|'\n'
name|'return'
name|'results'
newline|'\n'
nl|'\n'
DECL|member|_update_suffix_hashes
dedent|''
name|'def'
name|'_update_suffix_hashes'
op|'('
name|'self'
op|','
name|'hashes'
op|','
name|'ondisk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Applies policy specific updates to the given dict of md5 hashes for\n        the given ondisk_info.\n\n        :param hashes: a dict of md5 hashes to be updated\n        :param ondisk_info: a dict describing the state of ondisk files, as\n                            returned by get_ondisk_files\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|_hash_suffix_dir
dedent|''
name|'def'
name|'_hash_suffix_dir'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n\n        :param path: full path to directory\n        :param reclaim_age: age in seconds at which to remove tombstones\n        """'
newline|'\n'
name|'hashes'
op|'='
name|'defaultdict'
op|'('
name|'hashlib'
op|'.'
name|'md5'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'path_contents'
op|'='
name|'sorted'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOTDIR'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'path_contents'
op|':'
newline|'\n'
indent|'            '
name|'hsh_path'
op|'='
name|'join'
op|'('
name|'path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'ondisk_info'
op|'='
name|'self'
op|'.'
name|'cleanup_ondisk_files'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                    '
name|'partition_path'
op|'='
name|'dirname'
op|'('
name|'path'
op|')'
newline|'\n'
name|'objects_path'
op|'='
name|'dirname'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'device_path'
op|'='
name|'dirname'
op|'('
name|'objects_path'
op|')'
newline|'\n'
name|'quar_path'
op|'='
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'hsh_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(hsh_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'hsh_path'"
op|':'
name|'hsh_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'ondisk_info'
op|'['
string|"'files'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
nl|'\n'
comment|'# ondisk_info has info dicts containing timestamps for those'
nl|'\n'
comment|'# files that could determine the state of the diskfile if it were'
nl|'\n'
comment|'# to be opened. We update the suffix hash with the concatenation of'
nl|'\n'
comment|"# each file's timestamp and extension. The extension is added to"
nl|'\n'
comment|'# guarantee distinct hash values from two object dirs that have'
nl|'\n'
comment|'# different file types at the same timestamp(s).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Files that may be in the object dir but would have no effect on'
nl|'\n'
comment|'# the state of the diskfile are not used to update the hash.'
nl|'\n'
dedent|''
name|'for'
name|'key'
name|'in'
op|'('
name|'k'
name|'for'
name|'k'
name|'in'
op|'('
string|"'meta_info'"
op|','
string|"'ts_info'"
op|')'
nl|'\n'
name|'if'
name|'k'
name|'in'
name|'ondisk_info'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'info'
op|'='
name|'ondisk_info'
op|'['
name|'key'
op|']'
newline|'\n'
name|'hashes'
op|'['
name|'None'
op|']'
op|'.'
name|'update'
op|'('
name|'info'
op|'['
string|"'timestamp'"
op|']'
op|'.'
name|'internal'
op|'+'
name|'info'
op|'['
string|"'ext'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# delegate to subclass for data file related updates...'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_update_suffix_hashes'
op|'('
name|'hashes'
op|','
name|'ondisk_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'ctype_info'"
name|'in'
name|'ondisk_info'
op|':'
newline|'\n'
comment|'# We have a distinct content-type timestamp so update the'
nl|'\n'
comment|"# hash. As a precaution, append '_ctype' to differentiate this"
nl|'\n'
comment|'# value from any other timestamp value that might included in'
nl|'\n'
comment|'# the hash in future. There is no .ctype file so use _ctype to'
nl|'\n'
comment|'# avoid any confusion.'
nl|'\n'
indent|'                '
name|'info'
op|'='
name|'ondisk_info'
op|'['
string|"'ctype_info'"
op|']'
newline|'\n'
name|'hashes'
op|'['
name|'None'
op|']'
op|'.'
name|'update'
op|'('
name|'info'
op|'['
string|"'ctype_timestamp'"
op|']'
op|'.'
name|'internal'
nl|'\n'
op|'+'
string|"'_ctype'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# if we remove it, pretend like it wasn't there to begin with so"
nl|'\n'
comment|'# that the suffix key gets removed'
nl|'\n'
indent|'            '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'hashes'
newline|'\n'
nl|'\n'
DECL|member|_hash_suffix
dedent|''
name|'def'
name|'_hash_suffix'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Performs reclamation and returns an md5 of all (remaining) files.\n\n        :param path: full path to directory\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :raises PathNotDir: if given path is not a valid directory\n        :raises OSError: for non-ENOTDIR errors\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|_get_hashes
dedent|''
name|'def'
name|'_get_hashes'
op|'('
name|'self'
op|','
name|'partition_path'
op|','
name|'recalculate'
op|'='
name|'None'
op|','
name|'do_listdir'
op|'='
name|'False'
op|','
nl|'\n'
name|'reclaim_age'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get a list of hashes for the suffix dir.  do_listdir causes it to\n        mistrust the hash cache for suffix existence at the (unexpectedly high)\n        cost of a listdir.  reclaim_age is just passed on to hash_suffix.\n\n        :param partition_path: absolute path of partition to get hashes for\n        :param recalculate: list of suffixes which should be recalculated when\n                            got\n        :param do_listdir: force existence check for all hashes in the\n                           partition\n        :param reclaim_age: age at which to remove tombstones\n\n        :returns: tuple of (number of suffix dirs hashed, dictionary of hashes)\n        """'
newline|'\n'
name|'reclaim_age'
op|'='
name|'reclaim_age'
name|'or'
name|'self'
op|'.'
name|'reclaim_age'
newline|'\n'
name|'hashed'
op|'='
number|'0'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_path'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'modified'
op|'='
name|'False'
newline|'\n'
name|'force_rewrite'
op|'='
name|'False'
newline|'\n'
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'mtime'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'recalculate'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'recalculate'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mtime'
op|'='
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'hashes'
op|'='
name|'self'
op|'.'
name|'consolidate_hashes'
op|'('
name|'partition_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'do_listdir'
op|'='
name|'True'
newline|'\n'
name|'force_rewrite'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hashes'
name|'is'
name|'None'
op|':'
comment|"# no hashes.pkl file; let's build it"
newline|'\n'
indent|'                '
name|'do_listdir'
op|'='
name|'True'
newline|'\n'
name|'force_rewrite'
op|'='
name|'True'
newline|'\n'
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'do_listdir'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'suff'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'suff'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                    '
name|'hashes'
op|'.'
name|'setdefault'
op|'('
name|'suff'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'hashes'
op|'.'
name|'update'
op|'('
op|'('
name|'suffix'
op|','
name|'None'
op|')'
name|'for'
name|'suffix'
name|'in'
name|'recalculate'
op|')'
newline|'\n'
name|'for'
name|'suffix'
op|','
name|'hash_'
name|'in'
name|'hashes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'hash_'
op|':'
newline|'\n'
indent|'                '
name|'suffix_dir'
op|'='
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'self'
op|'.'
name|'_hash_suffix'
op|'('
name|'suffix_dir'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'hashed'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'PathNotDir'
op|':'
newline|'\n'
indent|'                    '
name|'del'
name|'hashes'
op|'['
name|'suffix'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Error hashing suffix'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'modified'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'lock_path'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'force_rewrite'
name|'or'
name|'not'
name|'exists'
op|'('
name|'hashes_file'
op|')'
name|'or'
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
op|'=='
name|'mtime'
op|':'
newline|'\n'
indent|'                    '
name|'write_pickle'
op|'('
nl|'\n'
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_path'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_get_hashes'
op|'('
name|'partition_path'
op|','
name|'recalculate'
op|','
name|'do_listdir'
op|','
nl|'\n'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
nl|'\n'
DECL|member|construct_dev_path
dedent|''
dedent|''
name|'def'
name|'construct_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Construct the path to a device without checking if it is mounted.\n\n        :param device: name of target device\n        :returns: full path to the device\n        """'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_dev_path
dedent|''
name|'def'
name|'get_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'mount_check'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the path to a device, first checking to see if either it\n        is a proper mount point, or at least a directory depending on\n        the mount_check configuration option.\n\n        :param device: name of target device\n        :param mount_check: whether or not to check mountedness of device.\n                            Defaults to bool(self.mount_check).\n        :returns: full path to the device, None if the path to the device is\n                  not a proper mount point or directory.\n        """'
newline|'\n'
comment|"# we'll do some kind of check unless explicitly forbidden"
nl|'\n'
name|'if'
name|'mount_check'
name|'is'
name|'not'
name|'False'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mount_check'
name|'or'
name|'self'
op|'.'
name|'mount_check'
op|':'
newline|'\n'
indent|'                '
name|'check'
op|'='
name|'check_mount'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'check'
op|'='
name|'check_dir'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'check'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|replication_lock
name|'def'
name|'replication_lock'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A context manager that will lock on the device given, if\n        configured to do so.\n\n        :param device: name of target device\n        :raises ReplicationLockTimeout: If the lock on the device\n            cannot be granted within the configured timeout.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'replication_one_per_device'
op|':'
newline|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'with'
name|'lock_path'
op|'('
nl|'\n'
name|'dev_path'
op|','
nl|'\n'
name|'timeout'
op|'='
name|'self'
op|'.'
name|'replication_lock_timeout'
op|','
nl|'\n'
name|'timeout_class'
op|'='
name|'ReplicationLockTimeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|pickle_async_update
dedent|''
dedent|''
name|'def'
name|'pickle_async_update'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
name|'data'
op|','
nl|'\n'
name|'timestamp'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write data describing a container update notification to a pickle file\n        in the async_pending directory.\n\n        :param device: name of target device\n        :param account: account name for the object\n        :param container: container name for the object\n        :param obj: object name for the object\n        :param data: update data to be written to pickle file\n        :param timestamp: a Timestamp\n        :param policy: the StoragePolicy instance\n        """'
newline|'\n'
name|'device_path'
op|'='
name|'self'
op|'.'
name|'construct_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'async_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_async_dir'
op|'('
name|'policy'
op|')'
op|')'
newline|'\n'
name|'ohash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'write_pickle'
op|','
nl|'\n'
name|'data'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'async_dir'
op|','
name|'ohash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
name|'ohash'
op|'+'
string|"'-'"
op|'+'
nl|'\n'
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
op|'.'
name|'internal'
op|')'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'async_pendings'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile
dedent|''
name|'def'
name|'get_diskfile'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a BaseDiskFile instance for an object based on the object\'s\n        partition, path parts and policy.\n\n        :param device: name of target device\n        :param partition: partition on device in which the object lives\n        :param account: account name for the object\n        :param container: container name for the object\n        :param obj: object name for the object\n        :param policy: the StoragePolicy instance\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|','
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'use_splice'
op|','
nl|'\n'
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'pipe_size'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|object_audit_location_generator
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'self'
op|','
name|'device_dirs'
op|'='
name|'None'
op|','
nl|'\n'
name|'auditor_type'
op|'='
string|'"ALL"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yield an AuditLocation for all objects stored under device_dirs.\n\n        :param device_dirs: directory of target device\n        :param auditor_type: either ALL or ZBF\n        """'
newline|'\n'
name|'return'
name|'object_audit_location_generator'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'self'
op|'.'
name|'mount_check'
op|','
nl|'\n'
name|'self'
op|'.'
name|'logger'
op|','
name|'device_dirs'
op|','
nl|'\n'
name|'auditor_type'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_audit_location
dedent|''
name|'def'
name|'get_diskfile_from_audit_location'
op|'('
name|'self'
op|','
name|'audit_location'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a BaseDiskFile instance for an object at the given\n        AuditLocation.\n\n        :param audit_location: object location to be audited\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'audit_location'
op|'.'
name|'device'
op|','
name|'mount_check'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'.'
name|'from_hash_dir'
op|'('
nl|'\n'
name|'self'
op|','
name|'audit_location'
op|'.'
name|'path'
op|','
name|'dev_path'
op|','
nl|'\n'
name|'audit_location'
op|'.'
name|'partition'
op|','
name|'policy'
op|'='
name|'audit_location'
op|'.'
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_hash
dedent|''
name|'def'
name|'get_diskfile_from_hash'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'object_hash'
op|','
nl|'\n'
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a DiskFile instance for an object at the given\n        object_hash. Just in case someone thinks of refactoring, be\n        sure DiskFileDeleted is *not* raised, but the DiskFile\n        instance representing the tombstoned object is returned\n        instead.\n\n        :param device: name of target device\n        :param partition: partition on the device in which the object lives\n        :param object_hash: the hash of an object path\n        :param policy: the StoragePolicy instance\n        :raises DiskFileNotExist: if the object does not exist\n        :returns: an instance of BaseDiskFile\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
name|'str'
op|'('
name|'partition'
op|')'
op|','
name|'object_hash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
nl|'\n'
name|'object_hash'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'filenames'
op|'='
name|'self'
op|'.'
name|'cleanup_ondisk_files'
op|'('
name|'object_path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'reclaim_age'
op|')'
op|'['
string|"'files'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                '
name|'quar_path'
op|'='
name|'self'
op|'.'
name|'quarantine_renamer'
op|'('
name|'dev_path'
op|','
name|'object_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(object_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'object_path'"
op|':'
name|'object_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'filenames'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'='
name|'read_metadata'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'object_path'
op|','
name|'filenames'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'EOFError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'split_path'
op|'('
nl|'\n'
name|'metadata'
op|'.'
name|'get'
op|'('
string|"'name'"
op|','
string|"''"
op|')'
op|','
number|'3'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hashes
dedent|''
name|'def'
name|'get_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'suffixes'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n\n        :param device: name of target device\n        :param partition: partition name\n        :param suffixes: a list of suffix directories to be recalculated\n        :param policy: the StoragePolicy instance\n        :returns: a dictionary that maps suffix directories\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'partition_path'
op|')'
newline|'\n'
dedent|''
name|'_junk'
op|','
name|'hashes'
op|'='
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_hashes'
op|','
name|'partition_path'
op|','
name|'recalculate'
op|'='
name|'suffixes'
op|')'
newline|'\n'
name|'return'
name|'hashes'
newline|'\n'
nl|'\n'
DECL|member|_listdir
dedent|''
name|'def'
name|'_listdir'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        :param path: full path to directory\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
nl|'\n'
string|"'ERROR: Skipping %r due to error with listdir attempt: %s'"
op|','
nl|'\n'
name|'path'
op|','
name|'err'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|yield_suffixes
dedent|''
name|'def'
name|'yield_suffixes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, suffix_only) for suffixes stored\n        on the given device and partition.\n\n        :param device: name of target device\n        :param partition: partition name\n        :param policy: the StoragePolicy instance\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'for'
name|'suffix'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'suffix'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'int'
op|'('
name|'suffix'
op|','
number|'16'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|member|yield_hashes
dedent|''
dedent|''
name|'def'
name|'yield_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|','
nl|'\n'
name|'suffixes'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, hash_only, timestamps) for object\n        information stored for the given device, partition, and\n        (optionally) suffixes. If suffixes is None, all stored\n        suffixes will be searched for object hashes. Note that if\n        suffixes is not None but empty, such as [], then nothing will\n        be yielded.\n\n        timestamps is a dict which may contain items mapping:\n\n        - ts_data -> timestamp of data or tombstone file,\n        - ts_meta -> timestamp of meta file, if one exists\n        - ts_ctype -> timestamp of meta file containing most recent\n                      content-type value, if one exists\n\n        where timestamps are instances of\n        :class:`~swift.common.utils.Timestamp`\n\n        :param device: name of target device\n        :param partition: partition name\n        :param policy: the StoragePolicy instance\n        :param suffixes: optional list of suffix directories to be searched\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffixes'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'suffixes'
op|'='
name|'self'
op|'.'
name|'yield_suffixes'
op|'('
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'str'
op|'('
name|'partition'
op|')'
op|')'
newline|'\n'
name|'suffixes'
op|'='
op|'('
nl|'\n'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
nl|'\n'
name|'for'
name|'suffix'
name|'in'
name|'suffixes'
op|')'
newline|'\n'
dedent|''
name|'key_preference'
op|'='
op|'('
nl|'\n'
op|'('
string|"'ts_meta'"
op|','
string|"'meta_info'"
op|','
string|"'timestamp'"
op|')'
op|','
nl|'\n'
op|'('
string|"'ts_data'"
op|','
string|"'data_info'"
op|','
string|"'timestamp'"
op|')'
op|','
nl|'\n'
op|'('
string|"'ts_data'"
op|','
string|"'ts_info'"
op|','
string|"'timestamp'"
op|')'
op|','
nl|'\n'
op|'('
string|"'ts_ctype'"
op|','
string|"'ctype_info'"
op|','
string|"'ctype_timestamp'"
op|')'
op|','
nl|'\n'
op|')'
newline|'\n'
name|'for'
name|'suffix_path'
op|','
name|'suffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'object_hash'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'suffix_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suffix_path'
op|','
name|'object_hash'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'results'
op|'='
name|'self'
op|'.'
name|'cleanup_ondisk_files'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'self'
op|'.'
name|'reclaim_age'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'timestamps'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'ts_key'
op|','
name|'info_key'
op|','
name|'info_ts_key'
name|'in'
name|'key_preference'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'info_key'
name|'not'
name|'in'
name|'results'
op|':'
newline|'\n'
indent|'                            '
name|'continue'
newline|'\n'
dedent|''
name|'timestamps'
op|'['
name|'ts_key'
op|']'
op|'='
name|'results'
op|'['
name|'info_key'
op|']'
op|'['
name|'info_ts_key'
op|']'
newline|'\n'
dedent|''
name|'if'
string|"'ts_data'"
name|'not'
name|'in'
name|'timestamps'
op|':'
newline|'\n'
comment|'# file sets that do not include a .data or .ts'
nl|'\n'
comment|'# file cannot be opened and therefore cannot'
nl|'\n'
comment|"# be ssync'd"
nl|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'object_path'
op|','
name|'object_hash'
op|','
name|'timestamps'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AssertionError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
string|"'Invalid file set in %s (%s)'"
op|'%'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|"'Invalid diskfile filename in %r (%s)'"
op|'%'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseDiskFileWriter
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'BaseDiskFileWriter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the write context for servicing PUT REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.create` method.\n\n    .. note::\n\n        It is the responsibility of the\n        :func:`swift.obj.diskfile.DiskFile.create` method context manager to\n        close the open file descriptor.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param name: name of object from REST API\n    :param datadir: on-disk directory object will end up in on\n                    :func:`swift.obj.diskfile.DiskFileWriter.put`\n    :param fd: open file descriptor of temporary file to receive data\n    :param tmppath: full path name of the opened file descriptor\n    :param bytes_per_sync: number bytes written between sync calls\n    :param threadpool: internal thread pool to use for disk operations\n    :param diskfile: the diskfile creating this DiskFileWriter instance\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
name|'bytes_per_sync'
op|','
name|'threadpool'
op|','
nl|'\n'
name|'diskfile'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'datadir'
newline|'\n'
name|'self'
op|'.'
name|'_fd'
op|'='
name|'fd'
newline|'\n'
name|'self'
op|'.'
name|'_tmppath'
op|'='
name|'tmppath'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'='
name|'diskfile'
newline|'\n'
nl|'\n'
comment|'# Internal attributes'
nl|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_extension'
op|'='
string|"'.data'"
newline|'\n'
name|'self'
op|'.'
name|'_put_succeeded'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'manager'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|put_succeeded
name|'def'
name|'put_succeeded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_put_succeeded'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a chunk of data to disk. All invocations of this method must\n        come before invoking the :func:\n\n        For this implementation, the data is written into a temporary file.\n\n        :param chunk: the chunk of data to write as a string object\n\n        :returns: the total number of bytes written to an object\n        """'
newline|'\n'
nl|'\n'
DECL|function|_write_entire_chunk
name|'def'
name|'_write_entire_chunk'
op|'('
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'chunk'
op|':'
newline|'\n'
indent|'                '
name|'written'
op|'='
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'chunk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'+='
name|'written'
newline|'\n'
name|'chunk'
op|'='
name|'chunk'
op|'['
name|'written'
op|':'
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
name|'_write_entire_chunk'
op|','
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
comment|'# For large files sync every 512MB (by default) written'
nl|'\n'
name|'diff'
op|'='
name|'self'
op|'.'
name|'_upload_size'
op|'-'
name|'self'
op|'.'
name|'_last_sync'
newline|'\n'
name|'if'
name|'diff'
op|'>='
name|'self'
op|'.'
name|'_bytes_per_sync'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
name|'fdatasync'
op|','
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'self'
op|'.'
name|'_last_sync'
op|','
name|'diff'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
DECL|member|_finalize_put
dedent|''
name|'def'
name|'_finalize_put'
op|'('
name|'self'
op|','
name|'metadata'
op|','
name|'target_path'
op|','
name|'cleanup'
op|')'
op|':'
newline|'\n'
comment|'# Write the metadata before calling fsync() so that both data and'
nl|'\n'
comment|'# metadata are flushed to disk.'
nl|'\n'
indent|'        '
name|'write_metadata'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'metadata'
op|')'
newline|'\n'
comment|'# We call fsync() before calling drop_cache() to lower the amount of'
nl|'\n'
comment|'# redundant work the drop cache code will perform on the pages (now'
nl|'\n'
comment|'# that after fsync the pages will be all clean).'
nl|'\n'
name|'fsync'
op|'('
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
comment|'# From the Department of the Redundancy Department, make sure we call'
nl|'\n'
comment|'# drop_cache() after fsync() to avoid redundant work (pages all'
nl|'\n'
comment|'# clean).'
nl|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
number|'0'
op|','
name|'self'
op|'.'
name|'_upload_size'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|')'
newline|'\n'
comment|'# After the rename completes, this object will be available for other'
nl|'\n'
comment|'# requests to reference.'
nl|'\n'
name|'renamer'
op|'('
name|'self'
op|'.'
name|'_tmppath'
op|','
name|'target_path'
op|')'
newline|'\n'
comment|'# If rename is successful, flag put as succeeded. This is done to avoid'
nl|'\n'
comment|'# unnecessary os.unlink() of tempfile later. As renamer() has'
nl|'\n'
comment|'# succeeded, the tempfile would no longer exist at its original path.'
nl|'\n'
name|'self'
op|'.'
name|'_put_succeeded'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'cleanup'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'cleanup_ondisk_files'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|'['
string|"'files'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Problem cleaning up %s'"
op|')'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_put
dedent|''
dedent|''
dedent|''
name|'def'
name|'_put'
op|'('
name|'self'
op|','
name|'metadata'
op|','
name|'cleanup'
op|'='
name|'True'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Helper method for subclasses.\n\n        For this implementation, this method is responsible for renaming the\n        temporary file to the final name and directory location.  This method\n        should be called after the final call to\n        :func:`swift.obj.diskfile.DiskFileWriter.write`.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        :param cleanup: a Boolean. If True then obsolete files will be removed\n                        from the object dir after the put completes, otherwise\n                        obsolete files are left in place.\n        """'
newline|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'metadata'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
newline|'\n'
name|'ctype_timestamp'
op|'='
name|'metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
newline|'\n'
name|'if'
name|'ctype_timestamp'
op|':'
newline|'\n'
indent|'            '
name|'ctype_timestamp'
op|'='
name|'Timestamp'
op|'('
name|'ctype_timestamp'
op|')'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'make_on_disk_filename'
op|'('
nl|'\n'
name|'timestamp'
op|','
name|'self'
op|'.'
name|'_extension'
op|','
name|'ctype_timestamp'
op|'='
name|'ctype_timestamp'
op|','
nl|'\n'
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
name|'metadata'
op|'['
string|"'name'"
op|']'
op|'='
name|'self'
op|'.'
name|'_name'
newline|'\n'
name|'target_path'
op|'='
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'filename'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_put'
op|','
name|'metadata'
op|','
name|'target_path'
op|','
name|'cleanup'
op|')'
newline|'\n'
nl|'\n'
DECL|member|put
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize writing the file on disk.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|commit
dedent|''
name|'def'
name|'commit'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform any operations necessary to mark the object as durable. For\n        replication policy type this is a no-op.\n\n        :param timestamp: object put timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseDiskFileReader
dedent|''
dedent|''
name|'class'
name|'BaseDiskFileReader'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the WSGI read context for servicing GET REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.reader` method.\n\n    .. note::\n\n        The quarantining behavior of this method is considered implementation\n        specific, and is not required of the API.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param fp: open file object pointer reference\n    :param data_file: on-disk data file name for the object\n    :param obj_size: verified on-disk size of the object\n    :param etag: expected metadata etag value for entire file\n    :param threadpool: thread pool to use for read operations\n    :param disk_chunk_size: size of reads from disk in bytes\n    :param keep_cache_size: maximum object size that will be kept in cache\n    :param device_path: on-disk device path, used when quarantining an obj\n    :param logger: logger caller wants this object to use\n    :param quarantine_hook: 1-arg callable called w/reason when quarantined\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    :param diskfile: the diskfile creating this DiskFileReader instance\n    :param keep_cache: should resulting reads be kept in the buffer cache\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'fp'
op|','
name|'data_file'
op|','
name|'obj_size'
op|','
name|'etag'
op|','
name|'threadpool'
op|','
nl|'\n'
name|'disk_chunk_size'
op|','
name|'keep_cache_size'
op|','
name|'device_path'
op|','
name|'logger'
op|','
nl|'\n'
name|'quarantine_hook'
op|','
name|'use_splice'
op|','
name|'pipe_size'
op|','
name|'diskfile'
op|','
nl|'\n'
name|'keep_cache'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_fp'
op|'='
name|'fp'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'data_file'
newline|'\n'
name|'self'
op|'.'
name|'_obj_size'
op|'='
name|'obj_size'
newline|'\n'
name|'self'
op|'.'
name|'_etag'
op|'='
name|'etag'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'='
name|'diskfile'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'='
name|'quarantine_hook'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'if'
name|'keep_cache'
op|':'
newline|'\n'
comment|'# Caller suggests we keep this in cache, only do it if the'
nl|'\n'
comment|"# object's size is less than the maximum."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'obj_size'
op|'<'
name|'keep_cache_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Internal Attributes'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'manager'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'tell'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'hashlib'
op|'.'
name|'md5'
op|'('
op|')'
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'read'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|')'
newline|'\n'
name|'if'
name|'chunk'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'update'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|can_zero_copy_send
dedent|''
dedent|''
dedent|''
name|'def'
name|'can_zero_copy_send'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_use_splice'
newline|'\n'
nl|'\n'
DECL|member|zero_copy_send
dedent|''
name|'def'
name|'zero_copy_send'
op|'('
name|'self'
op|','
name|'wsockfd'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Does some magic with splice() and tee() to move stuff from disk to\n        network without ever touching userspace.\n\n        :param wsockfd: file descriptor (integer) of the socket out which to\n                        send data\n        """'
newline|'\n'
comment|'# Note: if we ever add support for zero-copy ranged GET responses,'
nl|'\n'
comment|"# we'll have to make this conditional."
nl|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'rfd'
op|'='
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'client_rpipe'
op|','
name|'client_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'hash_rpipe'
op|','
name|'hash_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'md5_sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The actual amount allocated to the pipe may be rounded up to the'
nl|'\n'
comment|'# nearest multiple of the page size. If we have the memory allocated,'
nl|'\n'
comment|'# we may as well use it.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note: this will raise IOError on failure, so we don't bother"
nl|'\n'
comment|'# checking the return value.'
nl|'\n'
name|'pipe_size'
op|'='
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'client_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'self'
op|'.'
name|'_pipe_size'
op|')'
newline|'\n'
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'hash_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'pipe_size'
op|')'
newline|'\n'
nl|'\n'
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'True'
op|':'
newline|'\n'
comment|'# Read data from disk to pipe'
nl|'\n'
indent|'                '
op|'('
name|'bytes_in_pipe'
op|','
name|'_1'
op|','
name|'_2'
op|')'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'splice'
op|','
name|'rfd'
op|','
name|'None'
op|','
name|'client_wpipe'
op|','
name|'None'
op|','
name|'pipe_size'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_in_pipe'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'bytes_in_pipe'
newline|'\n'
nl|'\n'
comment|'# "Copy" data from pipe A to pipe B (really just some pointer'
nl|'\n'
comment|'# manipulation in the kernel, not actual copying).'
nl|'\n'
name|'bytes_copied'
op|'='
name|'tee'
op|'('
name|'client_rpipe'
op|','
name|'hash_wpipe'
op|','
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_copied'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
comment|'# We teed data between two pipes of equal size, and the'
nl|'\n'
comment|'# destination pipe was empty. If, somehow, the destination'
nl|'\n'
comment|'# pipe was full before all the data was teed, we should'
nl|'\n'
comment|"# fail here. If we don't raise an exception, then we will"
nl|'\n'
comment|'# have the incorrect MD5 hash once the object has been'
nl|'\n'
comment|'# sent out, causing a false-positive quarantine.'
nl|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"tee() failed: tried to move %d bytes, "'
nl|'\n'
string|'"but only moved %d"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'bytes_copied'
op|')'
op|')'
newline|'\n'
comment|'# Take the data and feed it into an in-kernel MD5 socket. The'
nl|'\n'
comment|'# MD5 socket hashes data that is written to it. Reading from'
nl|'\n'
comment|'# it yields the MD5 checksum of the written data.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note that we don't have to worry about splice() returning"
nl|'\n'
comment|"# None here (which happens on EWOULDBLOCK); we're splicing"
nl|'\n'
comment|'# $bytes_in_pipe bytes from a pipe with exactly that many'
nl|'\n'
comment|"# bytes in it, so read won't block, and we're splicing it into"
nl|'\n'
comment|'# an MD5 socket, which synchronously hashes any data sent to'
nl|'\n'
comment|"# it, so writing won't block either."
nl|'\n'
dedent|''
op|'('
name|'hashed'
op|','
name|'_1'
op|','
name|'_2'
op|')'
op|'='
name|'splice'
op|'('
name|'hash_rpipe'
op|','
name|'None'
op|','
name|'md5_sockfd'
op|','
name|'None'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
name|'splice'
op|'.'
name|'SPLICE_F_MORE'
op|')'
newline|'\n'
name|'if'
name|'hashed'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"md5 socket didn\'t take all the data? "'
nl|'\n'
string|'"(tried to write %d, but wrote %d)"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'hashed'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'bytes_in_pipe'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'res'
op|'='
name|'splice'
op|'('
name|'client_rpipe'
op|','
name|'None'
op|','
name|'wsockfd'
op|','
name|'None'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'bytes_in_pipe'
op|'-='
name|'res'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'exc'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EWOULDBLOCK'
op|':'
newline|'\n'
indent|'                            '
name|'trampoline'
op|'('
name|'wsockfd'
op|','
name|'write'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|"# Linux MD5 sockets return '00000000000000000000000000000000' for"
nl|'\n'
comment|"# the checksum if you didn't write any bytes to them, instead of"
nl|'\n'
comment|'# returning the correct value.'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'bin_checksum'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'md5_sockfd'
op|','
number|'16'
op|')'
newline|'\n'
name|'hex_checksum'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
string|'"%02x"'
op|'%'
name|'ord'
op|'('
name|'c'
op|')'
name|'for'
name|'c'
name|'in'
name|'bin_checksum'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'hex_checksum'
op|'='
name|'MD5_OF_EMPTY_STRING'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'hex_checksum'
newline|'\n'
nl|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'md5_sockfd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_range
dedent|''
dedent|''
name|'def'
name|'app_iter_range'
op|'('
name|'self'
op|','
name|'start'
op|','
name|'stop'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns an iterator over the data file for range (start, stop)\n\n        """'
newline|'\n'
name|'if'
name|'start'
name|'or'
name|'start'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'seek'
op|'('
name|'start'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stop'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'stop'
op|'-'
name|'start'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'chunk'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'length'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'length'
op|'-='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'length'
op|'<'
number|'0'
op|':'
newline|'\n'
comment|'# Chop off the extra:'
nl|'\n'
indent|'                        '
name|'yield'
name|'chunk'
op|'['
op|':'
name|'length'
op|']'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_ranges
dedent|''
dedent|''
dedent|''
name|'def'
name|'app_iter_ranges'
op|'('
name|'self'
op|','
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns an iterator over the data file for a set of ranges\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'ranges'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"''"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'True'
newline|'\n'
name|'for'
name|'chunk'
name|'in'
name|'multi_range_iterator'
op|'('
nl|'\n'
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app_iter_range'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_drop_cache
dedent|''
dedent|''
dedent|''
name|'def'
name|'_drop_cache'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Method for no-oping buffer cache drop method.\n\n        :param fd: file descriptor or filename\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_keep_cache'
op|':'
newline|'\n'
indent|'            '
name|'drop_buffer_cache'
op|'('
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warning'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handle_close_quarantine
dedent|''
name|'def'
name|'_handle_close_quarantine'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if file needs to be quarantined"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'!='
name|'self'
op|'.'
name|'_obj_size'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"Bytes read: %s, does not match metadata: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|','
name|'self'
op|'.'
name|'_obj_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
name|'and'
name|'self'
op|'.'
name|'_etag'
op|'!='
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"ETag %s and file\'s md5 %s do not match"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_etag'
op|','
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the open file handle if present.\n\n        For this specific implementation, this method will handle quarantining\n        the file if necessary.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_started_at_0'
name|'and'
name|'self'
op|'.'
name|'_read_to_eof'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_handle_close_quarantine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
nl|'\n'
string|"'ERROR DiskFile %(data_file)s'"
nl|'\n'
string|"' close failure: %(exc)s : %(stack)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'exc'"
op|':'
name|'e'
op|','
string|"'stack'"
op|':'
string|"''"
op|'.'
name|'join'
op|'('
name|'traceback'
op|'.'
name|'format_stack'
op|'('
op|')'
op|')'
op|','
nl|'\n'
string|"'data_file'"
op|':'
name|'self'
op|'.'
name|'_data_file'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseDiskFile
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'BaseDiskFile'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Manage object files.\n\n    This specific implementation manages object files on a disk formatted with\n    a POSIX-compliant file system that supports extended attributes as\n    metadata on a file or directory.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n        The following path format is used for data file locations:\n        <devices_path/<device_dir>/<datadir>/<partdir>/<suffixdir>/<hashdir>/\n        <datafile>.<ext>\n\n    :param mgr: associated DiskFileManager instance\n    :param device_path: path to the target device or drive\n    :param threadpool: thread pool to use for blocking operations\n    :param partition: partition on the device in which the object lives\n    :param account: account name for the object\n    :param container: container name for the object\n    :param obj: object name for the object\n    :param _datadir: override the full datadir otherwise constructed here\n    :param policy: the StoragePolicy instance\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    """'
newline|'\n'
DECL|variable|reader_cls
name|'reader_cls'
op|'='
name|'None'
comment|'# must be set by subclasses'
newline|'\n'
DECL|variable|writer_cls
name|'writer_cls'
op|'='
name|'None'
comment|'# must be set by subclasses'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'mgr'
op|','
name|'device_path'
op|','
name|'threadpool'
op|','
name|'partition'
op|','
nl|'\n'
name|'account'
op|'='
name|'None'
op|','
name|'container'
op|'='
name|'None'
op|','
name|'obj'
op|'='
name|'None'
op|','
name|'_datadir'
op|'='
name|'None'
op|','
nl|'\n'
name|'policy'
op|'='
name|'None'
op|','
name|'use_splice'
op|'='
name|'False'
op|','
name|'pipe_size'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_manager'
op|'='
name|'mgr'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
name|'or'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'mgr'
op|'.'
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'mgr'
op|'.'
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'mgr'
op|'.'
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'self'
op|'.'
name|'policy'
op|'='
name|'policy'
newline|'\n'
name|'if'
name|'account'
name|'and'
name|'container'
name|'and'
name|'obj'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'account'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'container'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'obj'
newline|'\n'
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# gets populated when we read the metadata'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tmpdir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_ondisk_info'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_datafile_metadata'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_metafile_metadata'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'_datadir'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'_datadir'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_manager'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|account
name|'def'
name|'account'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_account'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|container
name|'def'
name|'container'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_container'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|obj
name|'def'
name|'obj'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_obj'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|content_length
name|'def'
name|'content_length'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_content_length'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|timestamp
name|'def'
name|'timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Timestamp'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|data_timestamp
name|'def'
name|'data_timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_datafile_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Timestamp'
op|'('
name|'self'
op|'.'
name|'_datafile_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|durable_timestamp
name|'def'
name|'durable_timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provides the timestamp of the newest data file found in the object\n        directory.\n\n        :return: A Timestamp instance, or None if no data file was found.\n        :raises DiskFileNotOpen: if the open() method has not been previously\n                                 called on this instance.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_ondisk_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_datafile_metadata'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Timestamp'
op|'('
name|'self'
op|'.'
name|'_datafile_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|fragments
name|'def'
name|'fragments'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|content_type
name|'def'
name|'content_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|content_type_timestamp
name|'def'
name|'content_type_timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'t'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|','
nl|'\n'
name|'self'
op|'.'
name|'_datafile_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'Timestamp'
op|'('
name|'t'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_hash_dir
name|'def'
name|'from_hash_dir'
op|'('
name|'cls'
op|','
name|'mgr'
op|','
name|'hash_dir_path'
op|','
name|'device_path'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cls'
op|'('
name|'mgr'
op|','
name|'device_path'
op|','
name|'None'
op|','
name|'partition'
op|','
name|'_datadir'
op|'='
name|'hash_dir_path'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|open
dedent|''
name|'def'
name|'open'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the object.\n\n        This implementation opens the data file representing the object, reads\n        the associated metadata in the extended attributes, additionally\n        combining metadata from fast-POST `.meta` files.\n\n        .. note::\n\n            An implementation is allowed to raise any of the following\n            exceptions, but is only required to raise `DiskFileNotExist` when\n            the object representation does not exist.\n\n        :raises DiskFileCollision: on name mis-match with metadata\n        :raises DiskFileNotExist: if the object does not exist\n        :raises DiskFileDeleted: if the object was previously deleted\n        :raises DiskFileQuarantined: if while reading metadata of the file\n                                     some data did pass cross checks\n        :returns: itself for use as a context manager\n        """'
newline|'\n'
comment|'# First figure out if the data directory exists'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
comment|"# If there's a file here instead of a directory, quarantine"
nl|'\n'
comment|"# it; something's gone wrong somewhere."
nl|'\n'
indent|'                '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
comment|'# hack: quarantine_renamer actually renames the directory'
nl|'\n'
comment|'# enclosing the filename you give it, but here we just'
nl|'\n'
comment|'# want this one file and not its parent.'
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
string|'"made-up-filename"'
op|')'
op|','
nl|'\n'
string|'"Expected directory, found file at %s"'
op|'%'
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|'"Error listing directory %s: %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
comment|'# The data directory does not exist, so the object cannot exist.'
nl|'\n'
dedent|''
name|'files'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# gather info about the valid files to use to open the DiskFile'
nl|'\n'
dedent|''
name|'file_info'
op|'='
name|'self'
op|'.'
name|'_get_ondisk_files'
op|'('
name|'files'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'file_info'
op|'.'
name|'get'
op|'('
string|"'data_file'"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_data_file'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_construct_exception_from_ts_file'
op|'('
op|'**'
name|'file_info'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_construct_from_data_file'
op|'('
op|'**'
name|'file_info'
op|')'
newline|'\n'
comment|'# This method must populate the internal _metadata attribute.'
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context enter.\n\n        .. note::\n\n            An implementation shall raise `DiskFileNotOpen` when has not\n            previously invoked the :func:`swift.obj.diskfile.DiskFile.open`\n            method.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'t'
op|','
name|'v'
op|','
name|'tb'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context exit.\n\n        .. note::\n\n            This method will be invoked by the object server while servicing\n            the REST API *before* the object has actually been read. It is the\n            responsibility of the implementation to properly handle that.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Quarantine a file; responsible for incrementing the associated logger\'s\n        count of quarantines.\n\n        :param data_file: full path of data file to quarantine\n        :param msg: reason for quarantining to be included in the exception\n        :returns: DiskFileQuarantined exception object\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warning'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'return'
name|'DiskFileQuarantined'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_files
dedent|''
name|'def'
name|'_get_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Determine the on-disk files to use.\n\n        :param files: a list of files in the object\'s dir\n        :returns: dict of files to use having keys \'data_file\', \'ts_file\',\n                 \'meta_file\'\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|_construct_exception_from_ts_file
dedent|''
name|'def'
name|'_construct_exception_from_ts_file'
op|'('
name|'self'
op|','
name|'ts_file'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a tombstone is present it means the object is considered\n        deleted. We just need to pull the metadata from the tombstone file\n        which has the timestamp to construct the deleted exception. If there\n        was no tombstone, just report it does not exist.\n\n        :param ts_file: the tombstone file name found on disk\n        :returns: DiskFileDeleted if the ts_file was provided, else\n                  DiskFileNotExist\n        """'
newline|'\n'
name|'if'
name|'not'
name|'ts_file'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'ts_file'
op|','
name|'ts_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
comment|"# If the tombstone's corrupted, quarantine it and pretend it"
nl|'\n'
comment|"# wasn't there"
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# All well and good that we have found a tombstone file, but'
nl|'\n'
comment|"# we don't have a data file so we are just going to raise an"
nl|'\n'
comment|'# exception that we could not find the object, providing the'
nl|'\n'
comment|"# tombstone's timestamp."
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileDeleted'
op|'('
name|'metadata'
op|'='
name|'metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'exc'
newline|'\n'
nl|'\n'
DECL|member|_verify_name_matches_hash
dedent|''
name|'def'
name|'_verify_name_matches_hash'
op|'('
name|'self'
op|','
name|'data_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n\n        :param data_file: data file name, used when quarantines occur\n        """'
newline|'\n'
name|'hash_from_fs'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
name|'hash_from_name'
op|'='
name|'hash_path'
op|'('
name|'self'
op|'.'
name|'_name'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'hash_from_fs'
op|'!='
name|'hash_from_name'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
nl|'\n'
string|'"Hash of name in metadata does not match directory name"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_verify_data_file
dedent|''
dedent|''
name|'def'
name|'_verify_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'fp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify the metadata\'s name value matches what we think the object is\n        named.\n\n        :param data_file: data file name being consider, used when quarantines\n                          occur\n        :param fp: open file pointer so that we can `fstat()` the file to\n                   verify the on-disk size with Content-Length metadata value\n        :raises DiskFileCollision: if the metadata stored name does not match\n                                   the referenced name of the file\n        :raises DiskFileExpired: if the object has expired\n        :raises DiskFileQuarantined: if data inconsistencies were detected\n                                     between the metadata and the file-system\n                                     metadata\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mname'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"missing name metadata"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mname'
op|'!='
name|'self'
op|'.'
name|'_name'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client path %(client)s does not match '"
nl|'\n'
string|"'path stored in object metadata %(meta)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'client'"
op|':'
name|'self'
op|'.'
name|'_name'
op|','
string|"'meta'"
op|':'
name|'mname'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileCollision'
op|'('
string|"'Client path does not match path '"
nl|'\n'
string|"'stored in object metadata'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'x_delete_at'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the x-delete-at key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata x-delete-at value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'x_delete_at'
op|'<='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileExpired'
op|'('
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata_size'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"missing content-length in metadata"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the content-length key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata content-length value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'fd'
op|'='
name|'fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'statbuf'
op|'='
name|'os'
op|'.'
name|'fstat'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|"# Quarantine, we can't successfully stat the file."
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"not stat-able: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'obj_size'
op|'='
name|'statbuf'
op|'.'
name|'st_size'
newline|'\n'
dedent|''
name|'if'
name|'obj_size'
op|'!='
name|'metadata_size'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"metadata content-length %s does"'
nl|'\n'
string|'" not match actual object size %s"'
op|'%'
op|'('
nl|'\n'
name|'metadata_size'
op|','
name|'statbuf'
op|'.'
name|'st_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'obj_size'
newline|'\n'
name|'return'
name|'obj_size'
newline|'\n'
nl|'\n'
DECL|member|_failsafe_read_metadata
dedent|''
name|'def'
name|'_failsafe_read_metadata'
op|'('
name|'self'
op|','
name|'source'
op|','
name|'quarantine_filename'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read metadata from source object file. In case of failure, quarantine\n        the file.\n\n        Takes source and filename separately so we can read from an open\n        file if we have one.\n\n        :param source: file descriptor or filename to load the metadata from\n        :param quarantine_filename: full path of file to load the metadata from\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'read_metadata'
op|'('
name|'source'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'DiskFileXattrNotSupported'
op|','
name|'DiskFileNotExist'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'quarantine_filename'
op|','
nl|'\n'
string|'"Exception reading metadata: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_merge_content_type_metadata
dedent|''
dedent|''
name|'def'
name|'_merge_content_type_metadata'
op|'('
name|'self'
op|','
name|'ctype_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a second .meta file is providing the most recent Content-Type\n        metadata then merge it into the metafile_metadata.\n\n        :param ctype_file: An on-disk .meta file\n        """'
newline|'\n'
name|'ctypefile_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
nl|'\n'
name|'ctype_file'
op|','
name|'ctype_file'
op|')'
newline|'\n'
name|'if'
op|'('
string|"'Content-Type'"
name|'in'
name|'ctypefile_metadata'
nl|'\n'
name|'and'
op|'('
name|'ctypefile_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
op|'>'
nl|'\n'
name|'self'
op|'.'
name|'_metafile_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
op|')'
nl|'\n'
name|'and'
op|'('
name|'ctypefile_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
op|'>'
nl|'\n'
name|'self'
op|'.'
name|'data_timestamp'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metafile_metadata'
op|'['
string|"'Content-Type'"
op|']'
op|'='
name|'ctypefile_metadata'
op|'['
string|"'Content-Type'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_metafile_metadata'
op|'['
string|"'Content-Type-Timestamp'"
op|']'
op|'='
name|'ctypefile_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_construct_from_data_file
dedent|''
dedent|''
name|'def'
name|'_construct_from_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ctype_file'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the `.data` file to fetch its metadata, and fetch the metadata\n        from fast-POST `.meta` files as well if any exist, merging them\n        properly.\n\n        :param data_file: on-disk `.data` file being considered\n        :param meta_file: on-disk fast-POST `.meta` file being considered\n        :param ctype_file: on-disk fast-POST `.meta` file being considered that\n                           contains content-type and content-type timestamp\n        :returns: an opened data file pointer\n        :raises DiskFileError: various exceptions from\n                    :func:`swift.obj.diskfile.DiskFile._verify_data_file`\n        """'
newline|'\n'
name|'fp'
op|'='
name|'open'
op|'('
name|'data_file'
op|','
string|"'rb'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datafile_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'fp'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'meta_file'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metafile_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
nl|'\n'
name|'meta_file'
op|','
name|'meta_file'
op|')'
newline|'\n'
name|'if'
name|'ctype_file'
name|'and'
name|'ctype_file'
op|'!='
name|'meta_file'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_merge_content_type_metadata'
op|'('
name|'ctype_file'
op|')'
newline|'\n'
dedent|''
name|'sys_metadata'
op|'='
name|'dict'
op|'('
nl|'\n'
op|'['
op|'('
name|'key'
op|','
name|'val'
op|')'
name|'for'
name|'key'
op|','
name|'val'
name|'in'
name|'self'
op|'.'
name|'_datafile_metadata'
op|'.'
name|'items'
op|'('
op|')'
nl|'\n'
name|'if'
name|'key'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
name|'DATAFILE_SYSTEM_META'
nl|'\n'
name|'or'
name|'is_sys_meta'
op|'('
string|"'object'"
op|','
name|'key'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'_metafile_metadata'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'update'
op|'('
name|'sys_metadata'
op|')'
newline|'\n'
comment|"# diskfile writer added 'name' to metafile, so remove it here"
nl|'\n'
name|'self'
op|'.'
name|'_metafile_metadata'
op|'.'
name|'pop'
op|'('
string|"'name'"
op|','
name|'None'
op|')'
newline|'\n'
comment|'# TODO: the check for Content-Type is only here for tests that'
nl|'\n'
comment|'# create .data files without Content-Type'
nl|'\n'
name|'if'
op|'('
string|"'Content-Type'"
name|'in'
name|'self'
op|'.'
name|'_datafile_metadata'
name|'and'
nl|'\n'
op|'('
name|'self'
op|'.'
name|'data_timestamp'
op|'>'
nl|'\n'
name|'self'
op|'.'
name|'_metafile_metadata'
op|'.'
name|'get'
op|'('
string|"'Content-Type-Timestamp'"
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Type'"
op|']'
op|'='
name|'self'
op|'.'
name|'_datafile_metadata'
op|'['
string|"'Content-Type'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'pop'
op|'('
string|"'Content-Type-Timestamp'"
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'_datafile_metadata'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_name'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# If we don't know our name, we were just given a hash dir at"
nl|'\n'
comment|"# instantiation, so we'd better validate that the name hashes back"
nl|'\n'
comment|'# to us'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_verify_name_matches_hash'
op|'('
name|'data_file'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_verify_data_file'
op|'('
name|'data_file'
op|','
name|'fp'
op|')'
newline|'\n'
name|'return'
name|'fp'
newline|'\n'
nl|'\n'
DECL|member|get_metafile_metadata
dedent|''
name|'def'
name|'get_metafile_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provide the metafile metadata for a previously opened object as a\n        dictionary. This is metadata that was written by a POST and does not\n        include any persistent metadata that was set by the original PUT.\n\n        :returns: object\'s .meta file metadata dictionary, or None if there is\n                  no .meta file\n        :raises DiskFileNotOpen: if the\n            :func:`swift.obj.diskfile.DiskFile.open` method was not previously\n            invoked\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_metafile_metadata'
newline|'\n'
nl|'\n'
DECL|member|get_datafile_metadata
dedent|''
name|'def'
name|'get_datafile_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provide the datafile metadata for a previously opened object as a\n        dictionary. This is metadata that was included when the object was\n        first PUT, and does not include metadata set by any subsequent POST.\n\n        :returns: object\'s datafile metadata dictionary\n        :raises DiskFileNotOpen: if the\n            :func:`swift.obj.diskfile.DiskFile.open` method was not previously\n            invoked\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_datafile_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_datafile_metadata'
newline|'\n'
nl|'\n'
DECL|member|get_metadata
dedent|''
name|'def'
name|'get_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provide the metadata for a previously opened object as a dictionary.\n\n        :returns: object\'s metadata dictionary\n        :raises DiskFileNotOpen: if the\n            :func:`swift.obj.diskfile.DiskFile.open` method was not previously\n            invoked\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_metadata'
newline|'\n'
nl|'\n'
DECL|member|read_metadata
dedent|''
name|'def'
name|'read_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the metadata for an object without requiring the caller to open\n        the object first.\n\n        :returns: metadata dictionary for an object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `open()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'open'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'get_metadata'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|reader
dedent|''
dedent|''
name|'def'
name|'reader'
op|'('
name|'self'
op|','
name|'keep_cache'
op|'='
name|'False'
op|','
nl|'\n'
name|'_quarantine_hook'
op|'='
name|'lambda'
name|'m'
op|':'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a :class:`swift.common.swob.Response` class compatible\n        "`app_iter`" object as defined by\n        :class:`swift.obj.diskfile.DiskFileReader`.\n\n        For this implementation, the responsibility of closing the open file\n        is passed to the :class:`swift.obj.diskfile.DiskFileReader` object.\n\n        :param keep_cache: caller\'s preference for keeping data read in the\n                           OS buffer cache\n        :param _quarantine_hook: 1-arg callable called when obj quarantined;\n                                 the arg is the reason for quarantine.\n                                 Default is to ignore it.\n                                 Not needed by the REST layer.\n        :returns: a :class:`swift.obj.diskfile.DiskFileReader` object\n        """'
newline|'\n'
name|'dr'
op|'='
name|'self'
op|'.'
name|'reader_cls'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|','
name|'self'
op|'.'
name|'_data_file'
op|','
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'ETag'"
op|']'
op|','
name|'self'
op|'.'
name|'_threadpool'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_manager'
op|'.'
name|'keep_cache_size'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'self'
op|'.'
name|'_logger'
op|','
nl|'\n'
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'_use_splice'
op|','
name|'quarantine_hook'
op|'='
name|'_quarantine_hook'
op|','
nl|'\n'
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'_pipe_size'
op|','
name|'diskfile'
op|'='
name|'self'
op|','
name|'keep_cache'
op|'='
name|'keep_cache'
op|')'
newline|'\n'
comment|'# At this point the reader object is now responsible for closing'
nl|'\n'
comment|'# the file pointer.'
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'return'
name|'dr'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|create
name|'def'
name|'create'
op|'('
name|'self'
op|','
name|'size'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context manager to create a file. We create a temporary file first, and\n        then return a DiskFileWriter object to encapsulate the state.\n\n        .. note::\n\n            An implementation is not required to perform on-disk\n            preallocations even if the parameter is specified. But if it does\n            and it fails, it must raise a `DiskFileNoSpace` exception.\n\n        :param size: optional initial size of file to explicitly allocate on\n                     disk\n        :raises DiskFileNoSpace: if a size is specified and allocation fails\n        """'
newline|'\n'
name|'if'
name|'not'
name|'exists'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fd'
op|','
name|'tmppath'
op|'='
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
comment|'# No more inodes in filesystem'
nl|'\n'
indent|'                '
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'dfw'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'size'
name|'is'
name|'not'
name|'None'
name|'and'
name|'size'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'fallocate'
op|'('
name|'fd'
op|','
name|'size'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'dfw'
op|'='
name|'self'
op|'.'
name|'writer_cls'
op|'('
name|'self'
op|'.'
name|'_name'
op|','
name|'self'
op|'.'
name|'_datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
nl|'\n'
name|'bytes_per_sync'
op|'='
name|'self'
op|'.'
name|'_bytes_per_sync'
op|','
nl|'\n'
name|'threadpool'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|','
nl|'\n'
name|'diskfile'
op|'='
name|'self'
op|')'
newline|'\n'
name|'yield'
name|'dfw'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'dfw'
name|'is'
name|'None'
op|')'
name|'or'
op|'('
name|'not'
name|'dfw'
op|'.'
name|'put_succeeded'
op|')'
op|':'
newline|'\n'
comment|'# Try removing the temp file only if put did NOT succeed.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# dfw.put_succeeded is set to True after renamer() succeeds in'
nl|'\n'
comment|'# DiskFileWriter._finalize_put()'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmppath'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'exception'
op|'('
string|"'Error removing tempfile: %s'"
op|'%'
nl|'\n'
name|'tmppath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|write_metadata
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a block of metadata to an object without requiring the caller to\n        create the object first. Supports fast-POST behavior semantics.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'writer'
op|':'
newline|'\n'
indent|'            '
name|'writer'
op|'.'
name|'_extension'
op|'='
string|"'.meta'"
newline|'\n'
name|'writer'
op|'.'
name|'put'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete
dedent|''
dedent|''
name|'def'
name|'delete'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delete the object.\n\n        This implementation creates a tombstone file using the given\n        timestamp, and removes any older versions of the object file. Any\n        file that has an older timestamp than timestamp will be deleted.\n\n        .. note::\n\n            An implementation is free to use or ignore the timestamp\n            parameter.\n\n        :param timestamp: timestamp to compare with each file\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
comment|'# this is dumb, only tests send in strings'
nl|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'deleter'
op|':'
newline|'\n'
indent|'            '
name|'deleter'
op|'.'
name|'_extension'
op|'='
string|"'.ts'"
newline|'\n'
name|'deleter'
op|'.'
name|'put'
op|'('
op|'{'
string|"'X-Timestamp'"
op|':'
name|'timestamp'
op|'.'
name|'internal'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileReader
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFileReader'
op|'('
name|'BaseDiskFileReader'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileWriter
dedent|''
name|'class'
name|'DiskFileWriter'
op|'('
name|'BaseDiskFileWriter'
op|')'
op|':'
newline|'\n'
DECL|member|put
indent|'    '
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize writing the file on disk.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        """'
newline|'\n'
name|'super'
op|'('
name|'DiskFileWriter'
op|','
name|'self'
op|')'
op|'.'
name|'_put'
op|'('
name|'metadata'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFile
dedent|''
dedent|''
name|'class'
name|'DiskFile'
op|'('
name|'BaseDiskFile'
op|')'
op|':'
newline|'\n'
DECL|variable|reader_cls
indent|'    '
name|'reader_cls'
op|'='
name|'DiskFileReader'
newline|'\n'
DECL|variable|writer_cls
name|'writer_cls'
op|'='
name|'DiskFileWriter'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_files
name|'def'
name|'_get_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_ondisk_info'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'get_ondisk_files'
op|'('
name|'files'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_ondisk_info'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'DiskFileRouter'
op|'.'
name|'register'
op|'('
name|'REPL_POLICY'
op|')'
newline|'\n'
DECL|class|DiskFileManager
name|'class'
name|'DiskFileManager'
op|'('
name|'BaseDiskFileManager'
op|')'
op|':'
newline|'\n'
DECL|variable|diskfile_cls
indent|'    '
name|'diskfile_cls'
op|'='
name|'DiskFile'
newline|'\n'
nl|'\n'
DECL|member|_process_ondisk_files
name|'def'
name|'_process_ondisk_files'
op|'('
name|'self'
op|','
name|'exts'
op|','
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement replication policy specific handling of .data files.\n\n        :param exts: dict of lists of file info, keyed by extension\n        :param results: a dict that may be updated with results\n        """'
newline|'\n'
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'ext'
name|'in'
name|'exts'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|"# older .data's are obsolete"
nl|'\n'
indent|'                    '
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'obsolete'
op|'='
name|'self'
op|'.'
name|'_split_gte_timestamp'
op|'('
nl|'\n'
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'exts'
op|'['
string|"'.data'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# other files at same or older timestamp as most recent'
nl|'\n'
comment|'# data are obsolete'
nl|'\n'
indent|'                    '
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'obsolete'
op|'='
name|'self'
op|'.'
name|'_split_gt_timestamp'
op|'('
nl|'\n'
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'exts'
op|'['
string|"'.data'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'obsolete'
op|')'
newline|'\n'
nl|'\n'
comment|'# set results'
nl|'\n'
dedent|''
name|'results'
op|'['
string|"'data_info'"
op|']'
op|'='
name|'exts'
op|'['
string|"'.data'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# .meta files *may* be ready for reclaim if there is no data'
nl|'\n'
dedent|''
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
name|'and'
name|'not'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'possible_reclaim'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
nl|'\n'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_update_suffix_hashes
dedent|''
dedent|''
name|'def'
name|'_update_suffix_hashes'
op|'('
name|'self'
op|','
name|'hashes'
op|','
name|'ondisk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Applies policy specific updates to the given dict of md5 hashes for\n        the given ondisk_info.\n\n        :param hashes: a dict of md5 hashes to be updated\n        :param ondisk_info: a dict describing the state of ondisk files, as\n                            returned by get_ondisk_files\n        """'
newline|'\n'
name|'if'
string|"'data_info'"
name|'in'
name|'ondisk_info'
op|':'
newline|'\n'
indent|'            '
name|'file_info'
op|'='
name|'ondisk_info'
op|'['
string|"'data_info'"
op|']'
newline|'\n'
name|'hashes'
op|'['
name|'None'
op|']'
op|'.'
name|'update'
op|'('
nl|'\n'
name|'file_info'
op|'['
string|"'timestamp'"
op|']'
op|'.'
name|'internal'
op|'+'
name|'file_info'
op|'['
string|"'ext'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_hash_suffix
dedent|''
dedent|''
name|'def'
name|'_hash_suffix'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Performs reclamation and returns an md5 of all (remaining) files.\n\n        :param path: full path to directory\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :raises PathNotDir: if given path is not a valid directory\n        :raises OSError: for non-ENOTDIR errors\n        :returns: md5 of files in suffix\n        """'
newline|'\n'
name|'hashes'
op|'='
name|'self'
op|'.'
name|'_hash_suffix_dir'
op|'('
name|'path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'return'
name|'hashes'
op|'['
name|'None'
op|']'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFileReader
dedent|''
dedent|''
name|'class'
name|'ECDiskFileReader'
op|'('
name|'BaseDiskFileReader'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFileWriter
dedent|''
name|'class'
name|'ECDiskFileWriter'
op|'('
name|'BaseDiskFileWriter'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|_finalize_durable
indent|'    '
name|'def'
name|'_finalize_durable'
op|'('
name|'self'
op|','
name|'durable_file_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exc'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'open'
op|'('
name|'durable_file_path'
op|','
string|"'w'"
op|')'
name|'as'
name|'_fp'
op|':'
newline|'\n'
indent|'                    '
name|'fsync'
op|'('
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'fsync_dir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'not'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
comment|'# re-raise to catch all handler'
nl|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'No space left on device for %(file)s (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'file'"
op|':'
name|'durable_file_path'
op|','
string|"'err'"
op|':'
name|'err'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'DiskFileNoSpace'
op|'('
name|'str'
op|'('
name|'err'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'cleanup_ondisk_files'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|'['
string|"'files'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'os_err'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Problem cleaning up %(datadir)s (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'datadir'"
op|':'
name|'self'
op|'.'
name|'_datadir'
op|','
string|"'err'"
op|':'
name|'os_err'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Problem writing durable state file %(file)s (%(err)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'file'"
op|':'
name|'durable_file_path'
op|','
string|"'err'"
op|':'
name|'err'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'DiskFileError'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exc'
newline|'\n'
nl|'\n'
DECL|member|commit
dedent|''
dedent|''
name|'def'
name|'commit'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize put by writing a timestamp.durable file for the object. We\n        do this for EC policy because it requires a 2-phase put commit\n        confirmation.\n\n        :param timestamp: object put timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        """'
newline|'\n'
name|'durable_file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_datadir'
op|','
name|'timestamp'
op|'.'
name|'internal'
op|'+'
string|"'.durable'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_durable'
op|','
name|'durable_file_path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|put
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference between this method and the replication policy\n        DiskFileWriter method is adding the frag index to the metadata.\n\n        :param metadata: dictionary of metadata to be associated with object\n        """'
newline|'\n'
name|'fi'
op|'='
name|'None'
newline|'\n'
name|'cleanup'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_extension'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# generally we treat the fragment index provided in metadata as'
nl|'\n'
comment|"# canon, but if it's unavailable (e.g. tests) it's reasonable to"
nl|'\n'
comment|'# use the frag_index provided at instantiation. Either way make'
nl|'\n'
comment|'# sure that the fragment index is included in object sysmeta.'
nl|'\n'
indent|'            '
name|'fi'
op|'='
name|'metadata'
op|'.'
name|'setdefault'
op|'('
string|"'X-Object-Sysmeta-Ec-Frag-Index'"
op|','
nl|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'_frag_index'
op|')'
newline|'\n'
comment|'# defer cleanup until commit() writes .durable'
nl|'\n'
name|'cleanup'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'super'
op|'('
name|'ECDiskFileWriter'
op|','
name|'self'
op|')'
op|'.'
name|'_put'
op|'('
name|'metadata'
op|','
name|'cleanup'
op|','
name|'frag_index'
op|'='
name|'fi'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFile
dedent|''
dedent|''
name|'class'
name|'ECDiskFile'
op|'('
name|'BaseDiskFile'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|reader_cls
indent|'    '
name|'reader_cls'
op|'='
name|'ECDiskFileReader'
newline|'\n'
DECL|variable|writer_cls
name|'writer_cls'
op|'='
name|'ECDiskFileWriter'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'ECDiskFile'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'frag_index'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'frag_index'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_frag_index'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'frag_index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_frag_index'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|durable_timestamp
name|'def'
name|'durable_timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provides the timestamp of the newest durable file found in the object\n        directory.\n\n        :return: A Timestamp instance, or None if no durable file was found.\n        :raises DiskFileNotOpen: if the open() method has not been previously\n                                 called on this instance.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_ondisk_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_ondisk_info'
op|'.'
name|'get'
op|'('
string|"'durable_frag_set'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_ondisk_info'
op|'['
string|"'durable_frag_set'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
newline|'\n'
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|fragments
name|'def'
name|'fragments'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provides information about all fragments that were found in the object\n        directory, including fragments without a matching durable file, and\n        including any fragment chosen to construct the opened diskfile.\n\n        :return: A dict mapping <Timestamp instance> -> <list of frag indexes>,\n                 or None if the diskfile has not been opened or no fragments\n                 were found.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_ondisk_info'
op|':'
newline|'\n'
indent|'            '
name|'frag_sets'
op|'='
name|'self'
op|'.'
name|'_ondisk_info'
op|'['
string|"'frag_sets'"
op|']'
newline|'\n'
name|'return'
name|'dict'
op|'('
op|'['
op|'('
name|'ts'
op|','
op|'['
name|'info'
op|'['
string|"'frag_index'"
op|']'
name|'for'
name|'info'
name|'in'
name|'frag_set'
op|']'
op|')'
nl|'\n'
name|'for'
name|'ts'
op|','
name|'frag_set'
name|'in'
name|'frag_sets'
op|'.'
name|'items'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_files
dedent|''
dedent|''
name|'def'
name|'_get_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference between this method and the replication policy\n        DiskFile method is passing in the frag_index kwarg to our manager\'s\n        get_ondisk_files method.\n\n        :param files: list of file names\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_ondisk_info'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'get_ondisk_files'
op|'('
nl|'\n'
name|'files'
op|','
name|'self'
op|'.'
name|'_datadir'
op|','
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'_frag_index'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_ondisk_info'
newline|'\n'
nl|'\n'
DECL|member|purge
dedent|''
name|'def'
name|'purge'
op|'('
name|'self'
op|','
name|'timestamp'
op|','
name|'frag_index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a tombstone file matching the specified timestamp or\n        datafile matching the specified timestamp and fragment index\n        from the object directory.\n\n        This provides the EC reconstructor/ssync process with a way to\n        remove a tombstone or fragment from a handoff node after\n        reverting it to its primary node.\n\n        The hash will be invalidated, and if empty or invalid the\n        hsh_path will be removed on next hash_cleanup_listdir.\n\n        :param timestamp: the object timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        :param frag_index: fragment archive index, must be\n                           a whole number or None.\n        """'
newline|'\n'
name|'exts'
op|'='
op|'['
string|"'.ts'"
op|']'
newline|'\n'
comment|"# when frag_index is None it's not possible to build a data file name"
nl|'\n'
name|'if'
name|'frag_index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'exts'
op|'.'
name|'append'
op|'('
string|"'.data'"
op|')'
newline|'\n'
dedent|''
name|'for'
name|'ext'
name|'in'
name|'exts'
op|':'
newline|'\n'
indent|'            '
name|'purge_file'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'make_on_disk_filename'
op|'('
nl|'\n'
name|'timestamp'
op|','
name|'ext'
op|'='
name|'ext'
op|','
name|'frag_index'
op|'='
name|'frag_index'
op|')'
newline|'\n'
name|'remove_file'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'purge_file'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'manager'
op|'.'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'DiskFileRouter'
op|'.'
name|'register'
op|'('
name|'EC_POLICY'
op|')'
newline|'\n'
DECL|class|ECDiskFileManager
name|'class'
name|'ECDiskFileManager'
op|'('
name|'BaseDiskFileManager'
op|')'
op|':'
newline|'\n'
DECL|variable|diskfile_cls
indent|'    '
name|'diskfile_cls'
op|'='
name|'ECDiskFile'
newline|'\n'
nl|'\n'
DECL|member|validate_fragment_index
name|'def'
name|'validate_fragment_index'
op|'('
name|'self'
op|','
name|'frag_index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return int representation of frag_index, or raise a DiskFileError if\n        frag_index is not a whole number.\n\n        :param frag_index: a fragment archive index\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'frag_index'
op|'='
name|'int'
op|'('
name|'str'
op|'('
name|'frag_index'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'TypeError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|"'Bad fragment index: %s: %s'"
op|'%'
op|'('
name|'frag_index'
op|','
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'frag_index'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|"'Fragment index must not be negative: %s'"
op|'%'
name|'frag_index'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'frag_index'
newline|'\n'
nl|'\n'
DECL|member|make_on_disk_filename
dedent|''
name|'def'
name|'make_on_disk_filename'
op|'('
name|'self'
op|','
name|'timestamp'
op|','
name|'ext'
op|'='
name|'None'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
nl|'\n'
name|'ctype_timestamp'
op|'='
name|'None'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the EC specific filename for given timestamp.\n\n        :param timestamp: the object timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        :param ext: an optional string representing a file extension to be\n                    appended to the returned file name\n        :param frag_index: a fragment archive index, used with .data extension\n                           only, must be a whole number.\n        :param ctype_timestamp: an optional content-type timestamp, an instance\n                                of :class:`~swift.common.utils.Timestamp`\n        :returns: a file name\n        :raises DiskFileError: if ext==\'.data\' and the kwarg frag_index is not\n                               a whole number\n        """'
newline|'\n'
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# for datafiles only we encode the fragment index in the filename'
nl|'\n'
comment|'# to allow archives of different indexes to temporarily be stored'
nl|'\n'
comment|'# on the same node in certain situations'
nl|'\n'
indent|'            '
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
name|'rv'
op|'='
name|'timestamp'
op|'.'
name|'internal'
op|'+'
string|"'#'"
op|'+'
name|'str'
op|'('
name|'frag_index'
op|')'
newline|'\n'
name|'return'
string|"'%s%s'"
op|'%'
op|'('
name|'rv'
op|','
name|'ext'
name|'or'
string|"''"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'super'
op|'('
name|'ECDiskFileManager'
op|','
name|'self'
op|')'
op|'.'
name|'make_on_disk_filename'
op|'('
nl|'\n'
name|'timestamp'
op|','
name|'ext'
op|','
name|'ctype_timestamp'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
nl|'\n'
DECL|member|parse_on_disk_filename
dedent|''
name|'def'
name|'parse_on_disk_filename'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns timestamp(s) and other info extracted from a policy specific\n        file name. For EC policy the data file name includes a fragment index\n        which must be stripped off to retrieve the timestamp.\n\n        :param filename: the file name including extension\n        :returns: a dict, with keys for timestamp, frag_index, ext and\n                  ctype_timestamp:\n\n            * timestamp is a :class:`~swift.common.utils.Timestamp`\n            * frag_index is an int or None\n            * ctype_timestamp is a :class:`~swift.common.utils.Timestamp` or\n              None for .meta files, otherwise None\n            * ext is a string, the file extension including the leading dot or\n              the empty string if the filename has no extension.\n\n        :raises DiskFileError: if any part of the filename is not able to be\n                               validated.\n        """'
newline|'\n'
name|'frag_index'
op|'='
name|'None'
newline|'\n'
name|'float_frag'
op|','
name|'ext'
op|'='
name|'splitext'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
indent|'            '
name|'parts'
op|'='
name|'float_frag'
op|'.'
name|'split'
op|'('
string|"'#'"
op|','
number|'1'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'parts'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileError'
op|'('
string|"'Invalid Timestamp value in filename %r'"
nl|'\n'
op|'%'
name|'filename'
op|')'
newline|'\n'
comment|'# it is an error for an EC data file to not have a valid'
nl|'\n'
comment|'# fragment index'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'frag_index'
op|'='
name|'parts'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|'# expect validate_fragment_index raise DiskFileError'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
name|'return'
op|'{'
nl|'\n'
string|"'timestamp'"
op|':'
name|'timestamp'
op|','
nl|'\n'
string|"'frag_index'"
op|':'
name|'frag_index'
op|','
nl|'\n'
string|"'ext'"
op|':'
name|'ext'
op|','
nl|'\n'
string|"'ctype_timestamp'"
op|':'
name|'None'
nl|'\n'
op|'}'
newline|'\n'
dedent|''
name|'rv'
op|'='
name|'super'
op|'('
name|'ECDiskFileManager'
op|','
name|'self'
op|')'
op|'.'
name|'parse_on_disk_filename'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'rv'
op|'['
string|"'frag_index'"
op|']'
op|'='
name|'None'
newline|'\n'
name|'return'
name|'rv'
newline|'\n'
nl|'\n'
DECL|member|_process_ondisk_files
dedent|''
name|'def'
name|'_process_ondisk_files'
op|'('
name|'self'
op|','
name|'exts'
op|','
name|'results'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement EC policy specific handling of .data and .durable files.\n\n        :param exts: dict of lists of file info, keyed by extension\n        :param results: a dict that may be updated with results\n        :param frag_index: if set, search for a specific fragment index .data\n                           file, otherwise accept the first valid .data file.\n        """'
newline|'\n'
name|'durable_info'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.durable'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'durable_info'
op|'='
name|'exts'
op|'['
string|"'.durable'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
comment|'# Mark everything older than most recent .durable as obsolete'
nl|'\n'
comment|'# and remove from the exts dict.'
nl|'\n'
name|'for'
name|'ext'
name|'in'
name|'exts'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'older'
op|'='
name|'self'
op|'.'
name|'_split_gte_timestamp'
op|'('
nl|'\n'
name|'exts'
op|'['
name|'ext'
op|']'
op|','
name|'durable_info'
op|'['
string|"'timestamp'"
op|']'
op|')'
newline|'\n'
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'older'
op|')'
newline|'\n'
nl|'\n'
comment|'# Split the list of .data files into sets of frags having the same'
nl|'\n'
comment|'# timestamp, identifying the durable and newest sets (if any) as we go.'
nl|'\n'
comment|'# To do this we can take advantage of the list of .data files being'
nl|'\n'
comment|'# reverse-time ordered. Keep the resulting per-timestamp frag sets in'
nl|'\n'
comment|'# a frag_sets dict mapping a Timestamp instance -> frag_set.'
nl|'\n'
dedent|''
dedent|''
name|'all_frags'
op|'='
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
newline|'\n'
name|'frag_sets'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'durable_frag_set'
op|'='
name|'None'
newline|'\n'
name|'while'
name|'all_frags'
op|':'
newline|'\n'
indent|'            '
name|'frag_set'
op|','
name|'all_frags'
op|'='
name|'self'
op|'.'
name|'_split_gte_timestamp'
op|'('
nl|'\n'
name|'all_frags'
op|','
name|'all_frags'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
op|')'
newline|'\n'
comment|'# sort the frag set into ascending frag_index order'
nl|'\n'
name|'frag_set'
op|'.'
name|'sort'
op|'('
name|'key'
op|'='
name|'lambda'
name|'info'
op|':'
name|'info'
op|'['
string|"'frag_index'"
op|']'
op|')'
newline|'\n'
name|'timestamp'
op|'='
name|'frag_set'
op|'['
number|'0'
op|']'
op|'['
string|"'timestamp'"
op|']'
newline|'\n'
name|'frag_sets'
op|'['
name|'timestamp'
op|']'
op|'='
name|'frag_set'
newline|'\n'
name|'if'
name|'durable_info'
name|'and'
name|'durable_info'
op|'['
string|"'timestamp'"
op|']'
op|'=='
name|'timestamp'
op|':'
newline|'\n'
indent|'                '
name|'durable_frag_set'
op|'='
name|'frag_set'
newline|'\n'
nl|'\n'
comment|'# Select a single chosen frag from the chosen frag_set, by either'
nl|'\n'
comment|'# matching against a specified frag_index or taking the highest index.'
nl|'\n'
dedent|''
dedent|''
name|'chosen_frag'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'durable_frag_set'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'frag_index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# search the frag set to find the exact frag_index'
nl|'\n'
indent|'                '
name|'for'
name|'info'
name|'in'
name|'durable_frag_set'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'info'
op|'['
string|"'frag_index'"
op|']'
op|'=='
name|'frag_index'
op|':'
newline|'\n'
indent|'                        '
name|'chosen_frag'
op|'='
name|'info'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'chosen_frag'
op|'='
name|'durable_frag_set'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
comment|'# If we successfully found a frag then set results'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'chosen_frag'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'['
string|"'data_info'"
op|']'
op|'='
name|'chosen_frag'
newline|'\n'
name|'results'
op|'['
string|"'durable_frag_set'"
op|']'
op|'='
name|'durable_frag_set'
newline|'\n'
dedent|''
name|'results'
op|'['
string|"'frag_sets'"
op|']'
op|'='
name|'frag_sets'
newline|'\n'
nl|'\n'
comment|'# Mark any isolated .durable as obsolete'
nl|'\n'
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.durable'"
op|')'
name|'and'
name|'not'
name|'durable_frag_set'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'exts'
op|'['
string|"'.durable'"
op|']'
op|')'
newline|'\n'
name|'exts'
op|'.'
name|'pop'
op|'('
string|"'.durable'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Fragments *may* be ready for reclaim, unless they are durable'
nl|'\n'
dedent|''
name|'for'
name|'frag_set'
name|'in'
name|'frag_sets'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'frag_set'
op|'=='
name|'durable_frag_set'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'possible_reclaim'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
name|'frag_set'
op|')'
newline|'\n'
nl|'\n'
comment|'# .meta files *may* be ready for reclaim if there is no durable data'
nl|'\n'
dedent|''
name|'if'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
name|'and'
name|'not'
name|'durable_frag_set'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'possible_reclaim'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'extend'
op|'('
nl|'\n'
name|'exts'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_verify_ondisk_files
dedent|''
dedent|''
name|'def'
name|'_verify_ondisk_files'
op|'('
name|'self'
op|','
name|'results'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the final combination of on disk files complies with the\n        erasure-coded diskfile contract.\n\n        :param results: files that have been found and accepted\n        :param frag_index: specifies a specific fragment index .data file\n        :returns: True if the file combination is compliant, False otherwise\n        """'
newline|'\n'
name|'if'
name|'super'
op|'('
name|'ECDiskFileManager'
op|','
name|'self'
op|')'
op|'.'
name|'_verify_ondisk_files'
op|'('
nl|'\n'
name|'results'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'have_data_file'
op|'='
name|'results'
op|'['
string|"'data_file'"
op|']'
name|'is'
name|'not'
name|'None'
newline|'\n'
name|'have_durable'
op|'='
name|'results'
op|'.'
name|'get'
op|'('
string|"'durable_frag_set'"
op|')'
name|'is'
name|'not'
name|'None'
newline|'\n'
name|'return'
name|'have_data_file'
op|'=='
name|'have_durable'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_update_suffix_hashes
dedent|''
name|'def'
name|'_update_suffix_hashes'
op|'('
name|'self'
op|','
name|'hashes'
op|','
name|'ondisk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Applies policy specific updates to the given dict of md5 hashes for\n        the given ondisk_info.\n\n        The only difference between this method and the replication policy\n        function is the way that data files update hashes dict. Instead of all\n        filenames hashed into a single hasher, each data file name will fall\n        into a bucket keyed by its fragment index.\n\n        :param hashes: a dict of md5 hashes to be updated\n        :param ondisk_info: a dict describing the state of ondisk files, as\n                            returned by get_ondisk_files\n        """'
newline|'\n'
name|'for'
name|'frag_set'
name|'in'
name|'ondisk_info'
op|'['
string|"'frag_sets'"
op|']'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'file_info'
name|'in'
name|'frag_set'
op|':'
newline|'\n'
indent|'                '
name|'fi'
op|'='
name|'file_info'
op|'['
string|"'frag_index'"
op|']'
newline|'\n'
name|'hashes'
op|'['
name|'fi'
op|']'
op|'.'
name|'update'
op|'('
name|'file_info'
op|'['
string|"'timestamp'"
op|']'
op|'.'
name|'internal'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
string|"'durable_frag_set'"
name|'in'
name|'ondisk_info'
op|':'
newline|'\n'
indent|'            '
name|'file_info'
op|'='
name|'ondisk_info'
op|'['
string|"'durable_frag_set'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'hashes'
op|'['
name|'None'
op|']'
op|'.'
name|'update'
op|'('
name|'file_info'
op|'['
string|"'timestamp'"
op|']'
op|'.'
name|'internal'
op|'+'
string|"'.durable'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_hash_suffix
dedent|''
dedent|''
name|'def'
name|'_hash_suffix'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Performs reclamation and returns an md5 of all (remaining) files.\n\n        :param path: full path to directory\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :raises PathNotDir: if given path is not a valid directory\n        :raises OSError: for non-ENOTDIR errors\n        :returns: dict of md5 hex digests\n        """'
newline|'\n'
comment|'# hash_per_fi instead of single hash for whole suffix'
nl|'\n'
comment|'# here we flatten out the hashers hexdigest into a dictionary instead'
nl|'\n'
comment|'# of just returning the one hexdigest for the whole suffix'
nl|'\n'
nl|'\n'
name|'hash_per_fi'
op|'='
name|'self'
op|'.'
name|'_hash_suffix_dir'
op|'('
name|'path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'return'
name|'dict'
op|'('
op|'('
name|'fi'
op|','
name|'md5'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|')'
name|'for'
name|'fi'
op|','
name|'md5'
name|'in'
name|'hash_per_fi'
op|'.'
name|'items'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
