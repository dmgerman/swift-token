begin_unit
comment|'# Copyright (c) 2010-2012 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
name|'import'
name|'bisect'
newline|'\n'
name|'import'
name|'copy'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
name|'import'
name|'math'
newline|'\n'
name|'import'
name|'random'
newline|'\n'
name|'import'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
nl|'\n'
name|'from'
name|'array'
name|'import'
name|'array'
newline|'\n'
name|'from'
name|'collections'
name|'import'
name|'defaultdict'
newline|'\n'
name|'from'
name|'time'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
name|'import'
name|'exceptions'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'ring'
name|'import'
name|'RingData'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'ring'
op|'.'
name|'utils'
name|'import'
name|'tiers_for_dev'
op|','
name|'build_tier_tree'
newline|'\n'
nl|'\n'
DECL|variable|MAX_BALANCE
name|'MAX_BALANCE'
op|'='
number|'999.99'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|RingBuilder
name|'class'
name|'RingBuilder'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Used to build swift.common.ring.RingData instances to be written to disk\n    and used with swift.common.ring.Ring instances. See bin/swift-ring-builder\n    for example usage.\n\n    The instance variable devs_changed indicates if the device information has\n    changed since the last balancing. This can be used by tools to know whether\n    a rebalance request is an isolated request or due to added, changed, or\n    removed devices.\n\n    :param part_power: number of partitions = 2**part_power.\n    :param replicas: number of replicas for each partition\n    :param min_part_hours: minimum number of hours between partition changes\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'part_power'
op|','
name|'replicas'
op|','
name|'min_part_hours'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'part_power'
op|'>'
number|'32'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"part_power must be at most 32 (was %d)"'
nl|'\n'
op|'%'
op|'('
name|'part_power'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'replicas'
op|'<'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"replicas must be at least 1 (was %.6f)"'
nl|'\n'
op|'%'
op|'('
name|'replicas'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'min_part_hours'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"min_part_hours must be non-negative (was %d)"'
nl|'\n'
op|'%'
op|'('
name|'min_part_hours'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'part_power'
op|'='
name|'part_power'
newline|'\n'
name|'self'
op|'.'
name|'replicas'
op|'='
name|'replicas'
newline|'\n'
name|'self'
op|'.'
name|'min_part_hours'
op|'='
name|'min_part_hours'
newline|'\n'
name|'self'
op|'.'
name|'parts'
op|'='
number|'2'
op|'**'
name|'self'
op|'.'
name|'part_power'
newline|'\n'
name|'self'
op|'.'
name|'devs'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'='
number|'0'
newline|'\n'
nl|'\n'
comment|'# _replica2part2dev maps from replica number to partition number to'
nl|'\n'
comment|"# device id. So, for a three replica, 2**23 ring, it's an array of"
nl|'\n'
comment|'# three 2**23 arrays of device ids (unsigned shorts). This can work a'
nl|'\n'
comment|'# bit faster than the 2**23 array of triplet arrays of device ids in'
nl|'\n'
comment|"# many circumstances. Making one big 2**23 * 3 array didn't seem to"
nl|'\n'
comment|"# have any speed change; though you're welcome to try it again (it was"
nl|'\n'
comment|'# a while ago, code-wise, when I last tried it).'
nl|'\n'
name|'self'
op|'.'
name|'_replica2part2dev'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# _last_part_moves is a 2**23 array of unsigned bytes representing the'
nl|'\n'
comment|'# number of hours since a given partition was last moved. This is used'
nl|'\n'
comment|"# to guarantee we don't move a partition twice within a given number of"
nl|'\n'
comment|'# hours (24 is my usual test). Removing a device or setting its weight'
nl|'\n'
comment|"# to 0 overrides this behavior as it's assumed those actions are done"
nl|'\n'
comment|'# because of device failure.'
nl|'\n'
comment|'# _last_part_moves_epoch indicates the time the offsets in'
nl|'\n'
comment|'# _last_part_moves is based on.'
nl|'\n'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_last_part_gather_start'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_remove_devs'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_ring'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|weight_of_one_part
dedent|''
name|'def'
name|'weight_of_one_part'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the weight of each partition as calculated from the\n        total weight of all the devices.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'parts'
op|'*'
name|'self'
op|'.'
name|'replicas'
op|'/'
name|'sum'
op|'('
name|'d'
op|'['
string|"'weight'"
op|']'
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ZeroDivisionError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptions'
op|'.'
name|'EmptyRingError'
op|'('
string|"'There are no devices in this '"
nl|'\n'
string|"'ring, or all devices have been '"
nl|'\n'
string|"'deleted'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|copy_from
dedent|''
dedent|''
name|'def'
name|'copy_from'
op|'('
name|'self'
op|','
name|'builder'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Reinitializes this RingBuilder instance from data obtained from the\n        builder dict given. Code example::\n\n            b = RingBuilder(1, 1, 1)  # Dummy values\n            b.copy_from(builder)\n\n        This is to restore a RingBuilder that has had its b.to_dict()\n        previously saved.\n        """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'builder'
op|','
string|"'devs'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'part_power'
op|'='
name|'builder'
op|'.'
name|'part_power'
newline|'\n'
name|'self'
op|'.'
name|'replicas'
op|'='
name|'builder'
op|'.'
name|'replicas'
newline|'\n'
name|'self'
op|'.'
name|'min_part_hours'
op|'='
name|'builder'
op|'.'
name|'min_part_hours'
newline|'\n'
name|'self'
op|'.'
name|'parts'
op|'='
name|'builder'
op|'.'
name|'parts'
newline|'\n'
name|'self'
op|'.'
name|'devs'
op|'='
name|'builder'
op|'.'
name|'devs'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'builder'
op|'.'
name|'devs_changed'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'='
name|'builder'
op|'.'
name|'version'
newline|'\n'
name|'self'
op|'.'
name|'_replica2part2dev'
op|'='
name|'builder'
op|'.'
name|'_replica2part2dev'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|'='
name|'builder'
op|'.'
name|'_last_part_moves_epoch'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves'
op|'='
name|'builder'
op|'.'
name|'_last_part_moves'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_gather_start'
op|'='
name|'builder'
op|'.'
name|'_last_part_gather_start'
newline|'\n'
name|'self'
op|'.'
name|'_remove_devs'
op|'='
name|'builder'
op|'.'
name|'_remove_devs'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'part_power'
op|'='
name|'builder'
op|'['
string|"'part_power'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'replicas'
op|'='
name|'builder'
op|'['
string|"'replicas'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'min_part_hours'
op|'='
name|'builder'
op|'['
string|"'min_part_hours'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'parts'
op|'='
name|'builder'
op|'['
string|"'parts'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'devs'
op|'='
name|'builder'
op|'['
string|"'devs'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'builder'
op|'['
string|"'devs_changed'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'='
name|'builder'
op|'['
string|"'version'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_replica2part2dev'
op|'='
name|'builder'
op|'['
string|"'_replica2part2dev'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|'='
name|'builder'
op|'['
string|"'_last_part_moves_epoch'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves'
op|'='
name|'builder'
op|'['
string|"'_last_part_moves'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_gather_start'
op|'='
name|'builder'
op|'['
string|"'_last_part_gather_start'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_remove_devs'
op|'='
name|'builder'
op|'['
string|"'_remove_devs'"
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ring'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Old builders may not have a region defined for their devices, in'
nl|'\n'
comment|'# which case we default it to 1.'
nl|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'setdefault'
op|'('
string|'"region"'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|to_dict
dedent|''
dedent|''
name|'def'
name|'to_dict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a dict that can be used later with copy_from to\n        restore a RingBuilder. swift-ring-builder uses this to\n        pickle.dump the dict to a file and later load that dict into\n        copy_from.\n        """'
newline|'\n'
name|'return'
op|'{'
string|"'part_power'"
op|':'
name|'self'
op|'.'
name|'part_power'
op|','
nl|'\n'
string|"'replicas'"
op|':'
name|'self'
op|'.'
name|'replicas'
op|','
nl|'\n'
string|"'min_part_hours'"
op|':'
name|'self'
op|'.'
name|'min_part_hours'
op|','
nl|'\n'
string|"'parts'"
op|':'
name|'self'
op|'.'
name|'parts'
op|','
nl|'\n'
string|"'devs'"
op|':'
name|'self'
op|'.'
name|'devs'
op|','
nl|'\n'
string|"'devs_changed'"
op|':'
name|'self'
op|'.'
name|'devs_changed'
op|','
nl|'\n'
string|"'version'"
op|':'
name|'self'
op|'.'
name|'version'
op|','
nl|'\n'
string|"'_replica2part2dev'"
op|':'
name|'self'
op|'.'
name|'_replica2part2dev'
op|','
nl|'\n'
string|"'_last_part_moves_epoch'"
op|':'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|','
nl|'\n'
string|"'_last_part_moves'"
op|':'
name|'self'
op|'.'
name|'_last_part_moves'
op|','
nl|'\n'
string|"'_last_part_gather_start'"
op|':'
name|'self'
op|'.'
name|'_last_part_gather_start'
op|','
nl|'\n'
string|"'_remove_devs'"
op|':'
name|'self'
op|'.'
name|'_remove_devs'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|change_min_part_hours
dedent|''
name|'def'
name|'change_min_part_hours'
op|'('
name|'self'
op|','
name|'min_part_hours'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Changes the value used to decide if a given partition can be moved\n        again. This restriction is to give the overall system enough time to\n        settle a partition to its new location before moving it to yet another\n        location. While no data would be lost if a partition is moved several\n        times quickly, it could make that data unreachable for a short period\n        of time.\n\n        This should be set to at least the average full partition replication\n        time. Starting it at 24 hours and then lowering it to what the\n        replicator reports as the longest partition cycle is best.\n\n        :param min_part_hours: new value for min_part_hours\n        """'
newline|'\n'
name|'self'
op|'.'
name|'min_part_hours'
op|'='
name|'min_part_hours'
newline|'\n'
nl|'\n'
DECL|member|set_replicas
dedent|''
name|'def'
name|'set_replicas'
op|'('
name|'self'
op|','
name|'new_replica_count'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Changes the number of replicas in this ring.\n\n        If the new replica count is sufficiently different that\n        self._replica2part2dev will change size, sets\n        self.devs_changed. This is so tools like\n        bin/swift-ring-builder can know to write out the new ring\n        rather than bailing out due to lack of balance change.\n        """'
newline|'\n'
name|'old_slots_used'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'parts'
op|'*'
name|'self'
op|'.'
name|'replicas'
op|')'
newline|'\n'
name|'new_slots_used'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'parts'
op|'*'
name|'new_replica_count'
op|')'
newline|'\n'
name|'if'
name|'old_slots_used'
op|'!='
name|'new_slots_used'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'replicas'
op|'='
name|'new_replica_count'
newline|'\n'
nl|'\n'
DECL|member|get_ring
dedent|''
name|'def'
name|'get_ring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the ring, or more specifically, the swift.common.ring.RingData.\n        This ring data is the minimum required for use of the ring. The ring\n        builder itself keeps additional data such as when partitions were last\n        moved.\n        """'
newline|'\n'
comment|"# We cache the self._ring value so multiple requests for it don't build"
nl|'\n'
comment|'# it multiple times. Be sure to set self._ring = None whenever the ring'
nl|'\n'
comment|'# will need to be rebuilt.'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_ring'
op|':'
newline|'\n'
comment|'# Make devs list (with holes for deleted devices) and not including'
nl|'\n'
comment|'# builder-specific extra attributes.'
nl|'\n'
indent|'            '
name|'devs'
op|'='
op|'['
name|'None'
op|']'
op|'*'
name|'len'
op|'('
name|'self'
op|'.'
name|'devs'
op|')'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'devs'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'dict'
op|'('
op|'('
name|'k'
op|','
name|'v'
op|')'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'dev'
op|'.'
name|'items'
op|'('
op|')'
nl|'\n'
name|'if'
name|'k'
name|'not'
name|'in'
op|'('
string|"'parts'"
op|','
string|"'parts_wanted'"
op|')'
op|')'
newline|'\n'
comment|'# Copy over the replica+partition->device assignments, the device'
nl|'\n'
comment|'# information, and the part_shift value (the number of bits to'
nl|'\n'
comment|'# shift an unsigned int >I right to obtain the partition for the'
nl|'\n'
comment|'# int).'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_replica2part2dev'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_ring'
op|'='
name|'RingData'
op|'('
op|'['
op|']'
op|','
name|'devs'
op|','
number|'32'
op|'-'
name|'self'
op|'.'
name|'part_power'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_ring'
op|'='
name|'RingData'
op|'('
op|'['
name|'array'
op|'('
string|"'H'"
op|','
name|'p2d'
op|')'
name|'for'
name|'p2d'
name|'in'
nl|'\n'
name|'self'
op|'.'
name|'_replica2part2dev'
op|']'
op|','
nl|'\n'
name|'devs'
op|','
number|'32'
op|'-'
name|'self'
op|'.'
name|'part_power'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_ring'
newline|'\n'
nl|'\n'
DECL|member|add_dev
dedent|''
name|'def'
name|'add_dev'
op|'('
name|'self'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a device to the ring. This device dict should have a minimum of the\n        following keys:\n\n        ======  ===============================================================\n        id      unique integer identifier amongst devices. Defaults to the next\n                id if the \'id\' key is not provided in the dict\n        weight  a float of the relative weight of this device as compared to\n                others; this indicates how many partitions the builder will try\n                to assign to this device\n        region  integer indicating which region the device is in\n        zone    integer indicating which zone the device is in; a given\n                partition will not be assigned to multiple devices within the\n                same (region, zone) pair if there is any alternative\n        ip      the ip address of the device\n        port    the tcp port of the device\n        device  the device\'s name on disk (sdb1, for example)\n        meta    general use \'extra\' field; for example: the online date, the\n                hardware description\n        ======  ===============================================================\n\n        .. note::\n            This will not rebalance the ring immediately as you may want to\n            make multiple changes for a single rebalance.\n\n        :param dev: device dict\n\n        :returns: id of device\n        """'
newline|'\n'
name|'if'
string|"'id'"
name|'not'
name|'in'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'['
string|"'id'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'devs'
op|':'
newline|'\n'
indent|'                '
name|'dev'
op|'['
string|"'id'"
op|']'
op|'='
name|'max'
op|'('
name|'d'
op|'['
string|"'id'"
op|']'
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'devs'
name|'if'
name|'d'
op|')'
op|'+'
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'dev'
op|'['
string|"'id'"
op|']'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'devs'
op|')'
name|'and'
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptions'
op|'.'
name|'DuplicateDeviceError'
op|'('
nl|'\n'
string|"'Duplicate device id: %d'"
op|'%'
name|'dev'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
comment|"# Add holes to self.devs to ensure self.devs[dev['id']] will be the dev"
nl|'\n'
dedent|''
name|'while'
name|'dev'
op|'['
string|"'id'"
op|']'
op|'>='
name|'len'
op|'('
name|'self'
op|'.'
name|'devs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'devs'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'dev'
op|'['
string|"'weight'"
op|']'
op|'='
name|'float'
op|'('
name|'dev'
op|'['
string|"'weight'"
op|']'
op|')'
newline|'\n'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'dev'
newline|'\n'
name|'self'
op|'.'
name|'_set_parts_wanted'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'+='
number|'1'
newline|'\n'
name|'return'
name|'dev'
op|'['
string|"'id'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|set_dev_weight
dedent|''
name|'def'
name|'set_dev_weight'
op|'('
name|'self'
op|','
name|'dev_id'
op|','
name|'weight'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set the weight of a device. This should be called rather than just\n        altering the weight key in the device dict directly, as the builder\n        will need to rebuild some internal state to reflect the change.\n\n        .. note::\n            This will not rebalance the ring immediately as you may want to\n            make multiple changes for a single rebalance.\n\n        :param dev_id: device id\n        :param weight: new weight for device\n        """'
newline|'\n'
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev_id'
op|']'
op|'['
string|"'weight'"
op|']'
op|'='
name|'weight'
newline|'\n'
name|'self'
op|'.'
name|'_set_parts_wanted'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|remove_dev
dedent|''
name|'def'
name|'remove_dev'
op|'('
name|'self'
op|','
name|'dev_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a device from the ring.\n\n        .. note::\n            This will not rebalance the ring immediately as you may want to\n            make multiple changes for a single rebalance.\n\n        :param dev_id: device id\n        """'
newline|'\n'
name|'dev'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev_id'
op|']'
newline|'\n'
name|'dev'
op|'['
string|"'weight'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_remove_devs'
op|'.'
name|'append'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_parts_wanted'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|rebalance
dedent|''
name|'def'
name|'rebalance'
op|'('
name|'self'
op|','
name|'seed'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Rebalance the ring.\n\n        This is the main work function of the builder, as it will assign and\n        reassign partitions to devices in the ring based on weights, distinct\n        zones, recent reassignments, etc.\n\n        The process doesn\'t always perfectly assign partitions (that\'d take a\n        lot more analysis and therefore a lot more time -- I had code that did\n        that before). Because of this, it keeps rebalancing until the device\n        skew (number of partitions a device wants compared to what it has) gets\n        below 1% or doesn\'t change by more than 1% (only happens with ring that\n        can\'t be balanced no matter what).\n\n        :returns: (number_of_partitions_altered, resulting_balance)\n        """'
newline|'\n'
name|'old_replica2part2dev'
op|'='
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'seed'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'random'
op|'.'
name|'seed'
op|'('
name|'seed'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_ring'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_initial_balance'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'False'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'parts'
op|','
name|'self'
op|'.'
name|'get_balance'
op|'('
op|')'
newline|'\n'
dedent|''
name|'changed_parts'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_update_last_part_moves'
op|'('
op|')'
newline|'\n'
name|'last_balance'
op|'='
number|'0'
newline|'\n'
name|'new_parts'
op|','
name|'removed_part_count'
op|'='
name|'self'
op|'.'
name|'_adjust_replica2part2dev_size'
op|'('
op|')'
newline|'\n'
name|'changed_parts'
op|'+='
name|'removed_part_count'
newline|'\n'
name|'if'
name|'new_parts'
name|'or'
name|'removed_part_count'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_parts_wanted'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_reassign_parts'
op|'('
name|'new_parts'
op|')'
newline|'\n'
name|'changed_parts'
op|'+='
name|'len'
op|'('
name|'new_parts'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'reassign_parts'
op|'='
name|'self'
op|'.'
name|'_gather_reassign_parts'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_reassign_parts'
op|'('
name|'reassign_parts'
op|')'
newline|'\n'
name|'changed_parts'
op|'+='
name|'len'
op|'('
name|'reassign_parts'
op|')'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_remove_devs'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'devs'
op|'['
name|'self'
op|'.'
name|'_remove_devs'
op|'.'
name|'pop'
op|'('
op|')'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'balance'
op|'='
name|'self'
op|'.'
name|'get_balance'
op|'('
op|')'
newline|'\n'
name|'if'
name|'balance'
op|'<'
number|'1'
name|'or'
name|'abs'
op|'('
name|'last_balance'
op|'-'
name|'balance'
op|')'
op|'<'
number|'1'
name|'or'
name|'changed_parts'
op|'=='
name|'self'
op|'.'
name|'parts'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'last_balance'
op|'='
name|'balance'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'devs_changed'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'version'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
comment|'# Compare the partition allocation before and after the rebalance'
nl|'\n'
comment|'# Only changed device ids are taken into account; devices might be'
nl|'\n'
comment|'# "touched" during the rebalance, but actually not really moved'
nl|'\n'
name|'changed_parts'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'rep_id'
op|','
name|'_rep'
name|'in'
name|'enumerate'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'part_id'
op|','
name|'new_device'
name|'in'
name|'enumerate'
op|'('
name|'_rep'
op|')'
op|':'
newline|'\n'
comment|'# IndexErrors will be raised if the replicas are increased or'
nl|'\n'
comment|'# decreased, and that actually means the partition has changed'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'old_device'
op|'='
name|'old_replica2part2dev'
op|'['
name|'rep_id'
op|']'
op|'['
name|'part_id'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
indent|'                    '
name|'changed_parts'
op|'+='
number|'1'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'old_device'
op|'!='
name|'new_device'
op|':'
newline|'\n'
indent|'                    '
name|'changed_parts'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'changed_parts'
op|','
name|'balance'
newline|'\n'
nl|'\n'
DECL|member|validate
dedent|''
name|'def'
name|'validate'
op|'('
name|'self'
op|','
name|'stats'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Validate the ring.\n\n        This is a safety function to try to catch any bugs in the building\n        process. It ensures partitions have been assigned to real devices,\n        aren\'t doubly assigned, etc. It can also optionally check the even\n        distribution of partitions across devices.\n\n        :param stats: if True, check distribution of partitions across devices\n        :returns: if stats is True, a tuple of (device_usage, worst_stat), else\n                  (None, None). device_usage[dev_id] will equal the number of\n                  partitions assigned to that device. worst_stat will equal the\n                  number of partitions the worst device is skewed from the\n                  number it should have.\n        :raises RingValidationError: problem was found with the ring.\n        """'
newline|'\n'
nl|'\n'
comment|'# "len" showed up in profiling, so it\'s just computed once.'
nl|'\n'
name|'dev_len'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'devs'
op|')'
newline|'\n'
nl|'\n'
name|'parts_on_devs'
op|'='
name|'sum'
op|'('
name|'d'
op|'['
string|"'parts'"
op|']'
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_replica2part2dev'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptions'
op|'.'
name|'RingValidationError'
op|'('
nl|'\n'
string|"'_replica2part2dev empty; did you forget to rebalance?'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'parts_in_map'
op|'='
name|'sum'
op|'('
name|'len'
op|'('
name|'p2d'
op|')'
name|'for'
name|'p2d'
name|'in'
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
newline|'\n'
name|'if'
name|'parts_on_devs'
op|'!='
name|'parts_in_map'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptions'
op|'.'
name|'RingValidationError'
op|'('
nl|'\n'
string|"'All partitions are not double accounted for: %d != %d'"
op|'%'
nl|'\n'
op|'('
name|'parts_on_devs'
op|','
name|'parts_in_map'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stats'
op|':'
newline|'\n'
comment|'# dev_usage[dev_id] will equal the number of partitions assigned to'
nl|'\n'
comment|'# that device.'
nl|'\n'
indent|'            '
name|'dev_usage'
op|'='
name|'array'
op|'('
string|"'I'"
op|','
op|'('
number|'0'
name|'for'
name|'_junk'
name|'in'
name|'xrange'
op|'('
name|'dev_len'
op|')'
op|')'
op|')'
newline|'\n'
name|'for'
name|'part2dev'
name|'in'
name|'self'
op|'.'
name|'_replica2part2dev'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'dev_id'
name|'in'
name|'part2dev'
op|':'
newline|'\n'
indent|'                    '
name|'dev_usage'
op|'['
name|'dev_id'
op|']'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'for'
name|'part'
op|','
name|'replica'
name|'in'
name|'self'
op|'.'
name|'_each_part_replica'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev_id'
op|'='
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'['
name|'part'
op|']'
newline|'\n'
name|'if'
name|'dev_id'
op|'>='
name|'dev_len'
name|'or'
name|'not'
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev_id'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exceptions'
op|'.'
name|'RingValidationError'
op|'('
nl|'\n'
string|'"Partition %d, replica %d was not allocated "'
nl|'\n'
string|'"to a device."'
op|'%'
nl|'\n'
op|'('
name|'part'
op|','
name|'replica'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'dev'
op|'['
string|"'port'"
op|']'
op|','
name|'int'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exceptions'
op|'.'
name|'RingValidationError'
op|'('
nl|'\n'
string|'"Device %d has port %r, which is not an integer."'
op|'%'
nl|'\n'
op|'('
name|'dev'
op|'['
string|"'id'"
op|']'
op|','
name|'dev'
op|'['
string|"'port'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'stats'
op|':'
newline|'\n'
indent|'            '
name|'weight_of_one_part'
op|'='
name|'self'
op|'.'
name|'weight_of_one_part'
op|'('
op|')'
newline|'\n'
name|'worst'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'dev'
op|'['
string|"'weight'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'dev_usage'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|':'
newline|'\n'
comment|'# If a device has no weight, but has partitions, then'
nl|'\n'
comment|'# its overage is considered "infinity" and therefore'
nl|'\n'
comment|'# always the worst possible. We show MAX_BALANCE for'
nl|'\n'
comment|'# convenience.'
nl|'\n'
indent|'                        '
name|'worst'
op|'='
name|'MAX_BALANCE'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'skew'
op|'='
name|'abs'
op|'('
number|'100.0'
op|'*'
name|'dev_usage'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'/'
nl|'\n'
op|'('
name|'dev'
op|'['
string|"'weight'"
op|']'
op|'*'
name|'weight_of_one_part'
op|')'
op|'-'
number|'100.0'
op|')'
newline|'\n'
name|'if'
name|'skew'
op|'>'
name|'worst'
op|':'
newline|'\n'
indent|'                    '
name|'worst'
op|'='
name|'skew'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'dev_usage'
op|','
name|'worst'
newline|'\n'
dedent|''
name|'return'
name|'None'
op|','
name|'None'
newline|'\n'
nl|'\n'
DECL|member|get_balance
dedent|''
name|'def'
name|'get_balance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the balance of the ring. The balance value is the highest\n        percentage off the desired amount of partitions a given device\n        wants. For instance, if the "worst" device wants (based on its\n        weight relative to the sum of all the devices\' weights) 123\n        partitions and it has 124 partitions, the balance value would\n        be 0.83 (1 extra / 123 wanted * 100 for percentage).\n\n        :returns: balance of the ring\n        """'
newline|'\n'
name|'balance'
op|'='
number|'0'
newline|'\n'
name|'weight_of_one_part'
op|'='
name|'self'
op|'.'
name|'weight_of_one_part'
op|'('
op|')'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dev'
op|'['
string|"'weight'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|':'
newline|'\n'
comment|'# If a device has no weight, but has partitions, then its'
nl|'\n'
comment|'# overage is considered "infinity" and therefore always the'
nl|'\n'
comment|'# worst possible. We show MAX_BALANCE for convenience.'
nl|'\n'
indent|'                    '
name|'balance'
op|'='
name|'MAX_BALANCE'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'dev_balance'
op|'='
name|'abs'
op|'('
number|'100.0'
op|'*'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|'/'
nl|'\n'
op|'('
name|'dev'
op|'['
string|"'weight'"
op|']'
op|'*'
name|'weight_of_one_part'
op|')'
op|'-'
number|'100.0'
op|')'
newline|'\n'
name|'if'
name|'dev_balance'
op|'>'
name|'balance'
op|':'
newline|'\n'
indent|'                '
name|'balance'
op|'='
name|'dev_balance'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'balance'
newline|'\n'
nl|'\n'
DECL|member|pretend_min_part_hours_passed
dedent|''
name|'def'
name|'pretend_min_part_hours_passed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Override min_part_hours by marking all partitions as having been moved\n        255 hours ago. This can be used to force a full rebalance on the next\n        call to rebalance.\n        """'
newline|'\n'
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'self'
op|'.'
name|'parts'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
number|'0xff'
newline|'\n'
nl|'\n'
DECL|member|get_part_devices
dedent|''
dedent|''
name|'def'
name|'get_part_devices'
op|'('
name|'self'
op|','
name|'part'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the devices that are responsible for the partition,\n        filtering out duplicates.\n\n        :param part: partition to get devices for\n        :returns: list of device dicts\n        """'
newline|'\n'
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_devs_for_part'
op|'('
name|'part'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'dev'
name|'not'
name|'in'
name|'devices'
op|':'
newline|'\n'
indent|'                '
name|'devices'
op|'.'
name|'append'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|_iter_devs
dedent|''
name|'def'
name|'_iter_devs'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns an iterator all the non-None devices in the ring. Note that\n        this means list(b._iter_devs())[some_id] may not equal b.devs[some_id];\n        you will have to check the \'id\' key of each device to obtain its\n        dev_id.\n        """'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'devs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'dev'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'dev'
newline|'\n'
nl|'\n'
DECL|member|_set_parts_wanted
dedent|''
dedent|''
dedent|''
name|'def'
name|'_set_parts_wanted'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Sets the parts_wanted key for each of the devices to the number of\n        partitions the device wants based on its relative weight. This key is\n        used to sort the devices according to "most wanted" during rebalancing\n        to best distribute partitions. A negative parts_wanted indicates the\n        device is "overweight" and wishes to give partitions away if possible.\n        """'
newline|'\n'
name|'weight_of_one_part'
op|'='
name|'self'
op|'.'
name|'weight_of_one_part'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dev'
op|'['
string|"'weight'"
op|']'
op|':'
newline|'\n'
comment|'# With no weight, that means we wish to "drain" the device. So'
nl|'\n'
comment|'# we set the parts_wanted to a really large negative number to'
nl|'\n'
comment|'# indicate its strong desire to give up everything it has.'
nl|'\n'
indent|'                '
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'='
op|'-'
name|'self'
op|'.'
name|'parts'
op|'*'
name|'self'
op|'.'
name|'replicas'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'='
op|'('
nl|'\n'
comment|'# Round up here so that every partition ultimately ends up'
nl|'\n'
comment|'# with a placement.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Imagine 5 partitions to be placed on 4 devices. If we'
nl|'\n'
comment|"# didn't use math.ceil() here, each device would have a"
nl|'\n'
comment|'# parts_wanted of 1, so 4 partitions would be placed but'
nl|'\n'
comment|'# the last would not, probably resulting in a crash. This'
nl|'\n'
comment|'# way, some devices end up with leftover parts_wanted, but'
nl|'\n'
comment|'# at least every partition ends up somewhere.'
nl|'\n'
name|'int'
op|'('
name|'math'
op|'.'
name|'ceil'
op|'('
name|'weight_of_one_part'
op|'*'
name|'dev'
op|'['
string|"'weight'"
op|']'
op|')'
op|')'
op|'-'
nl|'\n'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_adjust_replica2part2dev_size
dedent|''
dedent|''
dedent|''
name|'def'
name|'_adjust_replica2part2dev_size'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that the lengths of the arrays in _replica2part2dev\n        are correct for the current value of self.replicas.\n\n        Example:\n        self.part_power = 8\n        self.replicas = 2.25\n\n        self._replica2part2dev will contain 3 arrays: the first 2 of\n        length 256 (2**8), and the last of length 64 (0.25 * 2**8).\n\n        Returns a 2-tuple: the first element is a list of (partition,\n        replicas) tuples indicating which replicas need to be\n        (re)assigned to devices, and the second element is a count of\n        how many replicas were removed.\n        """'
newline|'\n'
name|'removed_replicas'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'fractional_replicas'
op|','
name|'whole_replicas'
op|'='
name|'math'
op|'.'
name|'modf'
op|'('
name|'self'
op|'.'
name|'replicas'
op|')'
newline|'\n'
name|'whole_replicas'
op|'='
name|'int'
op|'('
name|'whole_replicas'
op|')'
newline|'\n'
nl|'\n'
name|'desired_lengths'
op|'='
op|'['
name|'self'
op|'.'
name|'parts'
op|']'
op|'*'
name|'whole_replicas'
newline|'\n'
name|'if'
name|'fractional_replicas'
op|':'
newline|'\n'
indent|'            '
name|'desired_lengths'
op|'.'
name|'append'
op|'('
name|'int'
op|'('
name|'self'
op|'.'
name|'parts'
op|'*'
name|'fractional_replicas'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'to_assign'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_replica2part2dev'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# If we crossed an integer threshold (say, 4.1 --> 4),'
nl|'\n'
comment|"# we'll have a partial extra replica clinging on here. Clean"
nl|'\n'
comment|'# up any such extra stuff.'
nl|'\n'
indent|'            '
name|'for'
name|'part2dev'
name|'in'
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'len'
op|'('
name|'desired_lengths'
op|')'
op|':'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'dev_id'
name|'in'
name|'part2dev'
op|':'
newline|'\n'
indent|'                    '
name|'dev_losing_part'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'dev_id'
op|']'
newline|'\n'
name|'dev_losing_part'
op|'['
string|"'parts'"
op|']'
op|'-='
number|'1'
newline|'\n'
name|'removed_replicas'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_replica2part2dev'
op|'='
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
op|':'
name|'len'
op|'('
name|'desired_lengths'
op|')'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_replica2part2dev'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'replica'
op|','
name|'desired_length'
name|'in'
name|'enumerate'
op|'('
name|'desired_lengths'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'replica'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'part2dev'
op|'='
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'part2dev'
op|')'
op|'<'
name|'desired_length'
op|':'
newline|'\n'
comment|'# Not long enough: needs to be extended and the'
nl|'\n'
comment|'# newly-added pieces assigned to devices.'
nl|'\n'
indent|'                    '
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'len'
op|'('
name|'part2dev'
op|')'
op|','
name|'desired_length'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'to_assign'
op|'['
name|'part'
op|']'
op|'.'
name|'append'
op|'('
name|'replica'
op|')'
newline|'\n'
name|'part2dev'
op|'.'
name|'append'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'len'
op|'('
name|'part2dev'
op|')'
op|'>'
name|'desired_length'
op|':'
newline|'\n'
comment|'# Too long: truncate this mapping.'
nl|'\n'
indent|'                    '
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'desired_length'
op|','
name|'len'
op|'('
name|'part2dev'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'dev_losing_part'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'part2dev'
op|'['
name|'part'
op|']'
op|']'
newline|'\n'
name|'dev_losing_part'
op|'['
string|"'parts'"
op|']'
op|'-='
number|'1'
newline|'\n'
name|'removed_replicas'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'='
name|'part2dev'
op|'['
op|':'
name|'desired_length'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Mapping not present at all: make one up and assign'
nl|'\n'
comment|'# all of it.'
nl|'\n'
indent|'                '
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'desired_length'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'to_assign'
op|'['
name|'part'
op|']'
op|'.'
name|'append'
op|'('
name|'replica'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_replica2part2dev'
op|'.'
name|'append'
op|'('
nl|'\n'
name|'array'
op|'('
string|"'H'"
op|','
op|'('
number|'0'
name|'for'
name|'_junk'
name|'in'
name|'xrange'
op|'('
name|'desired_length'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
op|'('
name|'to_assign'
op|'.'
name|'items'
op|'('
op|')'
op|','
name|'removed_replicas'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_initial_balance
dedent|''
name|'def'
name|'_initial_balance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initial partition assignment is the same as rebalancing an\n        existing ring, but with some initial setup beforehand.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves'
op|'='
name|'array'
op|'('
string|"'B'"
op|','
op|'('
number|'0'
name|'for'
name|'_junk'
name|'in'
name|'xrange'
op|'('
name|'self'
op|'.'
name|'parts'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|'='
name|'int'
op|'('
name|'time'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_reassign_parts'
op|'('
name|'self'
op|'.'
name|'_adjust_replica2part2dev_size'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_update_last_part_moves
dedent|''
name|'def'
name|'_update_last_part_moves'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Updates how many hours ago each partition was moved based on the\n        current time. The builder won\'t move a partition that has been moved\n        more recently than min_part_hours.\n        """'
newline|'\n'
name|'elapsed_hours'
op|'='
name|'int'
op|'('
name|'time'
op|'('
op|')'
op|'-'
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|')'
op|'/'
number|'3600'
newline|'\n'
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'self'
op|'.'
name|'parts'
op|')'
op|':'
newline|'\n'
comment|'# The "min(self._last_part_moves[part] + elapsed_hours, 0xff)"'
nl|'\n'
comment|'# which was here showed up in profiling, so it got inlined.'
nl|'\n'
indent|'            '
name|'last_plus_elapsed'
op|'='
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'+'
name|'elapsed_hours'
newline|'\n'
name|'if'
name|'last_plus_elapsed'
op|'<'
number|'0xff'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
name|'last_plus_elapsed'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
number|'0xff'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_last_part_moves_epoch'
op|'='
name|'int'
op|'('
name|'time'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_gather_reassign_parts
dedent|''
name|'def'
name|'_gather_reassign_parts'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a list of (partition, replicas) pairs to be reassigned by\n        gathering from removed devices, insufficiently-far-apart replicas, and\n        overweight drives.\n        """'
newline|'\n'
comment|'# inline memoization of tiers_for_dev() results (profiling reveals it'
nl|'\n'
comment|'# as a hot-spot).'
nl|'\n'
name|'tfd'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# First we gather partitions from removed devices. Since removed'
nl|'\n'
comment|'# devices usually indicate device failures, we have no choice but to'
nl|'\n'
comment|'# reassign these partitions. However, we mark them as moved so later'
nl|'\n'
comment|'# choices will skip other replicas of the same partition if possible.'
nl|'\n'
name|'removed_dev_parts'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_remove_devs'
op|':'
newline|'\n'
indent|'            '
name|'dev_ids'
op|'='
op|'['
name|'d'
op|'['
string|"'id'"
op|']'
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'_remove_devs'
name|'if'
name|'d'
op|'['
string|"'parts'"
op|']'
op|']'
newline|'\n'
name|'if'
name|'dev_ids'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'part'
op|','
name|'replica'
name|'in'
name|'self'
op|'.'
name|'_each_part_replica'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'dev_id'
op|'='
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'['
name|'part'
op|']'
newline|'\n'
name|'if'
name|'dev_id'
name|'in'
name|'dev_ids'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
number|'0'
newline|'\n'
name|'removed_dev_parts'
op|'['
name|'part'
op|']'
op|'.'
name|'append'
op|'('
name|'replica'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now we gather partitions that are "at risk" because they aren\'t'
nl|'\n'
comment|'# currently sufficient spread out across the cluster.'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'spread_out_parts'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'max_allowed_replicas'
op|'='
name|'self'
op|'.'
name|'_build_max_replicas_by_tier'
op|'('
op|')'
newline|'\n'
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'self'
op|'.'
name|'parts'
op|')'
op|':'
newline|'\n'
comment|'# Only move one replica at a time if possible.'
nl|'\n'
indent|'            '
name|'if'
name|'part'
name|'in'
name|'removed_dev_parts'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# First, add up the count of replicas at each tier for each'
nl|'\n'
comment|'# partition.'
nl|'\n'
comment|'# replicas_at_tier was a "lambda: 0" defaultdict, but profiling'
nl|'\n'
comment|'# revealed the lambda invocation as a significant cost.'
nl|'\n'
dedent|''
name|'replicas_at_tier'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_devs_for_part'
op|'('
name|'part'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'dev'
op|'['
string|"'id'"
op|']'
name|'not'
name|'in'
name|'tfd'
op|':'
newline|'\n'
indent|'                    '
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'tiers_for_dev'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'tier'
name|'in'
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'tier'
name|'not'
name|'in'
name|'replicas_at_tier'
op|':'
newline|'\n'
indent|'                        '
name|'replicas_at_tier'
op|'['
name|'tier'
op|']'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'replicas_at_tier'
op|'['
name|'tier'
op|']'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
comment|'# Now, look for partitions not yet spread out enough and not'
nl|'\n'
comment|'# recently moved.'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'for'
name|'replica'
name|'in'
name|'self'
op|'.'
name|'_replicas_for_part'
op|'('
name|'part'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'dev'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'['
name|'part'
op|']'
op|']'
newline|'\n'
name|'removed_replica'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'dev'
op|'['
string|"'id'"
op|']'
name|'not'
name|'in'
name|'tfd'
op|':'
newline|'\n'
indent|'                    '
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'tiers_for_dev'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'tier'
name|'in'
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'rep_at_tier'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'tier'
name|'in'
name|'replicas_at_tier'
op|':'
newline|'\n'
indent|'                        '
name|'rep_at_tier'
op|'='
name|'replicas_at_tier'
op|'['
name|'tier'
op|']'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'rep_at_tier'
op|'>'
name|'max_allowed_replicas'
op|'['
name|'tier'
op|']'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'>='
nl|'\n'
name|'self'
op|'.'
name|'min_part_hours'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
number|'0'
newline|'\n'
name|'spread_out_parts'
op|'['
name|'part'
op|']'
op|'.'
name|'append'
op|'('
name|'replica'
op|')'
newline|'\n'
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'+='
number|'1'
newline|'\n'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|'-='
number|'1'
newline|'\n'
name|'removed_replica'
op|'='
name|'True'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'removed_replica'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'dev'
op|'['
string|"'id'"
op|']'
name|'not'
name|'in'
name|'tfd'
op|':'
newline|'\n'
indent|'                        '
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'tiers_for_dev'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'tier'
name|'in'
name|'tfd'
op|'['
name|'dev'
op|'['
string|"'id'"
op|']'
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'replicas_at_tier'
op|'['
name|'tier'
op|']'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
comment|'# Last, we gather partitions from devices that are "overweight" because'
nl|'\n'
comment|'# they have more partitions than their parts_wanted.'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'reassign_parts'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
nl|'\n'
comment|'# We randomly pick a new starting point in the "circular" ring of'
nl|'\n'
comment|'# partitions to try to get a better rebalance when called multiple'
nl|'\n'
comment|'# times.'
nl|'\n'
nl|'\n'
name|'start'
op|'='
name|'self'
op|'.'
name|'_last_part_gather_start'
op|'/'
number|'4'
newline|'\n'
name|'start'
op|'+='
name|'random'
op|'.'
name|'randint'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'parts'
op|'/'
number|'2'
op|')'
comment|'# GRAH PEP8!!!'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_last_part_gather_start'
op|'='
name|'start'
newline|'\n'
name|'for'
name|'replica'
op|','
name|'part2dev'
name|'in'
name|'enumerate'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
op|':'
newline|'\n'
comment|"# If we've got a partial replica, start may be out of"
nl|'\n'
comment|'# range. Scale it down so that we get a similar movement'
nl|'\n'
comment|'# pattern (but scaled down) on sequential runs.'
nl|'\n'
indent|'            '
name|'this_start'
op|'='
name|'int'
op|'('
name|'float'
op|'('
name|'start'
op|')'
op|'*'
name|'len'
op|'('
name|'part2dev'
op|')'
op|'/'
name|'self'
op|'.'
name|'parts'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'part'
name|'in'
name|'itertools'
op|'.'
name|'chain'
op|'('
name|'xrange'
op|'('
name|'this_start'
op|','
name|'len'
op|'('
name|'part2dev'
op|')'
op|')'
op|','
nl|'\n'
name|'xrange'
op|'('
number|'0'
op|','
name|'this_start'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'<'
name|'self'
op|'.'
name|'min_part_hours'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'part'
name|'in'
name|'removed_dev_parts'
name|'or'
name|'part'
name|'in'
name|'spread_out_parts'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'dev'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'part2dev'
op|'['
name|'part'
op|']'
op|']'
newline|'\n'
name|'if'
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_last_part_moves'
op|'['
name|'part'
op|']'
op|'='
number|'0'
newline|'\n'
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'+='
number|'1'
newline|'\n'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|'-='
number|'1'
newline|'\n'
name|'reassign_parts'
op|'['
name|'part'
op|']'
op|'.'
name|'append'
op|'('
name|'replica'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'reassign_parts'
op|'.'
name|'update'
op|'('
name|'spread_out_parts'
op|')'
newline|'\n'
name|'reassign_parts'
op|'.'
name|'update'
op|'('
name|'removed_dev_parts'
op|')'
newline|'\n'
nl|'\n'
name|'reassign_parts_list'
op|'='
name|'list'
op|'('
name|'reassign_parts'
op|'.'
name|'iteritems'
op|'('
op|')'
op|')'
newline|'\n'
comment|'# We shuffle the partitions to reassign so we get a more even'
nl|'\n'
comment|'# distribution later. There has been discussion of trying to distribute'
nl|'\n'
comment|'# partitions more "regularly" because that would actually reduce risk'
nl|'\n'
comment|'# but 1) it is really difficult to do this with uneven clusters and 2)'
nl|'\n'
comment|'# it would concentrate load during failure recovery scenarios'
nl|'\n'
comment|'# (increasing risk). The "right" answer has yet to be debated to'
nl|'\n'
comment|'# conclusion, but working code wins for now.'
nl|'\n'
name|'random'
op|'.'
name|'shuffle'
op|'('
name|'reassign_parts_list'
op|')'
newline|'\n'
name|'return'
name|'reassign_parts_list'
newline|'\n'
nl|'\n'
DECL|member|_reassign_parts
dedent|''
name|'def'
name|'_reassign_parts'
op|'('
name|'self'
op|','
name|'reassign_parts'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For an existing ring data set, partitions are reassigned similarly to\n        the initial assignment. The devices are ordered by how many partitions\n        they still want and kept in that order throughout the process. The\n        gathered partitions are iterated through, assigning them to devices\n        according to the "most wanted" while keeping the replicas as "far\n        apart" as possible. Two different regions are considered the\n        farthest-apart things, followed by zones, then different ip/port pairs\n        within a zone; the least-far-apart things are different devices with\n        the same ip/port pair in the same zone.\n\n        If you want more replicas than devices, you won\'t get all your\n        replicas.\n\n        :param reassign_parts: An iterable of (part, replicas_to_replace)\n                               pairs. replicas_to_replace is an iterable of the\n                               replica (an int) to replace for that partition.\n                               replicas_to_replace may be shared for multiple\n                               partitions, so be sure you do not modify it.\n        """'
newline|'\n'
name|'parts_available_in_tier'
op|'='
name|'defaultdict'
op|'('
name|'int'
op|')'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'['
string|"'sort_key'"
op|']'
op|'='
name|'self'
op|'.'
name|'_sort_key_for'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'tiers'
op|'='
name|'tiers_for_dev'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'dev'
op|'['
string|"'tiers'"
op|']'
op|'='
name|'tiers'
newline|'\n'
name|'for'
name|'tier'
name|'in'
name|'tiers'
op|':'
newline|'\n'
comment|'# Note: this represents how many partitions may be assigned to'
nl|'\n'
comment|'# a given tier (region/zone/server/disk). It does not take'
nl|'\n'
comment|'# into account how many partitions a given tier wants to shed.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# If we did not do this, we could have a zone where, at some'
nl|'\n'
comment|'# point during assignment, number-of-parts-to-gain equals'
nl|'\n'
comment|'# number-of-parts-to-shed. At that point, no further placement'
nl|'\n'
comment|'# into that zone would occur since its parts_available_in_tier'
nl|'\n'
comment|'# would be 0. This would happen any time a zone had any device'
nl|'\n'
comment|'# with partitions to shed, which is any time a device is being'
nl|'\n'
comment|'# removed, which is a pretty frequent operation.'
nl|'\n'
indent|'                '
name|'parts_available_in_tier'
op|'['
name|'tier'
op|']'
op|'+='
name|'max'
op|'('
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'available_devs'
op|'='
name|'sorted'
op|'('
op|'('
name|'d'
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
name|'if'
name|'d'
op|'['
string|"'weight'"
op|']'
op|')'
op|','
nl|'\n'
name|'key'
op|'='
name|'lambda'
name|'x'
op|':'
name|'x'
op|'['
string|"'sort_key'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'tier2devs'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'tier2sort_key'
op|'='
name|'defaultdict'
op|'('
name|'tuple'
op|')'
newline|'\n'
name|'tier2dev_sort_key'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'max_tier_depth'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'available_devs'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'tier'
name|'in'
name|'dev'
op|'['
string|"'tiers'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'tier2devs'
op|'['
name|'tier'
op|']'
op|'.'
name|'append'
op|'('
name|'dev'
op|')'
comment|'# <-- starts out sorted!'
newline|'\n'
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|'.'
name|'append'
op|'('
name|'dev'
op|'['
string|"'sort_key'"
op|']'
op|')'
newline|'\n'
name|'tier2sort_key'
op|'['
name|'tier'
op|']'
op|'='
name|'dev'
op|'['
string|"'sort_key'"
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'tier'
op|')'
op|'>'
name|'max_tier_depth'
op|':'
newline|'\n'
indent|'                    '
name|'max_tier_depth'
op|'='
name|'len'
op|'('
name|'tier'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'tier2children_sets'
op|'='
name|'build_tier_tree'
op|'('
name|'available_devs'
op|')'
newline|'\n'
name|'tier2children'
op|'='
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'tier2children_sort_key'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'tiers_list'
op|'='
op|'['
op|'('
op|')'
op|']'
newline|'\n'
name|'depth'
op|'='
number|'1'
newline|'\n'
name|'while'
name|'depth'
op|'<='
name|'max_tier_depth'
op|':'
newline|'\n'
indent|'            '
name|'new_tiers_list'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'tier'
name|'in'
name|'tiers_list'
op|':'
newline|'\n'
indent|'                '
name|'child_tiers'
op|'='
name|'list'
op|'('
name|'tier2children_sets'
op|'['
name|'tier'
op|']'
op|')'
newline|'\n'
name|'child_tiers'
op|'.'
name|'sort'
op|'('
name|'key'
op|'='
name|'tier2sort_key'
op|'.'
name|'__getitem__'
op|')'
newline|'\n'
name|'tier2children'
op|'['
name|'tier'
op|']'
op|'='
name|'child_tiers'
newline|'\n'
name|'tier2children_sort_key'
op|'['
name|'tier'
op|']'
op|'='
name|'map'
op|'('
nl|'\n'
name|'tier2sort_key'
op|'.'
name|'__getitem__'
op|','
name|'child_tiers'
op|')'
newline|'\n'
name|'new_tiers_list'
op|'.'
name|'extend'
op|'('
name|'child_tiers'
op|')'
newline|'\n'
dedent|''
name|'tiers_list'
op|'='
name|'new_tiers_list'
newline|'\n'
name|'depth'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'part'
op|','
name|'replace_replicas'
name|'in'
name|'reassign_parts'
op|':'
newline|'\n'
comment|'# Gather up what other tiers (regions, zones, ip/ports, and'
nl|'\n'
comment|'# devices) the replicas not-to-be-moved are in for this part.'
nl|'\n'
indent|'            '
name|'other_replicas'
op|'='
name|'defaultdict'
op|'('
name|'int'
op|')'
newline|'\n'
name|'occupied_tiers_by_tier_len'
op|'='
name|'defaultdict'
op|'('
name|'set'
op|')'
newline|'\n'
name|'for'
name|'replica'
name|'in'
name|'self'
op|'.'
name|'_replicas_for_part'
op|'('
name|'part'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'replica'
name|'not'
name|'in'
name|'replace_replicas'
op|':'
newline|'\n'
indent|'                    '
name|'dev'
op|'='
name|'self'
op|'.'
name|'devs'
op|'['
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'['
name|'part'
op|']'
op|']'
newline|'\n'
name|'for'
name|'tier'
name|'in'
name|'dev'
op|'['
string|"'tiers'"
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'other_replicas'
op|'['
name|'tier'
op|']'
op|'+='
number|'1'
newline|'\n'
name|'occupied_tiers_by_tier_len'
op|'['
name|'len'
op|'('
name|'tier'
op|')'
op|']'
op|'.'
name|'add'
op|'('
name|'tier'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'for'
name|'replica'
name|'in'
name|'replace_replicas'
op|':'
newline|'\n'
comment|'# Find a new home for this replica'
nl|'\n'
indent|'                '
name|'tier'
op|'='
op|'('
op|')'
newline|'\n'
name|'depth'
op|'='
number|'1'
newline|'\n'
name|'while'
name|'depth'
op|'<='
name|'max_tier_depth'
op|':'
newline|'\n'
comment|'# Order the tiers by how many replicas of this'
nl|'\n'
comment|'# partition they already have. Then, of the ones'
nl|'\n'
comment|'# with the smallest number of replicas and that have'
nl|'\n'
comment|'# room to accept more partitions, pick the tier with'
nl|'\n'
comment|'# the hungriest drive and then continue searching in'
nl|'\n'
comment|'# that subtree.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# There are other strategies we could use here,'
nl|'\n'
comment|'# such as hungriest-tier (i.e. biggest'
nl|'\n'
comment|'# sum-of-parts-wanted) or picking one at random.'
nl|'\n'
comment|'# However, hungriest-drive is what was used here'
nl|'\n'
comment|'# before, and it worked pretty well in practice.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Note that this allocator prioritizes even device'
nl|'\n'
comment|'# filling over dispersion, so if your layout is'
nl|'\n'
comment|'# extremely unbalanced, you may not get the replica'
nl|'\n'
comment|'# dispersion that you expect, and your durability'
nl|'\n'
comment|'# may be lessened.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# This used to be a cute, recursive function, but it's been"
nl|'\n'
comment|'# unrolled for performance.'
nl|'\n'
nl|'\n'
comment|'# We sort the tiers here so that, when we look for a tier'
nl|'\n'
comment|'# with the lowest number of replicas, the first one we'
nl|'\n'
comment|'# find is the one with the hungriest drive (i.e. drive'
nl|'\n'
comment|'# with the largest sort_key value). This lets us'
nl|'\n'
comment|'# short-circuit the search while still ensuring we get the'
nl|'\n'
comment|'# right tier.'
nl|'\n'
indent|'                    '
name|'candidates_with_replicas'
op|'='
name|'occupied_tiers_by_tier_len'
op|'['
name|'len'
op|'('
name|'tier'
op|')'
op|'+'
number|'1'
op|']'
newline|'\n'
nl|'\n'
comment|'# Among the tiers with room for more partitions,'
nl|'\n'
comment|'# find one with the smallest possible number of'
nl|'\n'
comment|'# replicas already in it, breaking ties by which one'
nl|'\n'
comment|'# has the hungriest drive.'
nl|'\n'
name|'candidates_with_room'
op|'='
op|'['
nl|'\n'
name|'t'
name|'for'
name|'t'
name|'in'
name|'tier2children'
op|'['
name|'tier'
op|']'
nl|'\n'
name|'if'
name|'parts_available_in_tier'
op|'['
name|'t'
op|']'
op|'>'
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'candidates_with_room'
op|')'
op|'>'
name|'len'
op|'('
name|'candidates_with_replicas'
op|')'
op|':'
newline|'\n'
comment|'# There exists at least one tier with room for'
nl|'\n'
comment|'# another partition and 0 other replicas already'
nl|'\n'
comment|'# in it, so we can use a faster search. The else'
nl|'\n'
comment|"# branch's search would work here, but it's"
nl|'\n'
comment|'# significantly slower.'
nl|'\n'
indent|'                        '
name|'tier'
op|'='
name|'max'
op|'('
op|'('
name|'t'
name|'for'
name|'t'
name|'in'
name|'candidates_with_room'
nl|'\n'
name|'if'
name|'other_replicas'
op|'['
name|'t'
op|']'
op|'=='
number|'0'
op|')'
op|','
nl|'\n'
name|'key'
op|'='
name|'tier2sort_key'
op|'.'
name|'__getitem__'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'tier'
op|'='
name|'max'
op|'('
name|'candidates_with_room'
op|','
nl|'\n'
name|'key'
op|'='
name|'lambda'
name|'t'
op|':'
op|'('
op|'-'
name|'other_replicas'
op|'['
name|'t'
op|']'
op|','
nl|'\n'
name|'tier2sort_key'
op|'['
name|'t'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'depth'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'dev'
op|'='
name|'tier2devs'
op|'['
name|'tier'
op|']'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|'-='
number|'1'
newline|'\n'
name|'dev'
op|'['
string|"'parts'"
op|']'
op|'+='
number|'1'
newline|'\n'
name|'old_sort_key'
op|'='
name|'dev'
op|'['
string|"'sort_key'"
op|']'
newline|'\n'
name|'new_sort_key'
op|'='
name|'dev'
op|'['
string|"'sort_key'"
op|']'
op|'='
name|'self'
op|'.'
name|'_sort_key_for'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'for'
name|'tier'
name|'in'
name|'dev'
op|'['
string|"'tiers'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'parts_available_in_tier'
op|'['
name|'tier'
op|']'
op|'-='
number|'1'
newline|'\n'
name|'other_replicas'
op|'['
name|'tier'
op|']'
op|'+='
number|'1'
newline|'\n'
name|'occupied_tiers_by_tier_len'
op|'['
name|'len'
op|'('
name|'tier'
op|')'
op|']'
op|'.'
name|'add'
op|'('
name|'tier'
op|')'
newline|'\n'
nl|'\n'
name|'index'
op|'='
name|'bisect'
op|'.'
name|'bisect_left'
op|'('
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|','
nl|'\n'
name|'old_sort_key'
op|')'
newline|'\n'
name|'tier2devs'
op|'['
name|'tier'
op|']'
op|'.'
name|'pop'
op|'('
name|'index'
op|')'
newline|'\n'
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|'.'
name|'pop'
op|'('
name|'index'
op|')'
newline|'\n'
nl|'\n'
name|'new_index'
op|'='
name|'bisect'
op|'.'
name|'bisect_left'
op|'('
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|','
nl|'\n'
name|'new_sort_key'
op|')'
newline|'\n'
name|'tier2devs'
op|'['
name|'tier'
op|']'
op|'.'
name|'insert'
op|'('
name|'new_index'
op|','
name|'dev'
op|')'
newline|'\n'
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|'.'
name|'insert'
op|'('
name|'new_index'
op|','
name|'new_sort_key'
op|')'
newline|'\n'
nl|'\n'
name|'new_last_sort_key'
op|'='
name|'tier2dev_sort_key'
op|'['
name|'tier'
op|']'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'tier2sort_key'
op|'['
name|'tier'
op|']'
op|'='
name|'new_last_sort_key'
newline|'\n'
nl|'\n'
comment|'# Now jiggle tier2children values to keep them sorted'
nl|'\n'
name|'parent_tier'
op|'='
name|'tier'
op|'['
number|'0'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'index'
op|'='
name|'bisect'
op|'.'
name|'bisect_left'
op|'('
nl|'\n'
name|'tier2children_sort_key'
op|'['
name|'parent_tier'
op|']'
op|','
nl|'\n'
name|'old_sort_key'
op|')'
newline|'\n'
name|'popped'
op|'='
name|'tier2children'
op|'['
name|'parent_tier'
op|']'
op|'.'
name|'pop'
op|'('
name|'index'
op|')'
newline|'\n'
name|'tier2children_sort_key'
op|'['
name|'parent_tier'
op|']'
op|'.'
name|'pop'
op|'('
name|'index'
op|')'
newline|'\n'
nl|'\n'
name|'new_index'
op|'='
name|'bisect'
op|'.'
name|'bisect_left'
op|'('
nl|'\n'
name|'tier2children_sort_key'
op|'['
name|'parent_tier'
op|']'
op|','
nl|'\n'
name|'new_last_sort_key'
op|')'
newline|'\n'
name|'tier2children'
op|'['
name|'parent_tier'
op|']'
op|'.'
name|'insert'
op|'('
name|'new_index'
op|','
name|'popped'
op|')'
newline|'\n'
name|'tier2children_sort_key'
op|'['
name|'parent_tier'
op|']'
op|'.'
name|'insert'
op|'('
nl|'\n'
name|'new_index'
op|','
name|'new_last_sort_key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_replica2part2dev'
op|'['
name|'replica'
op|']'
op|'['
name|'part'
op|']'
op|'='
name|'dev'
op|'['
string|"'id'"
op|']'
newline|'\n'
nl|'\n'
comment|'# Just to save memory and keep from accidental reuse.'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'dev'
op|'['
string|"'sort_key'"
op|']'
newline|'\n'
name|'del'
name|'dev'
op|'['
string|"'tiers'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_sort_key_for
name|'def'
name|'_sort_key_for'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'dev'
op|'['
string|"'parts_wanted'"
op|']'
op|','
name|'random'
op|'.'
name|'randint'
op|'('
number|'0'
op|','
number|'0xFFFF'
op|')'
op|','
name|'dev'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_build_max_replicas_by_tier
dedent|''
name|'def'
name|'_build_max_replicas_by_tier'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a dict of (tier: replica_count) for all tiers in the ring.\n\n        There will always be a () entry as the root of the structure, whose\n        replica_count will equal the ring\'s replica_count.\n\n        Then there will be (region,) entries for each region, indicating the\n        maximum number of replicas the region might have for any given\n        partition.\n\n        Next there will be (region, zone) entries for each zone, indicating\n        the maximum number of replicas in a given region and zone.  Anything\n        greater than 1 indicates a partition at slightly elevated risk, as if\n        that zone were to fail multiple replicas of that partition would be\n        unreachable.\n\n        Next there will be (region, zone, ip_port) entries for each node,\n        indicating the maximum number of replicas stored on a node in a given\n        region and zone.  Anything greater than 1 indicates a partition at\n        elevated risk, as if that ip_port were to fail multiple replicas of\n        that partition would be unreachable.\n\n        Last there will be (region, zone, ip_port, device) entries for each\n        device, indicating the maximum number of replicas the device shares\n        with other devices on the same node for any given partition.\n        Anything greater than 1 indicates a partition at serious risk, as the\n        data on that partition will not be stored distinctly at the ring\'s\n        replica_count.\n\n        Example return dict for the common SAIO setup::\n\n            {(): 3.0,\n            (1,): 3.0,\n            (1, 1): 1.0,\n            (1, 1, \'127.0.0.1:6010\'): 1.0,\n            (1, 1, \'127.0.0.1:6010\', 0): 1.0,\n            (1, 2): 1.0,\n            (1, 2, \'127.0.0.1:6020\'): 1.0,\n            (1, 2, \'127.0.0.1:6020\', 1): 1.0,\n            (1, 3): 1.0,\n            (1, 3, \'127.0.0.1:6030\'): 1.0,\n            (1, 3, \'127.0.0.1:6030\', 2): 1.0,\n            (1, 4): 1.0,\n            (1, 4, \'127.0.0.1:6040\'): 1.0,\n            (1, 4, \'127.0.0.1:6040\', 3): 1.0}\n\n        """'
newline|'\n'
comment|'# Used by walk_tree to know what entries to create for each recursive'
nl|'\n'
comment|'# call.'
nl|'\n'
name|'tier2children'
op|'='
name|'build_tier_tree'
op|'('
name|'self'
op|'.'
name|'_iter_devs'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|walk_tree
name|'def'
name|'walk_tree'
op|'('
name|'tier'
op|','
name|'replica_count'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mr'
op|'='
op|'{'
name|'tier'
op|':'
name|'replica_count'
op|'}'
newline|'\n'
name|'if'
name|'tier'
name|'in'
name|'tier2children'
op|':'
newline|'\n'
indent|'                '
name|'subtiers'
op|'='
name|'tier2children'
op|'['
name|'tier'
op|']'
newline|'\n'
name|'for'
name|'subtier'
name|'in'
name|'subtiers'
op|':'
newline|'\n'
indent|'                    '
name|'submax'
op|'='
name|'math'
op|'.'
name|'ceil'
op|'('
name|'float'
op|'('
name|'replica_count'
op|')'
op|'/'
name|'len'
op|'('
name|'subtiers'
op|')'
op|')'
newline|'\n'
name|'mr'
op|'.'
name|'update'
op|'('
name|'walk_tree'
op|'('
name|'subtier'
op|','
name|'submax'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'mr'
newline|'\n'
dedent|''
name|'return'
name|'walk_tree'
op|'('
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'replicas'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_devs_for_part
dedent|''
name|'def'
name|'_devs_for_part'
op|'('
name|'self'
op|','
name|'part'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a list of devices for a specified partition.\n\n        Deliberately includes duplicates.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_replica2part2dev'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'return'
op|'['
name|'self'
op|'.'
name|'devs'
op|'['
name|'part2dev'
op|'['
name|'part'
op|']'
op|']'
nl|'\n'
name|'for'
name|'part2dev'
name|'in'
name|'self'
op|'.'
name|'_replica2part2dev'
nl|'\n'
name|'if'
name|'part'
op|'<'
name|'len'
op|'('
name|'part2dev'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_replicas_for_part
dedent|''
name|'def'
name|'_replicas_for_part'
op|'('
name|'self'
op|','
name|'part'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a list of replicas for a specified partition.\n\n        These can be used as indices into self._replica2part2dev\n        without worrying about IndexErrors.\n        """'
newline|'\n'
name|'return'
op|'['
name|'replica'
name|'for'
name|'replica'
op|','
name|'part2dev'
nl|'\n'
name|'in'
name|'enumerate'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
nl|'\n'
name|'if'
name|'part'
op|'<'
name|'len'
op|'('
name|'part2dev'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_each_part_replica
dedent|''
name|'def'
name|'_each_part_replica'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Generator yielding every (partition, replica) pair in the ring.\n        """'
newline|'\n'
name|'for'
name|'replica'
op|','
name|'part2dev'
name|'in'
name|'enumerate'
op|'('
name|'self'
op|'.'
name|'_replica2part2dev'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'part'
name|'in'
name|'xrange'
op|'('
name|'len'
op|'('
name|'part2dev'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
op|'('
name|'part'
op|','
name|'replica'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|load
name|'def'
name|'load'
op|'('
name|'cls'
op|','
name|'builder_file'
op|','
name|'open'
op|'='
name|'open'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Obtain RingBuilder instance of the provided builder file\n\n        :param builder_file: path to builder file to load\n        :return: RingBuilder instance\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|'='
name|'open'
op|'('
name|'builder_file'
op|','
string|"'rb'"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exceptions'
op|'.'
name|'FileNotFoundError'
op|'('
nl|'\n'
string|"'Ring Builder file does not exist: %s'"
op|'%'
name|'builder_file'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'e'
op|'.'
name|'errno'
name|'in'
op|'['
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'errno'
op|'.'
name|'EACCES'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exceptions'
op|'.'
name|'PermissionError'
op|'('
nl|'\n'
string|"'Ring Builder file cannot be accessed: %s'"
op|'%'
name|'builder_file'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'fp'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'builder'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
comment|'# raise error during unpickling as UnPicklingError'
nl|'\n'
indent|'                    '
name|'raise'
name|'exceptions'
op|'.'
name|'UnPicklingError'
op|'('
nl|'\n'
string|"'Ring Builder file is invalid: %s'"
op|'%'
name|'builder_file'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'builder'
op|','
string|"'devs'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'builder_dict'
op|'='
name|'builder'
newline|'\n'
name|'builder'
op|'='
name|'RingBuilder'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
name|'builder'
op|'.'
name|'copy_from'
op|'('
name|'builder_dict'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'builder'
op|'.'
name|'devs'
op|':'
newline|'\n'
comment|"#really old rings didn't have meta keys"
nl|'\n'
indent|'            '
name|'if'
name|'dev'
name|'and'
string|"'meta'"
name|'not'
name|'in'
name|'dev'
op|':'
newline|'\n'
indent|'                '
name|'dev'
op|'['
string|"'meta'"
op|']'
op|'='
string|"''"
newline|'\n'
comment|"# NOTE(akscram): An old ring builder file don't contain"
nl|'\n'
comment|'#                replication parameters.'
nl|'\n'
dedent|''
name|'if'
name|'dev'
op|':'
newline|'\n'
indent|'                '
name|'if'
string|"'ip'"
name|'in'
name|'dev'
op|':'
newline|'\n'
indent|'                    '
name|'dev'
op|'.'
name|'setdefault'
op|'('
string|"'replication_ip'"
op|','
name|'dev'
op|'['
string|"'ip'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'port'"
name|'in'
name|'dev'
op|':'
newline|'\n'
indent|'                    '
name|'dev'
op|'.'
name|'setdefault'
op|'('
string|"'replication_port'"
op|','
name|'dev'
op|'['
string|"'port'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'builder'
newline|'\n'
nl|'\n'
DECL|member|save
dedent|''
name|'def'
name|'save'
op|'('
name|'self'
op|','
name|'builder_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Serialize this RingBuilder instance to disk.\n\n        :param builder_file: path to builder file to save\n        """'
newline|'\n'
name|'with'
name|'open'
op|'('
name|'builder_file'
op|','
string|"'wb'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'            '
name|'pickle'
op|'.'
name|'dump'
op|'('
name|'self'
op|'.'
name|'to_dict'
op|'('
op|')'
op|','
name|'f'
op|','
name|'protocol'
op|'='
number|'2'
op|')'
newline|'\n'
nl|'\n'
DECL|member|search_devs
dedent|''
dedent|''
name|'def'
name|'search_devs'
op|'('
name|'self'
op|','
name|'search_values'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Search devices by parameters.\n\n        :param search_values: a dictionary with search values to filter\n                              devices, supported parameters are id,\n                              region, zone, ip, port, replication_ip,\n                              replication_port, device, weight, meta\n\n        :returns: list of device dicts\n        """'
newline|'\n'
name|'matched_devs'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dev'
name|'in'
name|'self'
op|'.'
name|'devs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dev'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'matched'
op|'='
name|'True'
newline|'\n'
name|'for'
name|'key'
name|'in'
op|'('
string|"'id'"
op|','
string|"'region'"
op|','
string|"'zone'"
op|','
string|"'ip'"
op|','
string|"'port'"
op|','
string|"'replication_ip'"
op|','
nl|'\n'
string|"'replication_port'"
op|','
string|"'device'"
op|','
string|"'weight'"
op|','
string|"'meta'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'key'
name|'in'
name|'search_values'
op|':'
newline|'\n'
indent|'                    '
name|'value'
op|'='
name|'search_values'
op|'.'
name|'get'
op|'('
name|'key'
op|')'
newline|'\n'
name|'if'
name|'value'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'key'
op|'=='
string|"'meta'"
op|':'
newline|'\n'
indent|'                            '
name|'if'
name|'value'
name|'not'
name|'in'
name|'dev'
op|'.'
name|'get'
op|'('
name|'key'
op|')'
op|':'
newline|'\n'
indent|'                                '
name|'matched'
op|'='
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'dev'
op|'.'
name|'get'
op|'('
name|'key'
op|')'
op|'!='
name|'value'
op|':'
newline|'\n'
indent|'                            '
name|'matched'
op|'='
name|'False'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'matched'
op|':'
newline|'\n'
indent|'                '
name|'matched_devs'
op|'.'
name|'append'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'matched_devs'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
