begin_unit
comment|'# Copyright (c) 2010-2012 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
comment|'# NOTE: swift_conn'
nl|'\n'
comment|"# You'll see swift_conn passed around a few places in this file. This is the"
nl|'\n'
comment|'# source bufferedhttp connection of whatever it is attached to.'
nl|'\n'
comment|'#   It is used when early termination of reading from the connection should'
nl|'\n'
comment|"# happen, such as when a range request is satisfied but there's still more the"
nl|'\n'
comment|'# source connection would like to send. To prevent having to read all the data'
nl|'\n'
comment|'# that could be left, the source connection can be .close() and then reads'
nl|'\n'
comment|'# commence to empty out any buffers.'
nl|'\n'
comment|'#   These shenanigans are to ensure all related objects can be garbage'
nl|'\n'
comment|"# collected. We've seen objects hang around forever otherwise."
nl|'\n'
nl|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'urllib'
op|'.'
name|'parse'
name|'import'
name|'unquote'
op|','
name|'quote'
newline|'\n'
nl|'\n'
name|'import'
name|'collections'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
name|'import'
name|'json'
newline|'\n'
name|'import'
name|'mimetypes'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'math'
newline|'\n'
name|'import'
name|'random'
newline|'\n'
name|'from'
name|'hashlib'
name|'import'
name|'md5'
newline|'\n'
name|'from'
name|'swift'
name|'import'
name|'gettext_'
name|'as'
name|'_'
newline|'\n'
nl|'\n'
name|'from'
name|'greenlet'
name|'import'
name|'GreenletExit'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'GreenPile'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'queue'
name|'import'
name|'Queue'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'timeout'
name|'import'
name|'Timeout'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
op|'('
nl|'\n'
name|'clean_content_type'
op|','
name|'config_true_value'
op|','
name|'ContextPool'
op|','
name|'csv_append'
op|','
nl|'\n'
name|'GreenAsyncPile'
op|','
name|'GreenthreadSafeIterator'
op|','
name|'Timestamp'
op|','
nl|'\n'
name|'normalize_delete_at_timestamp'
op|','
name|'public'
op|','
name|'get_expirer_container'
op|','
nl|'\n'
name|'document_iters_to_http_response_body'
op|','
name|'parse_content_range'
op|','
nl|'\n'
name|'quorum_size'
op|','
name|'reiterate'
op|','
name|'close_if_possible'
op|')'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'bufferedhttp'
name|'import'
name|'http_connect'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'constraints'
name|'import'
name|'check_metadata'
op|','
name|'check_object_creation'
op|','
name|'check_copy_from_header'
op|','
name|'check_destination_header'
op|','
name|'check_account_format'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
name|'import'
name|'constraints'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'ChunkReadTimeout'
op|','
name|'ChunkWriteTimeout'
op|','
name|'ConnectionTimeout'
op|','
name|'ResponseTimeout'
op|','
name|'InsufficientStorage'
op|','
name|'FooterNotSupported'
op|','
name|'MultiphasePUTNotSupported'
op|','
name|'PutterConnectError'
op|','
name|'ChunkReadError'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'header_key_dict'
name|'import'
name|'HeaderKeyDict'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'http'
name|'import'
op|'('
nl|'\n'
name|'is_informational'
op|','
name|'is_success'
op|','
name|'is_client_error'
op|','
name|'is_server_error'
op|','
nl|'\n'
name|'HTTP_CONTINUE'
op|','
name|'HTTP_CREATED'
op|','
name|'HTTP_MULTIPLE_CHOICES'
op|','
nl|'\n'
name|'HTTP_INTERNAL_SERVER_ERROR'
op|','
name|'HTTP_SERVICE_UNAVAILABLE'
op|','
nl|'\n'
name|'HTTP_INSUFFICIENT_STORAGE'
op|','
name|'HTTP_PRECONDITION_FAILED'
op|','
name|'HTTP_CONFLICT'
op|','
nl|'\n'
name|'HTTP_UNPROCESSABLE_ENTITY'
op|')'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'storage_policy'
name|'import'
op|'('
name|'POLICIES'
op|','
name|'REPL_POLICY'
op|','
name|'EC_POLICY'
op|','
nl|'\n'
name|'ECDriverError'
op|','
name|'PolicyError'
op|')'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'proxy'
op|'.'
name|'controllers'
op|'.'
name|'base'
name|'import'
name|'Controller'
op|','
name|'delay_denial'
op|','
name|'cors_validation'
op|','
name|'ResumingGetter'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'swob'
name|'import'
name|'HTTPAccepted'
op|','
name|'HTTPBadRequest'
op|','
name|'HTTPNotFound'
op|','
name|'HTTPPreconditionFailed'
op|','
name|'HTTPRequestEntityTooLarge'
op|','
name|'HTTPRequestTimeout'
op|','
name|'HTTPServerError'
op|','
name|'HTTPServiceUnavailable'
op|','
name|'Request'
op|','
name|'HTTPClientDisconnect'
op|','
name|'HTTPUnprocessableEntity'
op|','
name|'Response'
op|','
name|'HTTPException'
op|','
name|'HTTPRequestedRangeNotSatisfiable'
op|','
name|'Range'
op|','
name|'HTTPInternalServerError'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'request_helpers'
name|'import'
name|'is_sys_or_user_meta'
op|','
name|'is_sys_meta'
op|','
name|'remove_items'
op|','
name|'copy_header_subset'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|copy_headers_into
name|'def'
name|'copy_headers_into'
op|'('
name|'from_r'
op|','
name|'to_r'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Will copy desired headers from from_r to to_r\n    :params from_r: a swob Request or Response\n    :params to_r: a swob Request or Response\n    """'
newline|'\n'
name|'pass_headers'
op|'='
op|'['
string|"'x-delete-at'"
op|']'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'from_r'
op|'.'
name|'headers'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'is_sys_or_user_meta'
op|'('
string|"'object'"
op|','
name|'k'
op|')'
name|'or'
name|'k'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
name|'pass_headers'
op|':'
newline|'\n'
indent|'            '
name|'to_r'
op|'.'
name|'headers'
op|'['
name|'k'
op|']'
op|'='
name|'v'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|check_content_type
dedent|''
dedent|''
dedent|''
name|'def'
name|'check_content_type'
op|'('
name|'req'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'req'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
string|"'swift.content_type_overridden'"
op|')'
name|'and'
string|"';'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'content-type'"
op|','
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'param'
name|'in'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'content-type'"
op|']'
op|'.'
name|'split'
op|'('
string|"';'"
op|')'
op|'['
number|'1'
op|':'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'param'
op|'.'
name|'lstrip'
op|'('
op|')'
op|'.'
name|'startswith'
op|'('
string|"'swift_'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'HTTPBadRequest'
op|'('
string|'"Invalid Content-Type, "'
nl|'\n'
string|'"swift_* is not a valid parameter name."'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ObjectControllerRouter
dedent|''
name|'class'
name|'ObjectControllerRouter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|policy_type_to_controller_map
indent|'    '
name|'policy_type_to_controller_map'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|register
name|'def'
name|'register'
op|'('
name|'cls'
op|','
name|'policy_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Decorator for Storage Policy implemenations to register\n        their ObjectController implementations.\n\n        This also fills in a policy_type attribute on the class.\n        """'
newline|'\n'
DECL|function|register_wrapper
name|'def'
name|'register_wrapper'
op|'('
name|'controller_cls'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'policy_type'
name|'in'
name|'cls'
op|'.'
name|'policy_type_to_controller_map'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
nl|'\n'
string|"'%r is already registered for the policy_type %r'"
op|'%'
op|'('
nl|'\n'
name|'cls'
op|'.'
name|'policy_type_to_controller_map'
op|'['
name|'policy_type'
op|']'
op|','
nl|'\n'
name|'policy_type'
op|')'
op|')'
newline|'\n'
dedent|''
name|'cls'
op|'.'
name|'policy_type_to_controller_map'
op|'['
name|'policy_type'
op|']'
op|'='
name|'controller_cls'
newline|'\n'
name|'controller_cls'
op|'.'
name|'policy_type'
op|'='
name|'policy_type'
newline|'\n'
name|'return'
name|'controller_cls'
newline|'\n'
dedent|''
name|'return'
name|'register_wrapper'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'policy_to_controller_cls'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'policy'
name|'in'
name|'POLICIES'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'policy_to_controller_cls'
op|'['
name|'policy'
op|']'
op|'='
name|'self'
op|'.'
name|'policy_type_to_controller_map'
op|'['
name|'policy'
op|'.'
name|'policy_type'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'policy_to_controller_cls'
op|'['
name|'policy'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseObjectController
dedent|''
dedent|''
name|'class'
name|'BaseObjectController'
op|'('
name|'Controller'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Base WSGI controller for object requests."""'
newline|'\n'
DECL|variable|server_type
name|'server_type'
op|'='
string|"'Object'"
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'app'
op|','
name|'account_name'
op|','
name|'container_name'
op|','
name|'object_name'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Controller'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'app'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'account_name'
op|'='
name|'unquote'
op|'('
name|'account_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'container_name'
op|'='
name|'unquote'
op|'('
name|'container_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'object_name'
op|'='
name|'unquote'
op|'('
name|'object_name'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iter_nodes_local_first
dedent|''
name|'def'
name|'iter_nodes_local_first'
op|'('
name|'self'
op|','
name|'ring'
op|','
name|'partition'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields nodes for a ring partition.\n\n        If the \'write_affinity\' setting is non-empty, then this will yield N\n        local nodes (as defined by the write_affinity setting) first, then the\n        rest of the nodes as normal. It is a re-ordering of the nodes such\n        that the local ones come first; no node is omitted. The effect is\n        that the request will be serviced by local object servers first, but\n        nonlocal ones will be employed if not enough local ones are available.\n\n        :param ring: ring to get nodes from\n        :param partition: ring partition to yield nodes for\n        """'
newline|'\n'
nl|'\n'
name|'is_local'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'write_affinity_is_local_fn'
newline|'\n'
name|'if'
name|'is_local'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'app'
op|'.'
name|'iter_nodes'
op|'('
name|'ring'
op|','
name|'partition'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'primary_nodes'
op|'='
name|'ring'
op|'.'
name|'get_part_nodes'
op|'('
name|'partition'
op|')'
newline|'\n'
name|'num_locals'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'write_affinity_node_count'
op|'('
name|'len'
op|'('
name|'primary_nodes'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'all_nodes'
op|'='
name|'itertools'
op|'.'
name|'chain'
op|'('
name|'primary_nodes'
op|','
nl|'\n'
name|'ring'
op|'.'
name|'get_more_nodes'
op|'('
name|'partition'
op|')'
op|')'
newline|'\n'
name|'first_n_local_nodes'
op|'='
name|'list'
op|'('
name|'itertools'
op|'.'
name|'islice'
op|'('
nl|'\n'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'filter'
op|'('
name|'is_local'
op|','
name|'all_nodes'
op|')'
op|','
name|'num_locals'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# refresh it; it moved when we computed first_n_local_nodes'
nl|'\n'
name|'all_nodes'
op|'='
name|'itertools'
op|'.'
name|'chain'
op|'('
name|'primary_nodes'
op|','
nl|'\n'
name|'ring'
op|'.'
name|'get_more_nodes'
op|'('
name|'partition'
op|')'
op|')'
newline|'\n'
name|'local_first_node_iter'
op|'='
name|'itertools'
op|'.'
name|'chain'
op|'('
nl|'\n'
name|'first_n_local_nodes'
op|','
nl|'\n'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'filter'
op|'('
name|'lambda'
name|'node'
op|':'
name|'node'
name|'not'
name|'in'
name|'first_n_local_nodes'
op|','
nl|'\n'
name|'all_nodes'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'app'
op|'.'
name|'iter_nodes'
op|'('
nl|'\n'
name|'ring'
op|','
name|'partition'
op|','
name|'node_iter'
op|'='
name|'local_first_node_iter'
op|')'
newline|'\n'
nl|'\n'
DECL|member|GETorHEAD
dedent|''
name|'def'
name|'GETorHEAD'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Handle HTTP GET or HEAD requests."""'
newline|'\n'
name|'container_info'
op|'='
name|'self'
op|'.'
name|'container_info'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'req'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'acl'
op|'='
name|'container_info'
op|'['
string|"'read_acl'"
op|']'
newline|'\n'
comment|'# pass the policy index to storage nodes via req header'
nl|'\n'
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|','
nl|'\n'
name|'container_info'
op|'['
string|"'storage_policy'"
op|']'
op|')'
newline|'\n'
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'obj_ring'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'get_object_ring'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Backend-Storage-Policy-Index'"
op|']'
op|'='
name|'policy_index'
newline|'\n'
name|'if'
string|"'swift.authorize'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|':'
newline|'\n'
indent|'            '
name|'aresp'
op|'='
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize'"
op|']'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'aresp'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'aresp'
newline|'\n'
dedent|''
dedent|''
name|'partition'
op|'='
name|'obj_ring'
op|'.'
name|'get_part'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
name|'node_iter'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'iter_nodes'
op|'('
name|'obj_ring'
op|','
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'_reroute'
op|'('
name|'policy'
op|')'
op|'.'
name|'_get_or_head_response'
op|'('
nl|'\n'
name|'req'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"';'"
name|'in'
name|'resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'content-type'"
op|','
string|"''"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'.'
name|'content_type'
op|'='
name|'clean_content_type'
op|'('
nl|'\n'
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'content-type'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|GET
name|'def'
name|'GET'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Handler for HTTP GET requests."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'GETorHEAD'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|HEAD
name|'def'
name|'HEAD'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Handler for HTTP HEAD requests."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'GETorHEAD'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|POST
name|'def'
name|'POST'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""HTTP POST request handler."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'app'
op|'.'
name|'object_post_as_copy'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'method'
op|'='
string|"'PUT'"
newline|'\n'
name|'req'
op|'.'
name|'path_info'
op|'='
string|"'/v1/%s/%s/%s'"
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'Content-Length'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From'"
op|']'
op|'='
name|'quote'
op|'('
string|"'/%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'container_name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'object_name'
op|')'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.post_as_copy'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift_versioned_copy'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'PUT'
op|'('
name|'req'
op|')'
newline|'\n'
comment|"# Older editions returned 202 Accepted on object POSTs, so we'll"
nl|'\n'
comment|'# convert any 201 Created responses to that for compatibility with'
nl|'\n'
comment|'# picky clients.'
nl|'\n'
name|'if'
name|'resp'
op|'.'
name|'status_int'
op|'!='
name|'HTTP_CREATED'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'resp'
newline|'\n'
dedent|''
name|'return'
name|'HTTPAccepted'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'error_response'
op|'='
name|'check_metadata'
op|'('
name|'req'
op|','
string|"'object'"
op|')'
newline|'\n'
name|'if'
name|'error_response'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'error_response'
newline|'\n'
dedent|''
name|'container_info'
op|'='
name|'self'
op|'.'
name|'container_info'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'req'
op|')'
newline|'\n'
name|'container_partition'
op|'='
name|'container_info'
op|'['
string|"'partition'"
op|']'
newline|'\n'
name|'containers'
op|'='
name|'container_info'
op|'['
string|"'nodes'"
op|']'
newline|'\n'
name|'req'
op|'.'
name|'acl'
op|'='
name|'container_info'
op|'['
string|"'write_acl'"
op|']'
newline|'\n'
name|'if'
string|"'swift.authorize'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|':'
newline|'\n'
indent|'                '
name|'aresp'
op|'='
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize'"
op|']'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'aresp'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'aresp'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'containers'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'HTTPNotFound'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'req'
op|','
name|'delete_at_container'
op|','
name|'delete_at_part'
op|','
name|'delete_at_nodes'
op|'='
name|'self'
op|'.'
name|'_config_obj_expiration'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
comment|'# pass the policy index to storage nodes via req header'
nl|'\n'
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|','
nl|'\n'
name|'container_info'
op|'['
string|"'storage_policy'"
op|']'
op|')'
newline|'\n'
name|'obj_ring'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'get_object_ring'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Backend-Storage-Policy-Index'"
op|']'
op|'='
name|'policy_index'
newline|'\n'
name|'partition'
op|','
name|'nodes'
op|'='
name|'obj_ring'
op|'.'
name|'get_nodes'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|'='
name|'Timestamp'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'.'
name|'internal'
newline|'\n'
nl|'\n'
name|'headers'
op|'='
name|'self'
op|'.'
name|'_backend_requests'
op|'('
nl|'\n'
name|'req'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|','
name|'container_partition'
op|','
name|'containers'
op|','
nl|'\n'
name|'delete_at_container'
op|','
name|'delete_at_part'
op|','
name|'delete_at_nodes'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_post_object'
op|'('
name|'req'
op|','
name|'obj_ring'
op|','
name|'partition'
op|','
name|'headers'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_backend_requests
dedent|''
dedent|''
name|'def'
name|'_backend_requests'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'n_outgoing'
op|','
nl|'\n'
name|'container_partition'
op|','
name|'containers'
op|','
nl|'\n'
name|'delete_at_container'
op|'='
name|'None'
op|','
name|'delete_at_partition'
op|'='
name|'None'
op|','
nl|'\n'
name|'delete_at_nodes'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Backend-Storage-Policy-Index'"
op|']'
newline|'\n'
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'headers'
op|'='
op|'['
name|'self'
op|'.'
name|'generate_request_headers'
op|'('
name|'req'
op|','
name|'additional'
op|'='
name|'req'
op|'.'
name|'headers'
op|')'
nl|'\n'
name|'for'
name|'_junk'
name|'in'
name|'range'
op|'('
name|'n_outgoing'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|function|set_container_update
name|'def'
name|'set_container_update'
op|'('
name|'index'
op|','
name|'container'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'headers'
op|'['
name|'index'
op|']'
op|'['
string|"'X-Container-Partition'"
op|']'
op|'='
name|'container_partition'
newline|'\n'
name|'headers'
op|'['
name|'index'
op|']'
op|'['
string|"'X-Container-Host'"
op|']'
op|'='
name|'csv_append'
op|'('
nl|'\n'
name|'headers'
op|'['
name|'index'
op|']'
op|'.'
name|'get'
op|'('
string|"'X-Container-Host'"
op|')'
op|','
nl|'\n'
string|"'%(ip)s:%(port)s'"
op|'%'
name|'container'
op|')'
newline|'\n'
name|'headers'
op|'['
name|'index'
op|']'
op|'['
string|"'X-Container-Device'"
op|']'
op|'='
name|'csv_append'
op|'('
nl|'\n'
name|'headers'
op|'['
name|'index'
op|']'
op|'.'
name|'get'
op|'('
string|"'X-Container-Device'"
op|')'
op|','
nl|'\n'
name|'container'
op|'['
string|"'device'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'i'
op|','
name|'container'
name|'in'
name|'enumerate'
op|'('
name|'containers'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'i'
op|'='
name|'i'
op|'%'
name|'len'
op|'('
name|'headers'
op|')'
newline|'\n'
name|'set_container_update'
op|'('
name|'i'
op|','
name|'container'
op|')'
newline|'\n'
nl|'\n'
comment|'# if # of container_updates is not enough against # of replicas'
nl|'\n'
comment|'# (or fragments). Fill them like as pigeon hole problem.'
nl|'\n'
comment|'# TODO?: apply these to X-Delete-At-Container?'
nl|'\n'
dedent|''
name|'n_updates_needed'
op|'='
name|'min'
op|'('
name|'policy'
op|'.'
name|'quorum'
op|'+'
number|'1'
op|','
name|'n_outgoing'
op|')'
newline|'\n'
name|'container_iter'
op|'='
name|'itertools'
op|'.'
name|'cycle'
op|'('
name|'containers'
op|')'
newline|'\n'
name|'existing_updates'
op|'='
name|'len'
op|'('
name|'containers'
op|')'
newline|'\n'
name|'while'
name|'existing_updates'
op|'<'
name|'n_updates_needed'
op|':'
newline|'\n'
indent|'            '
name|'set_container_update'
op|'('
name|'existing_updates'
op|','
name|'next'
op|'('
name|'container_iter'
op|')'
op|')'
newline|'\n'
name|'existing_updates'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'i'
op|','
name|'node'
name|'in'
name|'enumerate'
op|'('
name|'delete_at_nodes'
name|'or'
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'i'
op|'='
name|'i'
op|'%'
name|'len'
op|'('
name|'headers'
op|')'
newline|'\n'
nl|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'['
string|"'X-Delete-At-Container'"
op|']'
op|'='
name|'delete_at_container'
newline|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'['
string|"'X-Delete-At-Partition'"
op|']'
op|'='
name|'delete_at_partition'
newline|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'['
string|"'X-Delete-At-Host'"
op|']'
op|'='
name|'csv_append'
op|'('
nl|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'.'
name|'get'
op|'('
string|"'X-Delete-At-Host'"
op|')'
op|','
nl|'\n'
string|"'%(ip)s:%(port)s'"
op|'%'
name|'node'
op|')'
newline|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'['
string|"'X-Delete-At-Device'"
op|']'
op|'='
name|'csv_append'
op|'('
nl|'\n'
name|'headers'
op|'['
name|'i'
op|']'
op|'.'
name|'get'
op|'('
string|"'X-Delete-At-Device'"
op|')'
op|','
nl|'\n'
name|'node'
op|'['
string|"'device'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'headers'
newline|'\n'
nl|'\n'
DECL|member|_await_response
dedent|''
name|'def'
name|'_await_response'
op|'('
name|'self'
op|','
name|'conn'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'Timeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'conn'
op|'.'
name|'resp'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'conn'
op|'.'
name|'resp'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'conn'
op|'.'
name|'getresponse'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_conn_response
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_conn_response'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'req'
op|','
name|'logger_thread_locals'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|'='
name|'logger_thread_locals'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'='
name|'self'
op|'.'
name|'_await_response'
op|'('
name|'conn'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'return'
op|'('
name|'conn'
op|','
name|'resp'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|'('
nl|'\n'
name|'conn'
op|'.'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Trying to get final status of PUT to %s'"
op|')'
op|'%'
name|'req'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_put_responses
dedent|''
name|'def'
name|'_get_put_responses'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'conns'
op|','
name|'nodes'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Collect replicated object responses.\n        """'
newline|'\n'
name|'statuses'
op|'='
op|'['
op|']'
newline|'\n'
name|'reasons'
op|'='
op|'['
op|']'
newline|'\n'
name|'bodies'
op|'='
op|'['
op|']'
newline|'\n'
name|'etags'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'pile'
op|'='
name|'GreenAsyncPile'
op|'('
name|'len'
op|'('
name|'conns'
op|')'
op|')'
newline|'\n'
name|'for'
name|'conn'
name|'in'
name|'conns'
op|':'
newline|'\n'
indent|'            '
name|'pile'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_get_conn_response'
op|','
name|'conn'
op|','
nl|'\n'
name|'req'
op|','
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_handle_response
dedent|''
name|'def'
name|'_handle_response'
op|'('
name|'conn'
op|','
name|'response'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'statuses'
op|'.'
name|'append'
op|'('
name|'response'
op|'.'
name|'status'
op|')'
newline|'\n'
name|'reasons'
op|'.'
name|'append'
op|'('
name|'response'
op|'.'
name|'reason'
op|')'
newline|'\n'
name|'bodies'
op|'.'
name|'append'
op|'('
name|'response'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'response'
op|'.'
name|'status'
op|'=='
name|'HTTP_INSUFFICIENT_STORAGE'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_limit'
op|'('
name|'conn'
op|'.'
name|'node'
op|','
nl|'\n'
name|'_'
op|'('
string|"'ERROR Insufficient Storage'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'response'
op|'.'
name|'status'
op|'>='
name|'HTTP_INTERNAL_SERVER_ERROR'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_occurred'
op|'('
nl|'\n'
name|'conn'
op|'.'
name|'node'
op|','
nl|'\n'
name|'_'
op|'('
string|"'ERROR %(status)d %(body)s From Object Server '"
nl|'\n'
string|"'re: %(path)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'status'"
op|':'
name|'response'
op|'.'
name|'status'
op|','
nl|'\n'
string|"'body'"
op|':'
name|'bodies'
op|'['
op|'-'
number|'1'
op|']'
op|'['
op|':'
number|'1024'
op|']'
op|','
string|"'path'"
op|':'
name|'req'
op|'.'
name|'path'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'is_success'
op|'('
name|'response'
op|'.'
name|'status'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'etags'
op|'.'
name|'add'
op|'('
name|'response'
op|'.'
name|'getheader'
op|'('
string|"'etag'"
op|')'
op|'.'
name|'strip'
op|'('
string|'\'"\''
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
op|'('
name|'conn'
op|','
name|'response'
op|')'
name|'in'
name|'pile'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'response'
op|':'
newline|'\n'
indent|'                '
name|'_handle_response'
op|'('
name|'conn'
op|','
name|'response'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'have_quorum'
op|'('
name|'statuses'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
nl|'\n'
comment|'# give any pending requests *some* chance to finish'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'finished_quickly'
op|'='
name|'pile'
op|'.'
name|'waitall'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'post_quorum_timeout'
op|')'
newline|'\n'
name|'for'
op|'('
name|'conn'
op|','
name|'response'
op|')'
name|'in'
name|'finished_quickly'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'response'
op|':'
newline|'\n'
indent|'                '
name|'_handle_response'
op|'('
name|'conn'
op|','
name|'response'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'while'
name|'len'
op|'('
name|'statuses'
op|')'
op|'<'
name|'len'
op|'('
name|'nodes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'statuses'
op|'.'
name|'append'
op|'('
name|'HTTP_SERVICE_UNAVAILABLE'
op|')'
newline|'\n'
name|'reasons'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
name|'bodies'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
name|'etags'
newline|'\n'
nl|'\n'
DECL|member|_config_obj_expiration
dedent|''
name|'def'
name|'_config_obj_expiration'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'delete_at_container'
op|'='
name|'None'
newline|'\n'
name|'delete_at_part'
op|'='
name|'None'
newline|'\n'
name|'delete_at_nodes'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'req'
op|'='
name|'constraints'
op|'.'
name|'check_delete_headers'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'x-delete-at'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'x_delete_at'
op|'='
name|'int'
op|'('
name|'normalize_delete_at_timestamp'
op|'('
nl|'\n'
name|'int'
op|'('
name|'req'
op|'.'
name|'headers'
op|'['
string|"'x-delete-at'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'environ'
op|'.'
name|'setdefault'
op|'('
string|"'swift.log_info'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
nl|'\n'
string|"'x-delete-at:%s'"
op|'%'
name|'x_delete_at'
op|')'
newline|'\n'
nl|'\n'
name|'delete_at_container'
op|'='
name|'get_expirer_container'
op|'('
nl|'\n'
name|'x_delete_at'
op|','
name|'self'
op|'.'
name|'app'
op|'.'
name|'expiring_objects_container_divisor'
op|','
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
nl|'\n'
name|'delete_at_part'
op|','
name|'delete_at_nodes'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'container_ring'
op|'.'
name|'get_nodes'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'expiring_objects_account'
op|','
name|'delete_at_container'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'req'
op|','
name|'delete_at_container'
op|','
name|'delete_at_part'
op|','
name|'delete_at_nodes'
newline|'\n'
nl|'\n'
DECL|member|_handle_copy_request
dedent|''
name|'def'
name|'_handle_copy_request'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This method handles copying objects based on values set in the headers\n        \'X-Copy-From\' and \'X-Copy-From-Account\'\n\n        Note that if the incomming request has some conditional headers (e.g.\n        \'Range\', \'If-Match\'), *source* object will be evaluated for these\n        headers. i.e. if PUT with both \'X-Copy-From\' and \'Range\', Swift will\n        make a partial copy as a new object.\n\n        This method was added as part of the refactoring of the PUT method and\n        the functionality is expected to be moved to middleware\n        """'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
string|"'swift.orig_req_method'"
op|','
name|'req'
op|'.'
name|'method'
op|')'
op|'!='
string|"'POST'"
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'environ'
op|'.'
name|'setdefault'
op|'('
string|"'swift.log_info'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
nl|'\n'
string|"'x-copy-from:%s'"
op|'%'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'ver'
op|','
name|'acct'
op|','
name|'_rest'
op|'='
name|'req'
op|'.'
name|'split_path'
op|'('
number|'2'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
name|'src_account_name'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Copy-From-Account'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'src_account_name'
op|':'
newline|'\n'
indent|'            '
name|'src_account_name'
op|'='
name|'check_account_format'
op|'('
name|'req'
op|','
name|'src_account_name'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'src_account_name'
op|'='
name|'acct'
newline|'\n'
dedent|''
name|'src_container_name'
op|','
name|'src_obj_name'
op|'='
name|'check_copy_from_header'
op|'('
name|'req'
op|')'
newline|'\n'
name|'source_header'
op|'='
string|"'/%s/%s/%s/%s'"
op|'%'
op|'('
nl|'\n'
name|'ver'
op|','
name|'src_account_name'
op|','
name|'src_container_name'
op|','
name|'src_obj_name'
op|')'
newline|'\n'
name|'source_req'
op|'='
name|'req'
op|'.'
name|'copy_get'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# make sure the source request uses it's container_info"
nl|'\n'
name|'source_req'
op|'.'
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|','
name|'None'
op|')'
newline|'\n'
name|'source_req'
op|'.'
name|'path_info'
op|'='
name|'source_header'
newline|'\n'
name|'source_req'
op|'.'
name|'headers'
op|'['
string|"'X-Newest'"
op|']'
op|'='
string|"'true'"
newline|'\n'
name|'if'
string|"'swift.post_as_copy'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|':'
newline|'\n'
comment|"# We're COPYing one object over itself because of a POST; rely on"
nl|'\n'
comment|"# the PUT for write authorization, don't require read authorization"
nl|'\n'
indent|'            '
name|'source_req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize'"
op|']'
op|'='
name|'lambda'
name|'req'
op|':'
name|'None'
newline|'\n'
name|'source_req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize_override'"
op|']'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'orig_obj_name'
op|'='
name|'self'
op|'.'
name|'object_name'
newline|'\n'
name|'orig_container_name'
op|'='
name|'self'
op|'.'
name|'container_name'
newline|'\n'
name|'orig_account_name'
op|'='
name|'self'
op|'.'
name|'account_name'
newline|'\n'
name|'sink_req'
op|'='
name|'Request'
op|'.'
name|'blank'
op|'('
name|'req'
op|'.'
name|'path_info'
op|','
nl|'\n'
name|'environ'
op|'='
name|'req'
op|'.'
name|'environ'
op|','
name|'headers'
op|'='
name|'req'
op|'.'
name|'headers'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'object_name'
op|'='
name|'src_obj_name'
newline|'\n'
name|'self'
op|'.'
name|'container_name'
op|'='
name|'src_container_name'
newline|'\n'
name|'self'
op|'.'
name|'account_name'
op|'='
name|'src_account_name'
newline|'\n'
nl|'\n'
name|'source_resp'
op|'='
name|'self'
op|'.'
name|'GET'
op|'('
name|'source_req'
op|')'
newline|'\n'
nl|'\n'
comment|'# This gives middlewares a way to change the source; for example,'
nl|'\n'
comment|'# this lets you COPY a SLO manifest and have the new object be the'
nl|'\n'
comment|'# concatenation of the segments (like what a GET request gives'
nl|'\n'
comment|'# the client), not a copy of the manifest file.'
nl|'\n'
name|'hook'
op|'='
name|'req'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'swift.copy_hook'"
op|','
nl|'\n'
op|'('
name|'lambda'
name|'source_req'
op|','
name|'source_resp'
op|','
name|'sink_req'
op|':'
name|'source_resp'
op|')'
op|')'
newline|'\n'
name|'source_resp'
op|'='
name|'hook'
op|'('
name|'source_req'
op|','
name|'source_resp'
op|','
name|'sink_req'
op|')'
newline|'\n'
nl|'\n'
comment|'# reset names'
nl|'\n'
name|'self'
op|'.'
name|'object_name'
op|'='
name|'orig_obj_name'
newline|'\n'
name|'self'
op|'.'
name|'container_name'
op|'='
name|'orig_container_name'
newline|'\n'
name|'self'
op|'.'
name|'account_name'
op|'='
name|'orig_account_name'
newline|'\n'
nl|'\n'
name|'if'
name|'source_resp'
op|'.'
name|'status_int'
op|'>='
name|'HTTP_MULTIPLE_CHOICES'
op|':'
newline|'\n'
comment|"# this is a bit of ugly code, but I'm willing to live with it"
nl|'\n'
comment|'# until copy request handling moves to middleware'
nl|'\n'
indent|'            '
name|'return'
name|'source_resp'
op|','
name|'None'
op|','
name|'None'
op|','
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'source_resp'
op|'.'
name|'content_length'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# This indicates a transfer-encoding: chunked source object,'
nl|'\n'
comment|'# which currently only happens because there are more than'
nl|'\n'
comment|'# CONTAINER_LISTING_LIMIT segments in a segmented object. In'
nl|'\n'
comment|"# this case, we're going to refuse to do the server-side copy."
nl|'\n'
indent|'            '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'source_resp'
op|'.'
name|'content_length'
op|'>'
name|'constraints'
op|'.'
name|'MAX_FILE_SIZE'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'data_source'
op|'='
name|'iter'
op|'('
name|'source_resp'
op|'.'
name|'app_iter'
op|')'
newline|'\n'
name|'sink_req'
op|'.'
name|'content_length'
op|'='
name|'source_resp'
op|'.'
name|'content_length'
newline|'\n'
name|'sink_req'
op|'.'
name|'etag'
op|'='
name|'source_resp'
op|'.'
name|'etag'
newline|'\n'
nl|'\n'
comment|'# we no longer need the X-Copy-From header'
nl|'\n'
name|'del'
name|'sink_req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From'"
op|']'
newline|'\n'
name|'if'
string|"'X-Copy-From-Account'"
name|'in'
name|'sink_req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'sink_req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From-Account'"
op|']'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'req'
op|'.'
name|'content_type_manually_set'
op|':'
newline|'\n'
indent|'            '
name|'sink_req'
op|'.'
name|'headers'
op|'['
string|"'Content-Type'"
op|']'
op|'='
name|'source_resp'
op|'.'
name|'headers'
op|'['
string|"'Content-Type'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'fresh_meta_flag'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'sink_req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'x-fresh-metadata'"
op|','
string|"'false'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fresh_meta_flag'
name|'or'
string|"'swift.post_as_copy'"
name|'in'
name|'sink_req'
op|'.'
name|'environ'
op|':'
newline|'\n'
comment|'# post-as-copy: ignore new sysmeta, copy existing sysmeta'
nl|'\n'
indent|'            '
name|'condition'
op|'='
name|'lambda'
name|'k'
op|':'
name|'is_sys_meta'
op|'('
string|"'object'"
op|','
name|'k'
op|')'
newline|'\n'
name|'remove_items'
op|'('
name|'sink_req'
op|'.'
name|'headers'
op|','
name|'condition'
op|')'
newline|'\n'
name|'copy_header_subset'
op|'('
name|'source_resp'
op|','
name|'sink_req'
op|','
name|'condition'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# copy/update existing sysmeta and user meta'
nl|'\n'
indent|'            '
name|'copy_headers_into'
op|'('
name|'source_resp'
op|','
name|'sink_req'
op|')'
newline|'\n'
name|'copy_headers_into'
op|'('
name|'req'
op|','
name|'sink_req'
op|')'
newline|'\n'
nl|'\n'
comment|'# copy over x-static-large-object for POSTs and manifest copies'
nl|'\n'
dedent|''
name|'if'
string|"'X-Static-Large-Object'"
name|'in'
name|'source_resp'
op|'.'
name|'headers'
name|'and'
op|'('
name|'req'
op|'.'
name|'params'
op|'.'
name|'get'
op|'('
string|"'multipart-manifest'"
op|')'
op|'=='
string|"'get'"
name|'or'
nl|'\n'
string|"'swift.post_as_copy'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'sink_req'
op|'.'
name|'headers'
op|'['
string|"'X-Static-Large-Object'"
op|']'
op|'='
name|'source_resp'
op|'.'
name|'headers'
op|'['
string|"'X-Static-Large-Object'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'req'
op|'='
name|'sink_req'
newline|'\n'
nl|'\n'
DECL|function|update_response
name|'def'
name|'update_response'
op|'('
name|'req'
op|','
name|'resp'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'acct'
op|','
name|'path'
op|'='
name|'source_resp'
op|'.'
name|'environ'
op|'['
string|"'PATH_INFO'"
op|']'
op|'.'
name|'split'
op|'('
string|"'/'"
op|','
number|'3'
op|')'
op|'['
number|'2'
op|':'
number|'4'
op|']'
newline|'\n'
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'X-Copied-From-Account'"
op|']'
op|'='
name|'quote'
op|'('
name|'acct'
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'X-Copied-From'"
op|']'
op|'='
name|'quote'
op|'('
name|'path'
op|')'
newline|'\n'
name|'if'
string|"'last-modified'"
name|'in'
name|'source_resp'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'                '
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'X-Copied-From-Last-Modified'"
op|']'
op|'='
name|'source_resp'
op|'.'
name|'headers'
op|'['
string|"'last-modified'"
op|']'
newline|'\n'
dedent|''
name|'copy_headers_into'
op|'('
name|'req'
op|','
name|'resp'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
comment|"# this is a bit of ugly code, but I'm willing to live with it"
nl|'\n'
comment|'# until copy request handling moves to middleware'
nl|'\n'
dedent|''
name|'return'
name|'None'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'update_response'
newline|'\n'
nl|'\n'
DECL|member|_update_content_type
dedent|''
name|'def'
name|'_update_content_type'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
comment|"# Sometimes the 'content-type' header exists, but is set to None."
nl|'\n'
indent|'        '
name|'req'
op|'.'
name|'content_type_manually_set'
op|'='
name|'True'
newline|'\n'
name|'detect_content_type'
op|'='
name|'config_true_value'
op|'('
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'x-detect-content-type'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'detect_content_type'
name|'or'
name|'not'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'content-type'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guessed_type'
op|','
name|'_junk'
op|'='
name|'mimetypes'
op|'.'
name|'guess_type'
op|'('
name|'req'
op|'.'
name|'path_info'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'Content-Type'"
op|']'
op|'='
name|'guessed_type'
name|'or'
string|"'application/octet-stream'"
newline|'\n'
name|'if'
name|'detect_content_type'
op|':'
newline|'\n'
indent|'                '
name|'req'
op|'.'
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'x-detect-content-type'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'req'
op|'.'
name|'content_type_manually_set'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_update_x_timestamp
dedent|''
dedent|''
dedent|''
name|'def'
name|'_update_x_timestamp'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
comment|'# Used by container sync feature'
nl|'\n'
indent|'        '
name|'if'
string|"'x-timestamp'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'req_timestamp'
op|'='
name|'Timestamp'
op|'('
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'HTTPBadRequest'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
name|'content_type'
op|'='
string|"'text/plain'"
op|','
nl|'\n'
name|'body'
op|'='
string|"'X-Timestamp should be a UNIX timestamp float value; '"
nl|'\n'
string|"'was %r'"
op|'%'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'x-timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|'='
name|'req_timestamp'
op|'.'
name|'internal'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|'='
name|'Timestamp'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'.'
name|'internal'
newline|'\n'
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|_check_failure_put_connections
dedent|''
name|'def'
name|'_check_failure_put_connections'
op|'('
name|'self'
op|','
name|'conns'
op|','
name|'req'
op|','
name|'nodes'
op|','
name|'min_conns'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Identify any failed connections and check minimum connection count.\n        """'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'if_none_match'
name|'is'
name|'not'
name|'None'
name|'and'
string|"'*'"
name|'in'
name|'req'
op|'.'
name|'if_none_match'
op|':'
newline|'\n'
indent|'            '
name|'statuses'
op|'='
op|'['
name|'conn'
op|'.'
name|'resp'
op|'.'
name|'status'
name|'for'
name|'conn'
name|'in'
name|'conns'
name|'if'
name|'conn'
op|'.'
name|'resp'
op|']'
newline|'\n'
name|'if'
name|'HTTP_PRECONDITION_FAILED'
name|'in'
name|'statuses'
op|':'
newline|'\n'
comment|"# If we find any copy of the file, it shouldn't be uploaded"
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Object PUT returning 412, %(statuses)r'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'statuses'"
op|':'
name|'statuses'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'HTTPPreconditionFailed'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'any'
op|'('
name|'conn'
name|'for'
name|'conn'
name|'in'
name|'conns'
name|'if'
name|'conn'
op|'.'
name|'resp'
name|'and'
nl|'\n'
name|'conn'
op|'.'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_CONFLICT'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'status_times'
op|'='
op|'['
string|"'%(status)s (%(timestamp)s)'"
op|'%'
op|'{'
nl|'\n'
string|"'status'"
op|':'
name|'conn'
op|'.'
name|'resp'
op|'.'
name|'status'
op|','
nl|'\n'
string|"'timestamp'"
op|':'
name|'HeaderKeyDict'
op|'('
nl|'\n'
name|'conn'
op|'.'
name|'resp'
op|'.'
name|'getheaders'
op|'('
op|')'
op|')'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'X-Backend-Timestamp'"
op|','
string|"'unknown'"
op|')'
nl|'\n'
op|'}'
name|'for'
name|'conn'
name|'in'
name|'conns'
name|'if'
name|'conn'
op|'.'
name|'resp'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Object PUT returning 202 for 409: '"
nl|'\n'
string|"'%(req_timestamp)s <= %(timestamps)r'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'req_timestamp'"
op|':'
name|'req'
op|'.'
name|'timestamp'
op|'.'
name|'internal'
op|','
nl|'\n'
string|"'timestamps'"
op|':'
string|"', '"
op|'.'
name|'join'
op|'('
name|'status_times'
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'HTTPAccepted'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_check_min_conn'
op|'('
name|'req'
op|','
name|'conns'
op|','
name|'min_conns'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_connect_put_node
dedent|''
name|'def'
name|'_connect_put_node'
op|'('
name|'self'
op|','
name|'nodes'
op|','
name|'part'
op|','
name|'path'
op|','
name|'headers'
op|','
nl|'\n'
name|'logger_thread_locals'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make connection to storage nodes\n\n        Connects to the first working node that it finds in nodes iter\n        and sends over the request headers. Returns an HTTPConnection\n        object to handle the rest of the streaming.\n\n        This method must be implemented by each policy ObjectController.\n\n        :param nodes: an iterator of the target storage nodes\n        :param partition: ring partition number\n        :param path: the object path to send to the storage node\n        :param headers: request headers\n        :param logger_thread_locals: The thread local values to be set on the\n                                     self.app.logger to retain transaction\n                                     logging information.\n        :return: HTTPConnection object\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_put_connections
dedent|''
name|'def'
name|'_get_put_connections'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'nodes'
op|','
name|'partition'
op|','
name|'outgoing_headers'
op|','
nl|'\n'
name|'policy'
op|','
name|'expect'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Establish connections to storage nodes for PUT request\n        """'
newline|'\n'
name|'obj_ring'
op|'='
name|'policy'
op|'.'
name|'object_ring'
newline|'\n'
name|'node_iter'
op|'='
name|'GreenthreadSafeIterator'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'iter_nodes_local_first'
op|'('
name|'obj_ring'
op|','
name|'partition'
op|')'
op|')'
newline|'\n'
name|'pile'
op|'='
name|'GreenPile'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'nheaders'
name|'in'
name|'outgoing_headers'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'expect'
op|':'
newline|'\n'
indent|'                '
name|'nheaders'
op|'['
string|"'Expect'"
op|']'
op|'='
string|"'100-continue'"
newline|'\n'
dedent|''
name|'pile'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_connect_put_node'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
nl|'\n'
name|'req'
op|'.'
name|'swift_entity_path'
op|','
name|'nheaders'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'conns'
op|'='
op|'['
name|'conn'
name|'for'
name|'conn'
name|'in'
name|'pile'
name|'if'
name|'conn'
op|']'
newline|'\n'
nl|'\n'
name|'return'
name|'conns'
newline|'\n'
nl|'\n'
DECL|member|_check_min_conn
dedent|''
name|'def'
name|'_check_min_conn'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'conns'
op|','
name|'min_conns'
op|','
name|'msg'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'msg'
name|'or'
string|"'Object PUT returning 503, %(conns)s/%(nodes)s '"
string|"'required connections'"
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'conns'
op|')'
op|'<'
name|'min_conns'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
op|'('
name|'msg'
op|')'
op|','
nl|'\n'
op|'{'
string|"'conns'"
op|':'
name|'len'
op|'('
name|'conns'
op|')'
op|','
string|"'nodes'"
op|':'
name|'min_conns'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'HTTPServiceUnavailable'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_store_object
dedent|''
dedent|''
name|'def'
name|'_store_object'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'nodes'
op|','
name|'partition'
op|','
nl|'\n'
name|'outgoing_headers'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This method is responsible for establishing connection\n        with storage nodes and sending the data to each one of those\n        nodes. The process of transferring data is specific to each\n        Storage Policy, thus it is required for each policy specific\n        ObjectController to provide their own implementation of this method.\n\n        :param req: the PUT Request\n        :param data_source: an iterator of the source of the data\n        :param nodes: an iterator of the target storage nodes\n        :param partition: ring partition number\n        :param outgoing_headers: system headers to storage nodes\n        :return: Response object\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete_object
dedent|''
name|'def'
name|'_delete_object'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'obj_ring'
op|','
name|'partition'
op|','
name|'headers'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        send object DELETE request to storage nodes. Subclasses of\n        the BaseObjectController can provide their own implementation\n        of this method.\n\n        :param req: the DELETE Request\n        :param obj_ring: the object ring\n        :param partition: ring partition number\n        :param headers: system headers to storage nodes\n        :return: Response object\n        """'
newline|'\n'
comment|'# When deleting objects treat a 404 status as 204.'
nl|'\n'
name|'status_overrides'
op|'='
op|'{'
number|'404'
op|':'
number|'204'
op|'}'
newline|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'make_requests'
op|'('
name|'req'
op|','
name|'obj_ring'
op|','
nl|'\n'
name|'partition'
op|','
string|"'DELETE'"
op|','
name|'req'
op|'.'
name|'swift_entity_path'
op|','
nl|'\n'
name|'headers'
op|','
name|'overrides'
op|'='
name|'status_overrides'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
DECL|member|_post_object
dedent|''
name|'def'
name|'_post_object'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'obj_ring'
op|','
name|'partition'
op|','
name|'headers'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        send object POST request to storage nodes.\n\n        :param req: the POST Request\n        :param obj_ring: the object ring\n        :param partition: ring partition number\n        :param headers: system headers to storage nodes\n        :return: Response object\n        """'
newline|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'make_requests'
op|'('
name|'req'
op|','
name|'obj_ring'
op|','
name|'partition'
op|','
nl|'\n'
string|"'POST'"
op|','
name|'req'
op|'.'
name|'swift_entity_path'
op|','
name|'headers'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|PUT
name|'def'
name|'PUT'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""HTTP PUT request handler."""'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'if_none_match'
name|'is'
name|'not'
name|'None'
name|'and'
string|"'*'"
name|'not'
name|'in'
name|'req'
op|'.'
name|'if_none_match'
op|':'
newline|'\n'
comment|"# Sending an etag with if-none-match isn't currently supported"
nl|'\n'
indent|'            '
name|'return'
name|'HTTPBadRequest'
op|'('
name|'request'
op|'='
name|'req'
op|','
name|'content_type'
op|'='
string|"'text/plain'"
op|','
nl|'\n'
name|'body'
op|'='
string|"'If-None-Match only supports *'"
op|')'
newline|'\n'
dedent|''
name|'container_info'
op|'='
name|'self'
op|'.'
name|'container_info'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'req'
op|')'
newline|'\n'
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|','
nl|'\n'
name|'container_info'
op|'['
string|"'storage_policy'"
op|']'
op|')'
newline|'\n'
name|'obj_ring'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'get_object_ring'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'container_nodes'
op|'='
name|'container_info'
op|'['
string|"'nodes'"
op|']'
newline|'\n'
name|'container_partition'
op|'='
name|'container_info'
op|'['
string|"'partition'"
op|']'
newline|'\n'
name|'partition'
op|','
name|'nodes'
op|'='
name|'obj_ring'
op|'.'
name|'get_nodes'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# pass the policy index to storage nodes via req header'
nl|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Backend-Storage-Policy-Index'"
op|']'
op|'='
name|'policy_index'
newline|'\n'
name|'req'
op|'.'
name|'acl'
op|'='
name|'container_info'
op|'['
string|"'write_acl'"
op|']'
newline|'\n'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift_sync_key'"
op|']'
op|'='
name|'container_info'
op|'['
string|"'sync_key'"
op|']'
newline|'\n'
nl|'\n'
comment|'# is request authorized'
nl|'\n'
name|'if'
string|"'swift.authorize'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|':'
newline|'\n'
indent|'            '
name|'aresp'
op|'='
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize'"
op|']'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'aresp'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'aresp'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'container_info'
op|'['
string|"'nodes'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPNotFound'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
comment|'# update content type in case it is missing'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_update_content_type'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
comment|'# check constraints on object name and request headers'
nl|'\n'
name|'error_response'
op|'='
name|'check_object_creation'
op|'('
name|'req'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
name|'or'
name|'check_content_type'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'error_response'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'error_response'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_update_x_timestamp'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
comment|'# check if request is a COPY of an existing object'
nl|'\n'
name|'source_header'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Copy-From'"
op|')'
newline|'\n'
name|'if'
name|'source_header'
op|':'
newline|'\n'
indent|'            '
name|'error_response'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'update_response'
op|'='
name|'self'
op|'.'
name|'_handle_copy_request'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'error_response'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'error_response'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|function|reader
indent|'            '
name|'def'
name|'reader'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'wsgi.input'"
op|']'
op|'.'
name|'read'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'client_chunk_size'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'IOError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ChunkReadError'
op|'('
name|'str'
op|'('
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'data_source'
op|'='
name|'iter'
op|'('
name|'reader'
op|','
string|"''"
op|')'
newline|'\n'
name|'update_response'
op|'='
name|'lambda'
name|'req'
op|','
name|'resp'
op|':'
name|'resp'
newline|'\n'
nl|'\n'
comment|'# check if object is set to be automatically deleted (i.e. expired)'
nl|'\n'
dedent|''
name|'req'
op|','
name|'delete_at_container'
op|','
name|'delete_at_part'
op|','
name|'delete_at_nodes'
op|'='
name|'self'
op|'.'
name|'_config_obj_expiration'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
comment|'# add special headers to be handled by storage nodes'
nl|'\n'
name|'outgoing_headers'
op|'='
name|'self'
op|'.'
name|'_backend_requests'
op|'('
nl|'\n'
name|'req'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|','
name|'container_partition'
op|','
name|'container_nodes'
op|','
nl|'\n'
name|'delete_at_container'
op|','
name|'delete_at_part'
op|','
name|'delete_at_nodes'
op|')'
newline|'\n'
nl|'\n'
comment|'# send object to storage nodes'
nl|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'_store_object'
op|'('
nl|'\n'
name|'req'
op|','
name|'data_source'
op|','
name|'nodes'
op|','
name|'partition'
op|','
name|'outgoing_headers'
op|')'
newline|'\n'
name|'return'
name|'update_response'
op|'('
name|'req'
op|','
name|'resp'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|DELETE
name|'def'
name|'DELETE'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""HTTP DELETE request handler."""'
newline|'\n'
name|'container_info'
op|'='
name|'self'
op|'.'
name|'container_info'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'req'
op|')'
newline|'\n'
comment|'# pass the policy index to storage nodes via req header'
nl|'\n'
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|','
nl|'\n'
name|'container_info'
op|'['
string|"'storage_policy'"
op|']'
op|')'
newline|'\n'
name|'obj_ring'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'get_object_ring'
op|'('
name|'policy_index'
op|')'
newline|'\n'
comment|'# pass the policy index to storage nodes via req header'
nl|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Backend-Storage-Policy-Index'"
op|']'
op|'='
name|'policy_index'
newline|'\n'
name|'container_partition'
op|'='
name|'container_info'
op|'['
string|"'partition'"
op|']'
newline|'\n'
name|'containers'
op|'='
name|'container_info'
op|'['
string|"'nodes'"
op|']'
newline|'\n'
name|'req'
op|'.'
name|'acl'
op|'='
name|'container_info'
op|'['
string|"'write_acl'"
op|']'
newline|'\n'
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift_sync_key'"
op|']'
op|'='
name|'container_info'
op|'['
string|"'sync_key'"
op|']'
newline|'\n'
name|'if'
string|"'swift.authorize'"
name|'in'
name|'req'
op|'.'
name|'environ'
op|':'
newline|'\n'
indent|'            '
name|'aresp'
op|'='
name|'req'
op|'.'
name|'environ'
op|'['
string|"'swift.authorize'"
op|']'
op|'('
name|'req'
op|')'
newline|'\n'
name|'if'
name|'aresp'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'aresp'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'containers'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPNotFound'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'partition'
op|','
name|'nodes'
op|'='
name|'obj_ring'
op|'.'
name|'get_nodes'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
comment|'# Used by container sync feature'
nl|'\n'
name|'if'
string|"'x-timestamp'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'req_timestamp'
op|'='
name|'Timestamp'
op|'('
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'HTTPBadRequest'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
name|'content_type'
op|'='
string|"'text/plain'"
op|','
nl|'\n'
name|'body'
op|'='
string|"'X-Timestamp should be a UNIX timestamp float value; '"
nl|'\n'
string|"'was %r'"
op|'%'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'x-timestamp'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|'='
name|'req_timestamp'
op|'.'
name|'internal'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|'='
name|'Timestamp'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'.'
name|'internal'
newline|'\n'
nl|'\n'
dedent|''
name|'headers'
op|'='
name|'self'
op|'.'
name|'_backend_requests'
op|'('
nl|'\n'
name|'req'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|','
name|'container_partition'
op|','
name|'containers'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_delete_object'
op|'('
name|'req'
op|','
name|'obj_ring'
op|','
name|'partition'
op|','
name|'headers'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_reroute
dedent|''
name|'def'
name|'_reroute'
op|'('
name|'self'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For COPY requests we need to make sure the controller instance the\n        request is routed through is the correct type for the policy.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'policy'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'HTTPServiceUnavailable'
op|'('
string|"'Unknown Storage Policy'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'policy'
op|'.'
name|'policy_type'
op|'!='
name|'self'
op|'.'
name|'policy_type'
op|':'
newline|'\n'
indent|'            '
name|'controller'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'obj_controller_router'
op|'['
name|'policy'
op|']'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'app'
op|','
name|'self'
op|'.'
name|'account_name'
op|','
name|'self'
op|'.'
name|'container_name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'controller'
op|'='
name|'self'
newline|'\n'
dedent|''
name|'return'
name|'controller'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'public'
newline|'\n'
op|'@'
name|'cors_validation'
newline|'\n'
op|'@'
name|'delay_denial'
newline|'\n'
DECL|member|COPY
name|'def'
name|'COPY'
op|'('
name|'self'
op|','
name|'req'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""HTTP COPY request handler."""'
newline|'\n'
name|'if'
name|'not'
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'Destination'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPPreconditionFailed'
op|'('
name|'request'
op|'='
name|'req'
op|','
nl|'\n'
name|'body'
op|'='
string|"'Destination header required'"
op|')'
newline|'\n'
dedent|''
name|'dest_account'
op|'='
name|'self'
op|'.'
name|'account_name'
newline|'\n'
name|'if'
string|"'Destination-Account'"
name|'in'
name|'req'
op|'.'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'dest_account'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'Destination-Account'"
op|')'
newline|'\n'
name|'dest_account'
op|'='
name|'check_account_format'
op|'('
name|'req'
op|','
name|'dest_account'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From-Account'"
op|']'
op|'='
name|'self'
op|'.'
name|'account_name'
newline|'\n'
name|'self'
op|'.'
name|'account_name'
op|'='
name|'dest_account'
newline|'\n'
name|'del'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'Destination-Account'"
op|']'
newline|'\n'
dedent|''
name|'dest_container'
op|','
name|'dest_object'
op|'='
name|'check_destination_header'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
name|'source'
op|'='
string|"'/%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'container_name'
op|','
name|'self'
op|'.'
name|'object_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'container_name'
op|'='
name|'dest_container'
newline|'\n'
name|'self'
op|'.'
name|'object_name'
op|'='
name|'dest_object'
newline|'\n'
comment|'# re-write the existing request as a PUT instead of creating a new one'
nl|'\n'
comment|'# since this one is already attached to the posthooklogger'
nl|'\n'
comment|'# TODO: Swift now has proxy-logging middleware instead of'
nl|'\n'
comment|"#       posthooklogger used in before. i.e. we don't have to"
nl|'\n'
comment|'#       keep the code depends on evnetlet.posthooks sequence, IMHO.'
nl|'\n'
comment|'#       However, creating a new sub request might'
nl|'\n'
comment|'#       cause the possibility to hide some bugs behindes the request'
nl|'\n'
comment|'#       so that we should discuss whichi is suitable (new-sub-request'
nl|'\n'
comment|'#       vs re-write-existing-request) for Swift. [kota_]'
nl|'\n'
name|'req'
op|'.'
name|'method'
op|'='
string|"'PUT'"
newline|'\n'
name|'req'
op|'.'
name|'path_info'
op|'='
string|"'/v1/%s/%s/%s'"
op|'%'
op|'('
name|'dest_account'
op|','
name|'dest_container'
op|','
name|'dest_object'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'Content-Length'"
op|']'
op|'='
number|'0'
newline|'\n'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Copy-From'"
op|']'
op|'='
name|'quote'
op|'('
name|'source'
op|')'
newline|'\n'
name|'del'
name|'req'
op|'.'
name|'headers'
op|'['
string|"'Destination'"
op|']'
newline|'\n'
nl|'\n'
name|'container_info'
op|'='
name|'self'
op|'.'
name|'container_info'
op|'('
nl|'\n'
name|'dest_account'
op|','
name|'dest_container'
op|','
name|'req'
op|')'
newline|'\n'
name|'dest_policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'container_info'
op|'['
string|"'storage_policy'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_reroute'
op|'('
name|'dest_policy'
op|')'
op|'.'
name|'PUT'
op|'('
name|'req'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'ObjectControllerRouter'
op|'.'
name|'register'
op|'('
name|'REPL_POLICY'
op|')'
newline|'\n'
DECL|class|ReplicatedObjectController
name|'class'
name|'ReplicatedObjectController'
op|'('
name|'BaseObjectController'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|_get_or_head_response
indent|'    '
name|'def'
name|'_get_or_head_response'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'resp'
op|'='
name|'self'
op|'.'
name|'GETorHEAD_base'
op|'('
nl|'\n'
name|'req'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
nl|'\n'
name|'req'
op|'.'
name|'swift_entity_path'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
DECL|member|_connect_put_node
dedent|''
name|'def'
name|'_connect_put_node'
op|'('
name|'self'
op|','
name|'nodes'
op|','
name|'part'
op|','
name|'path'
op|','
name|'headers'
op|','
nl|'\n'
name|'logger_thread_locals'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make a connection for a replicated object.\n\n        Connects to the first working node that it finds in node_iter\n        and sends over the request headers. Returns an HTTPConnection\n        object to handle the rest of the streaming.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|'='
name|'logger_thread_locals'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'nodes'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'start_time'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'with'
name|'ConnectionTimeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'conn_timeout'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'='
name|'http_connect'
op|'('
nl|'\n'
name|'node'
op|'['
string|"'ip'"
op|']'
op|','
name|'node'
op|'['
string|"'port'"
op|']'
op|','
name|'node'
op|'['
string|"'device'"
op|']'
op|','
name|'part'
op|','
string|"'PUT'"
op|','
nl|'\n'
name|'path'
op|','
name|'headers'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'app'
op|'.'
name|'set_node_timing'
op|'('
name|'node'
op|','
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'start_time'
op|')'
newline|'\n'
name|'with'
name|'Timeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'resp'
op|'='
name|'conn'
op|'.'
name|'getexpect'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_CONTINUE'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'.'
name|'resp'
op|'='
name|'None'
newline|'\n'
name|'conn'
op|'.'
name|'node'
op|'='
name|'node'
newline|'\n'
name|'return'
name|'conn'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'is_success'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
nl|'\n'
name|'or'
name|'resp'
op|'.'
name|'status'
name|'in'
op|'('
name|'HTTP_CONFLICT'
op|','
nl|'\n'
name|'HTTP_UNPROCESSABLE_ENTITY'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'.'
name|'resp'
op|'='
name|'resp'
newline|'\n'
name|'conn'
op|'.'
name|'node'
op|'='
name|'node'
newline|'\n'
name|'return'
name|'conn'
newline|'\n'
dedent|''
name|'elif'
name|'headers'
op|'['
string|"'If-None-Match'"
op|']'
name|'is'
name|'not'
name|'None'
name|'and'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_PRECONDITION_FAILED'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'.'
name|'resp'
op|'='
name|'resp'
newline|'\n'
name|'conn'
op|'.'
name|'node'
op|'='
name|'node'
newline|'\n'
name|'return'
name|'conn'
newline|'\n'
dedent|''
name|'elif'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_INSUFFICIENT_STORAGE'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_limit'
op|'('
name|'node'
op|','
name|'_'
op|'('
string|"'ERROR Insufficient Storage'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'is_server_error'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_occurred'
op|'('
nl|'\n'
name|'node'
op|','
nl|'\n'
name|'_'
op|'('
string|"'ERROR %(status)d Expect: 100-continue '"
nl|'\n'
string|"'From Object Server'"
op|')'
op|'%'
op|'{'
nl|'\n'
string|"'status'"
op|':'
name|'resp'
op|'.'
name|'status'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|'('
nl|'\n'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Expect: 100-continue on %s'"
op|')'
op|'%'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_send_file
dedent|''
dedent|''
dedent|''
name|'def'
name|'_send_file'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Method for a file PUT coro"""'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'chunk'
op|'='
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'get'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'conn'
op|'.'
name|'failed'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'ChunkWriteTimeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'conn'
op|'.'
name|'send'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'ChunkWriteTimeout'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'.'
name|'failed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|'('
nl|'\n'
name|'conn'
op|'.'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Trying to write to %s'"
op|')'
op|'%'
name|'path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'task_done'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_transfer_data
dedent|''
dedent|''
name|'def'
name|'_transfer_data'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'conns'
op|','
name|'nodes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Transfer data for a replicated object.\n\n        This method was added in the PUT method extraction change\n        """'
newline|'\n'
name|'min_conns'
op|'='
name|'quorum_size'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
newline|'\n'
name|'bytes_transferred'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'ContextPool'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
name|'as'
name|'pool'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'conn'
name|'in'
name|'conns'
op|':'
newline|'\n'
indent|'                    '
name|'conn'
op|'.'
name|'failed'
op|'='
name|'False'
newline|'\n'
name|'conn'
op|'.'
name|'queue'
op|'='
name|'Queue'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'put_queue_depth'
op|')'
newline|'\n'
name|'pool'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_send_file'
op|','
name|'conn'
op|','
name|'req'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'ChunkReadTimeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'client_timeout'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'try'
op|':'
newline|'\n'
indent|'                            '
name|'chunk'
op|'='
name|'next'
op|'('
name|'data_source'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
indent|'                            '
name|'if'
name|'req'
op|'.'
name|'is_chunked'
op|':'
newline|'\n'
indent|'                                '
name|'for'
name|'conn'
name|'in'
name|'conns'
op|':'
newline|'\n'
indent|'                                    '
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'bytes_transferred'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'bytes_transferred'
op|'>'
name|'constraints'
op|'.'
name|'MAX_FILE_SIZE'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'conn'
name|'in'
name|'list'
op|'('
name|'conns'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'not'
name|'conn'
op|'.'
name|'failed'
op|':'
newline|'\n'
indent|'                            '
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
nl|'\n'
string|"'%x\\r\\n%s\\r\\n'"
op|'%'
op|'('
name|'len'
op|'('
name|'chunk'
op|')'
op|','
name|'chunk'
op|')'
nl|'\n'
name|'if'
name|'req'
op|'.'
name|'is_chunked'
name|'else'
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'conn'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'conns'
op|'.'
name|'remove'
op|'('
name|'conn'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_check_min_conn'
op|'('
nl|'\n'
name|'req'
op|','
name|'conns'
op|','
name|'min_conns'
op|','
nl|'\n'
name|'msg'
op|'='
string|"'Object PUT exceptions during'"
nl|'\n'
string|"' send, %(conns)s/%(nodes)s required connections'"
op|')'
newline|'\n'
dedent|''
name|'for'
name|'conn'
name|'in'
name|'conns'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'unfinished_tasks'
op|':'
newline|'\n'
indent|'                        '
name|'conn'
op|'.'
name|'queue'
op|'.'
name|'join'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'conns'
op|'='
op|'['
name|'conn'
name|'for'
name|'conn'
name|'in'
name|'conns'
name|'if'
name|'not'
name|'conn'
op|'.'
name|'failed'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_check_min_conn'
op|'('
nl|'\n'
name|'req'
op|','
name|'conns'
op|','
name|'min_conns'
op|','
nl|'\n'
name|'msg'
op|'='
string|"'Object PUT exceptions after last send, '"
nl|'\n'
string|"'%(conns)s/%(nodes)s required connections'"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ChunkReadTimeout'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Client read timeout (%ss)'"
op|')'
op|','
name|'err'
op|'.'
name|'seconds'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_timeouts'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPRequestTimeout'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'HTTPException'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'except'
name|'ChunkReadError'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'client_disconnect'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client disconnected without sending last chunk'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_disconnects'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Timeout'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Exception causing client disconnect'"
op|')'
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Exception transferring data to object servers %s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'req'
op|'.'
name|'path'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'HTTPInternalServerError'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'content_length'
name|'and'
name|'bytes_transferred'
op|'<'
name|'req'
op|'.'
name|'content_length'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'client_disconnect'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client disconnected without sending enough data'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_disconnects'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_store_object
dedent|''
dedent|''
name|'def'
name|'_store_object'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'nodes'
op|','
name|'partition'
op|','
nl|'\n'
name|'outgoing_headers'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Store a replicated object.\n\n        This method is responsible for establishing connection\n        with storage nodes and sending object to each one of those\n        nodes. After sending the data, the "best" response will be\n        returned based on statuses from all connections\n        """'
newline|'\n'
name|'policy_index'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|')'
newline|'\n'
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_index'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'nodes'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'HTTPNotFound'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# RFC2616:8.2.3 disallows 100-continue without a body'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'req'
op|'.'
name|'content_length'
op|'>'
number|'0'
op|')'
name|'or'
name|'req'
op|'.'
name|'is_chunked'
op|':'
newline|'\n'
indent|'            '
name|'expect'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'expect'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'conns'
op|'='
name|'self'
op|'.'
name|'_get_put_connections'
op|'('
name|'req'
op|','
name|'nodes'
op|','
name|'partition'
op|','
nl|'\n'
name|'outgoing_headers'
op|','
name|'policy'
op|','
name|'expect'
op|')'
newline|'\n'
name|'min_conns'
op|'='
name|'quorum_size'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# check that a minimum number of connections were established and'
nl|'\n'
comment|'# meet all the correct conditions set in the request'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_check_failure_put_connections'
op|'('
name|'conns'
op|','
name|'req'
op|','
name|'nodes'
op|','
name|'min_conns'
op|')'
newline|'\n'
nl|'\n'
comment|'# transfer data'
nl|'\n'
name|'self'
op|'.'
name|'_transfer_data'
op|'('
name|'req'
op|','
name|'data_source'
op|','
name|'conns'
op|','
name|'nodes'
op|')'
newline|'\n'
nl|'\n'
comment|'# get responses'
nl|'\n'
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
name|'etags'
op|'='
name|'self'
op|'.'
name|'_get_put_responses'
op|'('
nl|'\n'
name|'req'
op|','
name|'conns'
op|','
name|'nodes'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'HTTPException'
name|'as'
name|'resp'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'resp'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'conn'
name|'in'
name|'conns'
op|':'
newline|'\n'
indent|'                '
name|'conn'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'etags'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Object servers returned %s mismatched etags'"
op|')'
op|','
name|'len'
op|'('
name|'etags'
op|')'
op|')'
newline|'\n'
name|'return'
name|'HTTPServerError'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'etag'
op|'='
name|'etags'
op|'.'
name|'pop'
op|'('
op|')'
name|'if'
name|'len'
op|'('
name|'etags'
op|')'
name|'else'
name|'None'
newline|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'best_response'
op|'('
name|'req'
op|','
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Object PUT'"
op|')'
op|','
name|'etag'
op|'='
name|'etag'
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'last_modified'
op|'='
name|'math'
op|'.'
name|'ceil'
op|'('
nl|'\n'
name|'float'
op|'('
name|'Timestamp'
op|'('
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECAppIter
dedent|''
dedent|''
name|'class'
name|'ECAppIter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    WSGI iterable that decodes EC fragment archives (or portions thereof)\n    into the original object (or portions thereof).\n\n    :param path: object\'s path, sans v1 (e.g. /a/c/o)\n\n    :param policy: storage policy for this object\n\n    :param internal_parts_iters: list of the response-document-parts\n        iterators for the backend GET responses. For an M+K erasure code,\n        the caller must supply M such iterables.\n\n    :param range_specs: list of dictionaries describing the ranges requested\n        by the client. Each dictionary contains the start and end of the\n        client\'s requested byte range as well as the start and end of the EC\n        segments containing that byte range.\n\n    :param fa_length: length of the fragment archive, in bytes, if the\n        response is a 200. If it\'s a 206, then this is ignored.\n\n    :param obj_length: length of the object, in bytes. Learned from the\n        headers in the GET response from the object server.\n\n    :param logger: a logger\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'policy'
op|','
name|'internal_parts_iters'
op|','
name|'range_specs'
op|','
nl|'\n'
name|'fa_length'
op|','
name|'obj_length'
op|','
name|'logger'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
name|'path'
newline|'\n'
name|'self'
op|'.'
name|'policy'
op|'='
name|'policy'
newline|'\n'
name|'self'
op|'.'
name|'internal_parts_iters'
op|'='
name|'internal_parts_iters'
newline|'\n'
name|'self'
op|'.'
name|'range_specs'
op|'='
name|'range_specs'
newline|'\n'
name|'self'
op|'.'
name|'fa_length'
op|'='
name|'fa_length'
newline|'\n'
name|'self'
op|'.'
name|'obj_length'
op|'='
name|'obj_length'
name|'if'
name|'obj_length'
name|'is'
name|'not'
name|'None'
name|'else'
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'boundary'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'mime_boundary'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'learned_content_type'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'stashed_iter'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'it'
name|'in'
name|'self'
op|'.'
name|'internal_parts_iters'
op|':'
newline|'\n'
indent|'            '
name|'close_if_possible'
op|'('
name|'it'
op|')'
newline|'\n'
nl|'\n'
DECL|member|kickoff
dedent|''
dedent|''
name|'def'
name|'kickoff'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'resp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Start pulling data from the backends so that we can learn things like\n        the real Content-Type that might only be in the multipart/byteranges\n        response body. Update our response accordingly.\n\n        Also, this is the first point at which we can learn the MIME\n        boundary that our response has in the headers. We grab that so we\n        can also use it in the body.\n\n        :returns: None\n        :raises: HTTPException on error\n        """'
newline|'\n'
name|'self'
op|'.'
name|'mime_boundary'
op|'='
name|'resp'
op|'.'
name|'boundary'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'stashed_iter'
op|'='
name|'reiterate'
op|'('
name|'self'
op|'.'
name|'_real_iter'
op|'('
name|'req'
op|','
name|'resp'
op|'.'
name|'headers'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'learned_content_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'.'
name|'content_type'
op|'='
name|'self'
op|'.'
name|'learned_content_type'
newline|'\n'
dedent|''
name|'resp'
op|'.'
name|'content_length'
op|'='
name|'self'
op|'.'
name|'obj_length'
newline|'\n'
nl|'\n'
DECL|member|_next_range
dedent|''
name|'def'
name|'_next_range'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Each FA part should have approximately the same headers. We really'
nl|'\n'
comment|"# only care about Content-Range and Content-Type, and that'll be the"
nl|'\n'
comment|'# same for all the different FAs.'
nl|'\n'
indent|'        '
name|'frag_iters'
op|'='
op|'['
op|']'
newline|'\n'
name|'headers'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'parts_iter'
name|'in'
name|'self'
op|'.'
name|'internal_parts_iters'
op|':'
newline|'\n'
indent|'            '
name|'part_info'
op|'='
name|'next'
op|'('
name|'parts_iter'
op|')'
newline|'\n'
name|'frag_iters'
op|'.'
name|'append'
op|'('
name|'part_info'
op|'['
string|"'part_iter'"
op|']'
op|')'
newline|'\n'
name|'headers'
op|'='
name|'part_info'
op|'['
string|"'headers'"
op|']'
newline|'\n'
dedent|''
name|'headers'
op|'='
name|'HeaderKeyDict'
op|'('
name|'headers'
op|')'
newline|'\n'
name|'return'
name|'headers'
op|','
name|'frag_iters'
newline|'\n'
nl|'\n'
DECL|member|_actual_range
dedent|''
name|'def'
name|'_actual_range'
op|'('
name|'self'
op|','
name|'req_start'
op|','
name|'req_end'
op|','
name|'entity_length'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'rng'
op|'='
name|'Range'
op|'('
string|'"bytes=%s-%s"'
op|'%'
op|'('
nl|'\n'
name|'req_start'
name|'if'
name|'req_start'
name|'is'
name|'not'
name|'None'
name|'else'
string|"''"
op|','
nl|'\n'
name|'req_end'
name|'if'
name|'req_end'
name|'is'
name|'not'
name|'None'
name|'else'
string|"''"
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'rfl'
op|'='
name|'rng'
op|'.'
name|'ranges_for_length'
op|'('
name|'entity_length'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'rfl'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# ranges_for_length() adds 1 to the last byte's position"
nl|'\n'
comment|'# because webob once made a mistake'
nl|'\n'
indent|'            '
name|'return'
op|'('
name|'rfl'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'rfl'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fill_out_range_specs_from_obj_length
dedent|''
dedent|''
name|'def'
name|'_fill_out_range_specs_from_obj_length'
op|'('
name|'self'
op|','
name|'range_specs'
op|')'
op|':'
newline|'\n'
comment|'# Add a few fields to each range spec:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  * resp_client_start, resp_client_end: the actual bytes that will'
nl|'\n'
comment|'#      be delivered to the client for the requested range. This may'
nl|'\n'
comment|'#      differ from the requested bytes if, say, the requested range'
nl|'\n'
comment|'#      overlaps the end of the object.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  * resp_segment_start, resp_segment_end: the actual offsets of the'
nl|'\n'
comment|'#      segments that will be decoded for the requested range. These'
nl|'\n'
comment|'#      differ from resp_client_start/end in that these are aligned'
nl|'\n'
comment|'#      to segment boundaries, while resp_client_start/end are not'
nl|'\n'
comment|'#      necessarily so.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  * satisfiable: a boolean indicating whether the range is'
nl|'\n'
comment|'#      satisfiable or not (i.e. the requested range overlaps the'
nl|'\n'
comment|'#      object in at least one byte).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This is kept separate from _fill_out_range_specs_from_fa_length()'
nl|'\n'
comment|'# because this computation can be done with just the response'
nl|'\n'
comment|'# headers from the object servers (in particular'
nl|'\n'
comment|'# X-Object-Sysmeta-Ec-Content-Length), while the computation in'
nl|'\n'
comment|'# _fill_out_range_specs_from_fa_length() requires the beginnings of'
nl|'\n'
comment|'# the response bodies.'
nl|'\n'
indent|'        '
name|'for'
name|'spec'
name|'in'
name|'range_specs'
op|':'
newline|'\n'
indent|'            '
name|'cstart'
op|','
name|'cend'
op|'='
name|'self'
op|'.'
name|'_actual_range'
op|'('
nl|'\n'
name|'spec'
op|'['
string|"'req_client_start'"
op|']'
op|','
nl|'\n'
name|'spec'
op|'['
string|"'req_client_end'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'obj_length'
op|')'
newline|'\n'
name|'spec'
op|'['
string|"'resp_client_start'"
op|']'
op|'='
name|'cstart'
newline|'\n'
name|'spec'
op|'['
string|"'resp_client_end'"
op|']'
op|'='
name|'cend'
newline|'\n'
name|'spec'
op|'['
string|"'satisfiable'"
op|']'
op|'='
op|'('
name|'cstart'
name|'is'
name|'not'
name|'None'
name|'and'
name|'cend'
name|'is'
name|'not'
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'sstart'
op|','
name|'send'
op|'='
name|'self'
op|'.'
name|'_actual_range'
op|'('
nl|'\n'
name|'spec'
op|'['
string|"'req_segment_start'"
op|']'
op|','
nl|'\n'
name|'spec'
op|'['
string|"'req_segment_end'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'obj_length'
op|')'
newline|'\n'
nl|'\n'
name|'seg_size'
op|'='
name|'self'
op|'.'
name|'policy'
op|'.'
name|'ec_segment_size'
newline|'\n'
name|'if'
name|'spec'
op|'['
string|"'req_segment_start'"
op|']'
name|'is'
name|'None'
name|'and'
name|'sstart'
op|'%'
name|'seg_size'
op|'!='
number|'0'
op|':'
newline|'\n'
comment|'# Segment start may, in the case of a suffix request, need'
nl|'\n'
comment|'# to be rounded up (not down!) to the nearest segment boundary.'
nl|'\n'
comment|'# This reflects the trimming of leading garbage (partial'
nl|'\n'
comment|'# fragments) from the retrieved fragments.'
nl|'\n'
indent|'                '
name|'sstart'
op|'+='
name|'seg_size'
op|'-'
op|'('
name|'sstart'
op|'%'
name|'seg_size'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'spec'
op|'['
string|"'resp_segment_start'"
op|']'
op|'='
name|'sstart'
newline|'\n'
name|'spec'
op|'['
string|"'resp_segment_end'"
op|']'
op|'='
name|'send'
newline|'\n'
nl|'\n'
DECL|member|_fill_out_range_specs_from_fa_length
dedent|''
dedent|''
name|'def'
name|'_fill_out_range_specs_from_fa_length'
op|'('
name|'self'
op|','
name|'fa_length'
op|','
name|'range_specs'
op|')'
op|':'
newline|'\n'
comment|'# Add two fields to each range spec:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  * resp_fragment_start, resp_fragment_end: the start and end of'
nl|'\n'
comment|'#      the fragments that compose this byterange. These values are'
nl|'\n'
comment|'#      aligned to fragment boundaries.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This way, ECAppIter has the knowledge it needs to correlate'
nl|'\n'
comment|'# response byteranges with requested ones for when some byteranges'
nl|'\n'
comment|'# are omitted from the response entirely and also to put the right'
nl|'\n'
comment|'# Content-Range headers in a multipart/byteranges response.'
nl|'\n'
indent|'        '
name|'for'
name|'spec'
name|'in'
name|'range_specs'
op|':'
newline|'\n'
indent|'            '
name|'fstart'
op|','
name|'fend'
op|'='
name|'self'
op|'.'
name|'_actual_range'
op|'('
nl|'\n'
name|'spec'
op|'['
string|"'req_fragment_start'"
op|']'
op|','
nl|'\n'
name|'spec'
op|'['
string|"'req_fragment_end'"
op|']'
op|','
nl|'\n'
name|'fa_length'
op|')'
newline|'\n'
name|'spec'
op|'['
string|"'resp_fragment_start'"
op|']'
op|'='
name|'fstart'
newline|'\n'
name|'spec'
op|'['
string|"'resp_fragment_end'"
op|']'
op|'='
name|'fend'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'stashed_iter'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'iter'
op|'('
name|'self'
op|'.'
name|'stashed_iter'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Failed to call kickoff() before __iter__()"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_real_iter
dedent|''
dedent|''
name|'def'
name|'_real_iter'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'resp_headers'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'range_specs'
op|':'
newline|'\n'
indent|'            '
name|'client_asked_for_range'
op|'='
name|'False'
newline|'\n'
name|'range_specs'
op|'='
op|'['
op|'{'
nl|'\n'
string|"'req_client_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'req_client_end'"
op|':'
op|'('
name|'None'
name|'if'
name|'self'
op|'.'
name|'obj_length'
name|'is'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
op|','
nl|'\n'
string|"'resp_client_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'resp_client_end'"
op|':'
op|'('
name|'None'
name|'if'
name|'self'
op|'.'
name|'obj_length'
name|'is'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
op|','
nl|'\n'
string|"'req_segment_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'req_segment_end'"
op|':'
op|'('
name|'None'
name|'if'
name|'self'
op|'.'
name|'obj_length'
name|'is'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
op|','
nl|'\n'
string|"'resp_segment_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'resp_segment_end'"
op|':'
op|'('
name|'None'
name|'if'
name|'self'
op|'.'
name|'obj_length'
name|'is'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
op|','
nl|'\n'
string|"'req_fragment_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'req_fragment_end'"
op|':'
name|'self'
op|'.'
name|'fa_length'
op|'-'
number|'1'
op|','
nl|'\n'
string|"'resp_fragment_start'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'resp_fragment_end'"
op|':'
name|'self'
op|'.'
name|'fa_length'
op|'-'
number|'1'
op|','
nl|'\n'
string|"'satisfiable'"
op|':'
name|'self'
op|'.'
name|'obj_length'
op|'>'
number|'0'
op|','
nl|'\n'
op|'}'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'client_asked_for_range'
op|'='
name|'True'
newline|'\n'
name|'range_specs'
op|'='
name|'self'
op|'.'
name|'range_specs'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_fill_out_range_specs_from_obj_length'
op|'('
name|'range_specs'
op|')'
newline|'\n'
nl|'\n'
name|'multipart'
op|'='
op|'('
name|'len'
op|'('
op|'['
name|'rs'
name|'for'
name|'rs'
name|'in'
name|'range_specs'
name|'if'
name|'rs'
op|'['
string|"'satisfiable'"
op|']'
op|']'
op|')'
op|'>'
number|'1'
op|')'
newline|'\n'
comment|'# Multipart responses are not required to be in the same order as'
nl|'\n'
comment|'# the Range header; the parts may be in any order the server wants.'
nl|'\n'
comment|'# Further, if multiple ranges are requested and only some are'
nl|'\n'
comment|'# satisfiable, then only the satisfiable ones appear in the response'
nl|'\n'
comment|'# at all. Thus, we cannot simply iterate over range_specs in order;'
nl|'\n'
comment|'# we must use the Content-Range header from each part to figure out'
nl|'\n'
comment|"# what we've been given."
nl|'\n'
comment|'#'
nl|'\n'
comment|'# We do, however, make the assumption that all the object-server'
nl|'\n'
comment|'# responses have their ranges in the same order. Otherwise, a'
nl|'\n'
comment|'# streaming decode would be impossible.'
nl|'\n'
nl|'\n'
DECL|function|convert_ranges_iter
name|'def'
name|'convert_ranges_iter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'seen_first_headers'
op|'='
name|'False'
newline|'\n'
name|'ranges_for_resp'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
comment|"# this'll raise StopIteration and exit the loop"
nl|'\n'
indent|'                '
name|'next_range'
op|'='
name|'self'
op|'.'
name|'_next_range'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'headers'
op|','
name|'frag_iters'
op|'='
name|'next_range'
newline|'\n'
name|'content_type'
op|'='
name|'headers'
op|'['
string|"'Content-Type'"
op|']'
newline|'\n'
nl|'\n'
name|'content_range'
op|'='
name|'headers'
op|'.'
name|'get'
op|'('
string|"'Content-Range'"
op|')'
newline|'\n'
name|'if'
name|'content_range'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'fa_start'
op|','
name|'fa_end'
op|','
name|'fa_length'
op|'='
name|'parse_content_range'
op|'('
nl|'\n'
name|'content_range'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'fa_length'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'fa_start'
op|'='
name|'None'
newline|'\n'
name|'fa_end'
op|'='
name|'None'
newline|'\n'
name|'fa_length'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'fa_start'
op|'='
number|'0'
newline|'\n'
name|'fa_end'
op|'='
name|'self'
op|'.'
name|'fa_length'
op|'-'
number|'1'
newline|'\n'
name|'fa_length'
op|'='
name|'self'
op|'.'
name|'fa_length'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'seen_first_headers'
op|':'
newline|'\n'
comment|'# This is the earliest we can possibly do this. On a'
nl|'\n'
comment|'# 200 or 206-single-byterange response, we can learn'
nl|'\n'
comment|"# the FA's length from the HTTP response headers."
nl|'\n'
comment|'# However, on a 206-multiple-byteranges response, we'
nl|'\n'
comment|"# don't learn it until the first part of the"
nl|'\n'
comment|'# response body, in the headers of the first MIME'
nl|'\n'
comment|'# part.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Similarly, the content type of a'
nl|'\n'
comment|'# 206-multiple-byteranges response is'
nl|'\n'
comment|'# "multipart/byteranges", not the object\'s actual'
nl|'\n'
comment|'# content type.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_fill_out_range_specs_from_fa_length'
op|'('
nl|'\n'
name|'fa_length'
op|','
name|'range_specs'
op|')'
newline|'\n'
nl|'\n'
name|'satisfiable'
op|'='
name|'False'
newline|'\n'
name|'for'
name|'range_spec'
name|'in'
name|'range_specs'
op|':'
newline|'\n'
indent|'                        '
name|'satisfiable'
op|'|='
name|'range_spec'
op|'['
string|"'satisfiable'"
op|']'
newline|'\n'
name|'key'
op|'='
op|'('
name|'range_spec'
op|'['
string|"'resp_fragment_start'"
op|']'
op|','
nl|'\n'
name|'range_spec'
op|'['
string|"'resp_fragment_end'"
op|']'
op|')'
newline|'\n'
name|'ranges_for_resp'
op|'.'
name|'setdefault'
op|'('
name|'key'
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'range_spec'
op|')'
newline|'\n'
nl|'\n'
comment|'# The client may have asked for an unsatisfiable set of'
nl|'\n'
comment|'# ranges, but when converted to fragments, the object'
nl|'\n'
comment|'# servers see it as satisfiable. For example, imagine a'
nl|'\n'
comment|'# request for bytes 800-900 of a 750-byte object with a'
nl|'\n'
comment|'# 1024-byte segment size. The object servers will see a'
nl|'\n'
comment|"# request for bytes 0-${fragsize-1}, and that's"
nl|'\n'
comment|"# satisfiable, so they return 206. It's not until we"
nl|'\n'
comment|'# learn the object size that we can check for this'
nl|'\n'
comment|'# condition.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Note that some unsatisfiable ranges *will* be caught'
nl|'\n'
comment|'# by the object servers, like bytes 1800-1900 of a'
nl|'\n'
comment|"# 100-byte object with 1024-byte segments. That's not"
nl|'\n'
comment|"# what we're dealing with here, though."
nl|'\n'
dedent|''
name|'if'
name|'client_asked_for_range'
name|'and'
name|'not'
name|'satisfiable'
op|':'
newline|'\n'
indent|'                        '
name|'req'
op|'.'
name|'environ'
op|'['
nl|'\n'
string|"'swift.non_client_disconnect'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'raise'
name|'HTTPRequestedRangeNotSatisfiable'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
name|'headers'
op|'='
name|'resp_headers'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'learned_content_type'
op|'='
name|'content_type'
newline|'\n'
name|'seen_first_headers'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'range_spec'
op|'='
name|'ranges_for_resp'
op|'['
op|'('
name|'fa_start'
op|','
name|'fa_end'
op|')'
op|']'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'seg_iter'
op|'='
name|'self'
op|'.'
name|'_decode_segments_from_fragments'
op|'('
name|'frag_iters'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'range_spec'
op|'['
string|"'satisfiable'"
op|']'
op|':'
newline|'\n'
comment|"# This'll be small; just a single small segment. Discard"
nl|'\n'
comment|'# it.'
nl|'\n'
indent|'                    '
name|'for'
name|'x'
name|'in'
name|'seg_iter'
op|':'
newline|'\n'
indent|'                        '
name|'pass'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'byterange_iter'
op|'='
name|'self'
op|'.'
name|'_iter_one_range'
op|'('
name|'range_spec'
op|','
name|'seg_iter'
op|')'
newline|'\n'
nl|'\n'
name|'converted'
op|'='
op|'{'
nl|'\n'
string|'"start_byte"'
op|':'
name|'range_spec'
op|'['
string|'"resp_client_start"'
op|']'
op|','
nl|'\n'
string|'"end_byte"'
op|':'
name|'range_spec'
op|'['
string|'"resp_client_end"'
op|']'
op|','
nl|'\n'
string|'"content_type"'
op|':'
name|'content_type'
op|','
nl|'\n'
string|'"part_iter"'
op|':'
name|'byterange_iter'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'obj_length'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'converted'
op|'['
string|'"entity_length"'
op|']'
op|'='
name|'self'
op|'.'
name|'obj_length'
newline|'\n'
dedent|''
name|'yield'
name|'converted'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'document_iters_to_http_response_body'
op|'('
nl|'\n'
name|'convert_ranges_iter'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'mime_boundary'
op|','
name|'multipart'
op|','
name|'self'
op|'.'
name|'logger'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_iter_one_range
dedent|''
name|'def'
name|'_iter_one_range'
op|'('
name|'self'
op|','
name|'range_spec'
op|','
name|'segment_iter'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'client_start'
op|'='
name|'range_spec'
op|'['
string|"'resp_client_start'"
op|']'
newline|'\n'
name|'client_end'
op|'='
name|'range_spec'
op|'['
string|"'resp_client_end'"
op|']'
newline|'\n'
name|'segment_start'
op|'='
name|'range_spec'
op|'['
string|"'resp_segment_start'"
op|']'
newline|'\n'
name|'segment_end'
op|'='
name|'range_spec'
op|'['
string|"'resp_segment_end'"
op|']'
newline|'\n'
nl|'\n'
comment|"# It's entirely possible that the client asked for a range that"
nl|'\n'
comment|"# includes some bytes we have and some we don't; for example, a"
nl|'\n'
comment|'# range of bytes 1000-20000000 on a 1500-byte object.'
nl|'\n'
name|'segment_end'
op|'='
op|'('
name|'min'
op|'('
name|'segment_end'
op|','
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
nl|'\n'
name|'if'
name|'segment_end'
name|'is'
name|'not'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'client_end'
op|'='
op|'('
name|'min'
op|'('
name|'client_end'
op|','
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
nl|'\n'
name|'if'
name|'client_end'
name|'is'
name|'not'
name|'None'
nl|'\n'
name|'else'
name|'self'
op|'.'
name|'obj_length'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'num_segments'
op|'='
name|'int'
op|'('
nl|'\n'
name|'math'
op|'.'
name|'ceil'
op|'('
name|'float'
op|'('
name|'segment_end'
op|'+'
number|'1'
op|'-'
name|'segment_start'
op|')'
nl|'\n'
op|'/'
name|'self'
op|'.'
name|'policy'
op|'.'
name|'ec_segment_size'
op|')'
op|')'
newline|'\n'
comment|'# We get full segments here, but the client may have requested a'
nl|'\n'
comment|'# byte range that begins or ends in the middle of a segment.'
nl|'\n'
comment|'# Thus, we have some amount of overrun (extra decoded bytes)'
nl|'\n'
comment|'# that we trim off so the client gets exactly what they'
nl|'\n'
comment|'# requested.'
nl|'\n'
name|'start_overrun'
op|'='
name|'client_start'
op|'-'
name|'segment_start'
newline|'\n'
name|'end_overrun'
op|'='
name|'segment_end'
op|'-'
name|'client_end'
newline|'\n'
nl|'\n'
name|'for'
name|'i'
op|','
name|'next_seg'
name|'in'
name|'enumerate'
op|'('
name|'segment_iter'
op|')'
op|':'
newline|'\n'
comment|'# We may have a start_overrun of more than one segment in'
nl|'\n'
comment|'# the case of suffix-byte-range requests. However, we never'
nl|'\n'
comment|'# have an end_overrun of more than one segment.'
nl|'\n'
indent|'            '
name|'if'
name|'start_overrun'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'seglen'
op|'='
name|'len'
op|'('
name|'next_seg'
op|')'
newline|'\n'
name|'if'
name|'seglen'
op|'<='
name|'start_overrun'
op|':'
newline|'\n'
indent|'                    '
name|'start_overrun'
op|'-='
name|'seglen'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'next_seg'
op|'='
name|'next_seg'
op|'['
name|'start_overrun'
op|':'
op|']'
newline|'\n'
name|'start_overrun'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'i'
op|'=='
op|'('
name|'num_segments'
op|'-'
number|'1'
op|')'
name|'and'
name|'end_overrun'
op|':'
newline|'\n'
indent|'                '
name|'next_seg'
op|'='
name|'next_seg'
op|'['
op|':'
op|'-'
name|'end_overrun'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'yield'
name|'next_seg'
newline|'\n'
nl|'\n'
DECL|member|_decode_segments_from_fragments
dedent|''
dedent|''
name|'def'
name|'_decode_segments_from_fragments'
op|'('
name|'self'
op|','
name|'fragment_iters'
op|')'
op|':'
newline|'\n'
comment|'# Decodes the fragments from the object servers and yields one'
nl|'\n'
comment|'# segment at a time.'
nl|'\n'
indent|'        '
name|'queues'
op|'='
op|'['
name|'Queue'
op|'('
number|'1'
op|')'
name|'for'
name|'_junk'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'fragment_iters'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|function|put_fragments_in_queue
name|'def'
name|'put_fragments_in_queue'
op|'('
name|'frag_iter'
op|','
name|'queue'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'fragment'
name|'in'
name|'frag_iter'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fragment'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'Exception'
op|'('
string|"'Leading whitespace on fragment.'"
op|')'
newline|'\n'
dedent|''
name|'queue'
op|'.'
name|'put'
op|'('
name|'fragment'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'GreenletExit'
op|':'
newline|'\n'
comment|'# killed by contextpool'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'except'
name|'ChunkReadTimeout'
op|':'
newline|'\n'
comment|'# unable to resume in GetOrHeadHandler'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
string|'"Timeout fetching fragments for %r"'
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
comment|'# noqa'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
string|'"Exception fetching fragments for %r"'
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'queue'
op|'.'
name|'resize'
op|'('
number|'2'
op|')'
comment|"# ensure there's room"
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
name|'None'
op|')'
newline|'\n'
name|'frag_iter'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'with'
name|'ContextPool'
op|'('
name|'len'
op|'('
name|'fragment_iters'
op|')'
op|')'
name|'as'
name|'pool'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'frag_iter'
op|','
name|'queue'
name|'in'
name|'zip'
op|'('
name|'fragment_iters'
op|','
name|'queues'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pool'
op|'.'
name|'spawn'
op|'('
name|'put_fragments_in_queue'
op|','
name|'frag_iter'
op|','
name|'queue'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'fragments'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'queue'
name|'in'
name|'queues'
op|':'
newline|'\n'
indent|'                    '
name|'fragment'
op|'='
name|'queue'
op|'.'
name|'get'
op|'('
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'task_done'
op|'('
op|')'
newline|'\n'
name|'fragments'
op|'.'
name|'append'
op|'('
name|'fragment'
op|')'
newline|'\n'
nl|'\n'
comment|"# If any object server connection yields out a None; we're"
nl|'\n'
comment|"# done.  Either they are all None, and we've finished"
nl|'\n'
comment|'# successfully; or some un-recoverable failure has left us'
nl|'\n'
comment|"# with an un-reconstructible list of fragments - so we'll"
nl|'\n'
comment|'# break out of the iter so WSGI can tear down the broken'
nl|'\n'
comment|'# connection.'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'all'
op|'('
name|'fragments'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'segment'
op|'='
name|'self'
op|'.'
name|'policy'
op|'.'
name|'pyeclib_driver'
op|'.'
name|'decode'
op|'('
name|'fragments'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ECDriverError'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
string|'"Error decoding fragments for %r"'
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
name|'yield'
name|'segment'
newline|'\n'
nl|'\n'
DECL|member|app_iter_range
dedent|''
dedent|''
dedent|''
name|'def'
name|'app_iter_range'
op|'('
name|'self'
op|','
name|'start'
op|','
name|'end'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|app_iter_ranges
dedent|''
name|'def'
name|'app_iter_ranges'
op|'('
name|'self'
op|','
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'content_size'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|client_range_to_segment_range
dedent|''
dedent|''
name|'def'
name|'client_range_to_segment_range'
op|'('
name|'client_start'
op|','
name|'client_end'
op|','
name|'segment_size'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Takes a byterange from the client and converts it into a byterange\n    spanning the necessary segments.\n\n    Handles prefix, suffix, and fully-specified byte ranges.\n\n    Examples:\n        client_range_to_segment_range(100, 700, 512) = (0, 1023)\n        client_range_to_segment_range(100, 700, 256) = (0, 767)\n        client_range_to_segment_range(300, None, 256) = (256, None)\n\n    :param client_start: first byte of the range requested by the client\n    :param client_end: last byte of the range requested by the client\n    :param segment_size: size of an EC segment, in bytes\n\n    :returns: a 2-tuple (seg_start, seg_end) where\n\n      * seg_start is the first byte of the first segment, or None if this is\n        a suffix byte range\n\n      * seg_end is the last byte of the last segment, or None if this is a\n        prefix byte range\n    """'
newline|'\n'
comment|'# the index of the first byte of the first segment'
nl|'\n'
name|'segment_start'
op|'='
op|'('
nl|'\n'
name|'int'
op|'('
name|'client_start'
op|'//'
name|'segment_size'
op|')'
nl|'\n'
op|'*'
name|'segment_size'
op|')'
name|'if'
name|'client_start'
name|'is'
name|'not'
name|'None'
name|'else'
name|'None'
newline|'\n'
comment|'# the index of the last byte of the last segment'
nl|'\n'
name|'segment_end'
op|'='
op|'('
nl|'\n'
comment|'# bytes M-'
nl|'\n'
name|'None'
name|'if'
name|'client_end'
name|'is'
name|'None'
name|'else'
nl|'\n'
comment|'# bytes M-N'
nl|'\n'
op|'('
op|'('
op|'('
name|'int'
op|'('
name|'client_end'
op|'//'
name|'segment_size'
op|')'
op|'+'
number|'1'
op|')'
nl|'\n'
op|'*'
name|'segment_size'
op|')'
op|'-'
number|'1'
op|')'
name|'if'
name|'client_start'
name|'is'
name|'not'
name|'None'
name|'else'
nl|'\n'
comment|'# bytes -N: we get some extra bytes to make sure we'
nl|'\n'
comment|'# have all we need.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# To see why, imagine a 100-byte segment size, a'
nl|'\n'
comment|'# 340-byte object, and a request for the last 50'
nl|'\n'
comment|'# bytes. Naively requesting the last 100 bytes would'
nl|'\n'
comment|'# result in a truncated first segment and hence a'
nl|'\n'
comment|'# truncated download. (Of course, the actual'
nl|'\n'
comment|'# obj-server requests are for fragments, not'
nl|'\n'
comment|"# segments, but that doesn't change the"
nl|'\n'
comment|'# calculation.)'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This does mean that we fetch an extra segment if'
nl|'\n'
comment|'# the object size is an exact multiple of the'
nl|'\n'
comment|"# segment size. It's a little wasteful, but it's"
nl|'\n'
comment|'# better to be a little wasteful than to get some'
nl|'\n'
comment|'# range requests completely wrong.'
nl|'\n'
op|'('
name|'int'
op|'('
name|'math'
op|'.'
name|'ceil'
op|'('
op|'('
nl|'\n'
name|'float'
op|'('
name|'client_end'
op|')'
op|'/'
name|'segment_size'
op|')'
op|'+'
number|'1'
op|')'
op|')'
comment|'# nsegs'
nl|'\n'
op|'*'
name|'segment_size'
op|')'
op|')'
newline|'\n'
name|'return'
op|'('
name|'segment_start'
op|','
name|'segment_end'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|segment_range_to_fragment_range
dedent|''
name|'def'
name|'segment_range_to_fragment_range'
op|'('
name|'segment_start'
op|','
name|'segment_end'
op|','
name|'segment_size'
op|','
nl|'\n'
name|'fragment_size'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Takes a byterange spanning some segments and converts that into a\n    byterange spanning the corresponding fragments within their fragment\n    archives.\n\n    Handles prefix, suffix, and fully-specified byte ranges.\n\n    :param segment_start: first byte of the first segment\n    :param segment_end: last byte of the last segment\n    :param segment_size: size of an EC segment, in bytes\n    :param fragment_size: size of an EC fragment, in bytes\n\n    :returns: a 2-tuple (frag_start, frag_end) where\n\n      * frag_start is the first byte of the first fragment, or None if this\n        is a suffix byte range\n\n      * frag_end is the last byte of the last fragment, or None if this is a\n        prefix byte range\n    """'
newline|'\n'
comment|'# Note: segment_start and (segment_end + 1) are'
nl|'\n'
comment|"# multiples of segment_size, so we don't have to worry"
nl|'\n'
comment|'# about integer math giving us rounding troubles.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# There's a whole bunch of +1 and -1 in here; that's because HTTP wants"
nl|'\n'
comment|'# byteranges to be inclusive of the start and end, so e.g. bytes 200-300'
nl|'\n'
comment|'# is a range containing 101 bytes. Python has half-inclusive ranges, of'
nl|'\n'
comment|'# course, so we have to convert back and forth. We try to keep things in'
nl|'\n'
comment|'# HTTP-style byteranges for consistency.'
nl|'\n'
nl|'\n'
comment|'# the index of the first byte of the first fragment'
nl|'\n'
name|'fragment_start'
op|'='
op|'('
op|'('
nl|'\n'
name|'segment_start'
op|'/'
name|'segment_size'
op|'*'
name|'fragment_size'
op|')'
nl|'\n'
name|'if'
name|'segment_start'
name|'is'
name|'not'
name|'None'
name|'else'
name|'None'
op|')'
newline|'\n'
comment|'# the index of the last byte of the last fragment'
nl|'\n'
name|'fragment_end'
op|'='
op|'('
nl|'\n'
comment|'# range unbounded on the right'
nl|'\n'
name|'None'
name|'if'
name|'segment_end'
name|'is'
name|'None'
name|'else'
nl|'\n'
comment|"# range unbounded on the left; no -1 since we're"
nl|'\n'
comment|'# asking for the last N bytes, not to have a'
nl|'\n'
comment|'# particular byte be the last one'
nl|'\n'
op|'('
op|'('
name|'segment_end'
op|'+'
number|'1'
op|')'
op|'/'
name|'segment_size'
nl|'\n'
op|'*'
name|'fragment_size'
op|')'
name|'if'
name|'segment_start'
name|'is'
name|'None'
name|'else'
nl|'\n'
comment|'# range bounded on both sides; the -1 is because the'
nl|'\n'
comment|'# rest of the expression computes the length of the'
nl|'\n'
comment|'# fragment, and a range of N bytes starts at index M'
nl|'\n'
comment|'# and ends at M + N - 1.'
nl|'\n'
op|'('
op|'('
name|'segment_end'
op|'+'
number|'1'
op|')'
op|'/'
name|'segment_size'
op|'*'
name|'fragment_size'
op|')'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'return'
op|'('
name|'fragment_start'
op|','
name|'fragment_end'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|NO_DATA_SENT
dedent|''
name|'NO_DATA_SENT'
op|'='
number|'1'
newline|'\n'
DECL|variable|SENDING_DATA
name|'SENDING_DATA'
op|'='
number|'2'
newline|'\n'
DECL|variable|DATA_SENT
name|'DATA_SENT'
op|'='
number|'3'
newline|'\n'
DECL|variable|DATA_ACKED
name|'DATA_ACKED'
op|'='
number|'4'
newline|'\n'
DECL|variable|COMMIT_SENT
name|'COMMIT_SENT'
op|'='
number|'5'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECPutter
name|'class'
name|'ECPutter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This is here mostly to wrap up the fact that all EC PUTs are\n    chunked because of the mime boundary footer trick and the first\n    half of the two-phase PUT conversation handling.\n\n    An HTTP PUT request that supports streaming.\n\n    Probably deserves more docs than this, but meh.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'node'
op|','
name|'resp'
op|','
name|'path'
op|','
name|'connect_duration'
op|','
nl|'\n'
name|'mime_boundary'
op|')'
op|':'
newline|'\n'
comment|'# Note: you probably want to call Putter.connect() instead of'
nl|'\n'
comment|'# instantiating one of these directly.'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'conn'
op|'='
name|'conn'
newline|'\n'
name|'self'
op|'.'
name|'node'
op|'='
name|'node'
newline|'\n'
name|'self'
op|'.'
name|'resp'
op|'='
name|'resp'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'='
name|'path'
newline|'\n'
name|'self'
op|'.'
name|'connect_duration'
op|'='
name|'connect_duration'
newline|'\n'
comment|'# for handoff nodes node_index is None'
nl|'\n'
name|'self'
op|'.'
name|'node_index'
op|'='
name|'node'
op|'.'
name|'get'
op|'('
string|"'index'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'mime_boundary'
op|'='
name|'mime_boundary'
newline|'\n'
name|'self'
op|'.'
name|'chunk_hasher'
op|'='
name|'md5'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failed'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'queue'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'NO_DATA_SENT'
newline|'\n'
nl|'\n'
DECL|member|current_status
dedent|''
name|'def'
name|'current_status'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the current status of the response.\n\n        A response starts off with no current status, then may or may not have\n        a status of 100 for some time, and then ultimately has a final status\n        like 200, 404, et cetera.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'resp'
op|'.'
name|'status'
newline|'\n'
nl|'\n'
DECL|member|await_response
dedent|''
name|'def'
name|'await_response'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'informational'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get 100-continue response indicating the end of 1st phase of a 2-phase\n        commit or the final response, i.e. the one with status >= 200.\n\n        Might or might not actually wait for anything. If we said Expect:\n        100-continue but got back a non-100 response, that\'ll be the thing\n        returned, and we won\'t do any network IO to get it. OTOH, if we got\n        a 100 Continue response and sent up the PUT request\'s body, then\n        we\'ll actually read the 2xx-5xx response off the network here.\n\n        :returns: HTTPResponse\n        :raises: Timeout if the response took too long\n        """'
newline|'\n'
name|'conn'
op|'='
name|'self'
op|'.'
name|'conn'
newline|'\n'
name|'with'
name|'Timeout'
op|'('
name|'timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'conn'
op|'.'
name|'resp'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'informational'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'resp'
op|'='
name|'conn'
op|'.'
name|'getexpect'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'resp'
op|'='
name|'conn'
op|'.'
name|'getresponse'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'resp'
newline|'\n'
nl|'\n'
DECL|member|spawn_sender_greenthread
dedent|''
dedent|''
name|'def'
name|'spawn_sender_greenthread'
op|'('
name|'self'
op|','
name|'pool'
op|','
name|'queue_depth'
op|','
name|'write_timeout'
op|','
nl|'\n'
name|'exception_handler'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Call before sending the first chunk of request body"""'
newline|'\n'
name|'self'
op|'.'
name|'queue'
op|'='
name|'Queue'
op|'('
name|'queue_depth'
op|')'
newline|'\n'
name|'pool'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_send_file'
op|','
name|'write_timeout'
op|','
name|'exception_handler'
op|')'
newline|'\n'
nl|'\n'
DECL|member|wait
dedent|''
name|'def'
name|'wait'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'queue'
op|'.'
name|'unfinished_tasks'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'queue'
op|'.'
name|'join'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_start_mime_doc_object_body
dedent|''
dedent|''
name|'def'
name|'_start_mime_doc_object_body'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|'"--%s\\r\\nX-Document: object body\\r\\n\\r\\n"'
op|'%'
nl|'\n'
op|'('
name|'self'
op|'.'
name|'mime_boundary'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|send_chunk
dedent|''
name|'def'
name|'send_chunk'
op|'('
name|'self'
op|','
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'chunk'
op|':'
newline|'\n'
comment|"# If we're not using chunked transfer-encoding, sending a 0-byte"
nl|'\n'
comment|'# chunk is just wasteful. If we *are* using chunked'
nl|'\n'
comment|'# transfer-encoding, sending a 0-byte chunk terminates the'
nl|'\n'
comment|'# request body. Neither one of these is good.'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'state'
op|'=='
name|'DATA_SENT'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"called send_chunk after end_of_object_data"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
name|'NO_DATA_SENT'
name|'and'
name|'self'
op|'.'
name|'mime_boundary'
op|':'
newline|'\n'
comment|"# We're sending the object plus other stuff in the same request"
nl|'\n'
comment|"# body, all wrapped up in multipart MIME, so we'd better start"
nl|'\n'
comment|'# off the MIME document before sending any object data.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_start_mime_doc_object_body'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'SENDING_DATA'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
DECL|member|end_of_object_data
dedent|''
name|'def'
name|'end_of_object_data'
op|'('
name|'self'
op|','
name|'footer_metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call when there is no more data to send.\n\n        :param footer_metadata: dictionary of metadata items\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
name|'DATA_SENT'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"called end_of_object_data twice"'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'state'
op|'=='
name|'NO_DATA_SENT'
name|'and'
name|'self'
op|'.'
name|'mime_boundary'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_start_mime_doc_object_body'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'footer_body'
op|'='
name|'json'
op|'.'
name|'dumps'
op|'('
name|'footer_metadata'
op|')'
newline|'\n'
name|'footer_md5'
op|'='
name|'md5'
op|'('
name|'footer_body'
op|')'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'tail_boundary'
op|'='
op|'('
string|'"--%s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'mime_boundary'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'message_parts'
op|'='
op|'['
nl|'\n'
op|'('
string|'"\\r\\n--%s\\r\\n"'
op|'%'
name|'self'
op|'.'
name|'mime_boundary'
op|')'
op|','
nl|'\n'
string|'"X-Document: object metadata\\r\\n"'
op|','
nl|'\n'
string|'"Content-MD5: %s\\r\\n"'
op|'%'
name|'footer_md5'
op|','
nl|'\n'
string|'"\\r\\n"'
op|','
nl|'\n'
name|'footer_body'
op|','
string|'"\\r\\n"'
op|','
nl|'\n'
name|'tail_boundary'
op|','
string|'"\\r\\n"'
op|','
nl|'\n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'message_parts'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'DATA_SENT'
newline|'\n'
nl|'\n'
DECL|member|send_commit_confirmation
dedent|''
name|'def'
name|'send_commit_confirmation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call when there are > quorum 2XX responses received.  Send commit\n        confirmations to all object nodes to finalize the PUT.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
name|'COMMIT_SENT'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"called send_commit_confirmation twice"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'state'
op|'='
name|'DATA_ACKED'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'mime_boundary'
op|':'
newline|'\n'
indent|'            '
name|'body'
op|'='
string|'"put_commit_confirmation"'
newline|'\n'
name|'tail_boundary'
op|'='
op|'('
string|'"--%s--"'
op|'%'
op|'('
name|'self'
op|'.'
name|'mime_boundary'
op|','
op|')'
op|')'
newline|'\n'
name|'message_parts'
op|'='
op|'['
nl|'\n'
string|'"X-Document: put commit\\r\\n"'
op|','
nl|'\n'
string|'"\\r\\n"'
op|','
nl|'\n'
name|'body'
op|','
string|'"\\r\\n"'
op|','
nl|'\n'
name|'tail_boundary'
op|','
nl|'\n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'message_parts'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'queue'
op|'.'
name|'put'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'COMMIT_SENT'
newline|'\n'
nl|'\n'
DECL|member|_send_file
dedent|''
name|'def'
name|'_send_file'
op|'('
name|'self'
op|','
name|'write_timeout'
op|','
name|'exception_handler'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Method for a file PUT coro. Takes chunks from a queue and sends them\n        down a socket.\n\n        If something goes wrong, the "failed" attribute will be set to true\n        and the exception handler will be called.\n        """'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'queue'
op|'.'
name|'get'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'failed'
op|':'
newline|'\n'
indent|'                '
name|'to_send'
op|'='
string|'"%x\\r\\n%s\\r\\n"'
op|'%'
op|'('
name|'len'
op|'('
name|'chunk'
op|')'
op|','
name|'chunk'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'ChunkWriteTimeout'
op|'('
name|'write_timeout'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'conn'
op|'.'
name|'send'
op|'('
name|'to_send'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'ChunkWriteTimeout'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'failed'
op|'='
name|'True'
newline|'\n'
name|'exception_handler'
op|'('
name|'self'
op|'.'
name|'conn'
op|'.'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Trying to write to %s'"
op|')'
op|'%'
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'queue'
op|'.'
name|'task_done'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|connect
name|'def'
name|'connect'
op|'('
name|'cls'
op|','
name|'node'
op|','
name|'part'
op|','
name|'path'
op|','
name|'headers'
op|','
name|'conn_timeout'
op|','
name|'node_timeout'
op|','
nl|'\n'
name|'chunked'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Connect to a backend node and send the headers.\n\n        :returns: Putter instance\n\n        :raises: ConnectionTimeout if initial connection timed out\n        :raises: ResponseTimeout if header retrieval timed out\n        :raises: InsufficientStorage on 507 response from node\n        :raises: PutterConnectError on non-507 server error response from node\n        :raises: FooterNotSupported if need_metadata_footer is set but\n                 backend node can\'t process footers\n        :raises: MultiphasePUTNotSupported if need_multiphase_support is\n                 set but backend node can\'t handle multiphase PUT\n        """'
newline|'\n'
name|'mime_boundary'
op|'='
string|'"%.64x"'
op|'%'
name|'random'
op|'.'
name|'randint'
op|'('
number|'0'
op|','
number|'16'
op|'**'
number|'64'
op|')'
newline|'\n'
name|'headers'
op|'='
name|'HeaderKeyDict'
op|'('
name|'headers'
op|')'
newline|'\n'
comment|"# We're going to be adding some unknown amount of data to the"
nl|'\n'
comment|"# request, so we can't use an explicit content length, and thus"
nl|'\n'
comment|'# we must use chunked encoding.'
nl|'\n'
name|'headers'
op|'['
string|"'Transfer-Encoding'"
op|']'
op|'='
string|"'chunked'"
newline|'\n'
name|'headers'
op|'['
string|"'Expect'"
op|']'
op|'='
string|"'100-continue'"
newline|'\n'
name|'if'
string|"'Content-Length'"
name|'in'
name|'headers'
op|':'
newline|'\n'
indent|'            '
name|'headers'
op|'['
string|"'X-Backend-Obj-Content-Length'"
op|']'
op|'='
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'Content-Length'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'headers'
op|'['
string|"'X-Backend-Obj-Multipart-Mime-Boundary'"
op|']'
op|'='
name|'mime_boundary'
newline|'\n'
nl|'\n'
name|'headers'
op|'['
string|"'X-Backend-Obj-Metadata-Footer'"
op|']'
op|'='
string|"'yes'"
newline|'\n'
nl|'\n'
name|'headers'
op|'['
string|"'X-Backend-Obj-Multiphase-Commit'"
op|']'
op|'='
string|"'yes'"
newline|'\n'
nl|'\n'
name|'start_time'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'with'
name|'ConnectionTimeout'
op|'('
name|'conn_timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'='
name|'http_connect'
op|'('
name|'node'
op|'['
string|"'ip'"
op|']'
op|','
name|'node'
op|'['
string|"'port'"
op|']'
op|','
name|'node'
op|'['
string|"'device'"
op|']'
op|','
nl|'\n'
name|'part'
op|','
string|"'PUT'"
op|','
name|'path'
op|','
name|'headers'
op|')'
newline|'\n'
dedent|''
name|'connect_duration'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'start_time'
newline|'\n'
nl|'\n'
name|'with'
name|'ResponseTimeout'
op|'('
name|'node_timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'='
name|'conn'
op|'.'
name|'getexpect'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_INSUFFICIENT_STORAGE'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'InsufficientStorage'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'is_server_error'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PutterConnectError'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'is_informational'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue_headers'
op|'='
name|'HeaderKeyDict'
op|'('
name|'resp'
op|'.'
name|'getheaders'
op|'('
op|')'
op|')'
newline|'\n'
name|'can_send_metadata_footer'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'continue_headers'
op|'.'
name|'get'
op|'('
string|"'X-Obj-Metadata-Footer'"
op|','
string|"'no'"
op|')'
op|')'
newline|'\n'
name|'can_handle_multiphase_put'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'continue_headers'
op|'.'
name|'get'
op|'('
string|"'X-Obj-Multiphase-Commit'"
op|','
string|"'no'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'can_send_metadata_footer'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'FooterNotSupported'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'can_handle_multiphase_put'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'MultiphasePUTNotSupported'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'conn'
op|'.'
name|'node'
op|'='
name|'node'
newline|'\n'
name|'conn'
op|'.'
name|'resp'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'is_success'
op|'('
name|'resp'
op|'.'
name|'status'
op|')'
name|'or'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_CONFLICT'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'.'
name|'resp'
op|'='
name|'resp'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'headers'
op|'.'
name|'get'
op|'('
string|"'If-None-Match'"
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'resp'
op|'.'
name|'status'
op|'=='
name|'HTTP_PRECONDITION_FAILED'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'.'
name|'resp'
op|'='
name|'resp'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'cls'
op|'('
name|'conn'
op|','
name|'node'
op|','
name|'resp'
op|','
name|'path'
op|','
name|'connect_duration'
op|','
name|'mime_boundary'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|chunk_transformer
dedent|''
dedent|''
name|'def'
name|'chunk_transformer'
op|'('
name|'policy'
op|','
name|'nstreams'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'segment_size'
op|'='
name|'policy'
op|'.'
name|'ec_segment_size'
newline|'\n'
nl|'\n'
name|'buf'
op|'='
name|'collections'
op|'.'
name|'deque'
op|'('
op|')'
newline|'\n'
name|'total_buf_len'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'chunk'
op|'='
name|'yield'
newline|'\n'
name|'while'
name|'chunk'
op|':'
newline|'\n'
indent|'        '
name|'buf'
op|'.'
name|'append'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'total_buf_len'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'total_buf_len'
op|'>='
name|'segment_size'
op|':'
newline|'\n'
indent|'            '
name|'chunks_to_encode'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# extract as many chunks as we can from the input buffer'
nl|'\n'
name|'while'
name|'total_buf_len'
op|'>='
name|'segment_size'
op|':'
newline|'\n'
indent|'                '
name|'to_take'
op|'='
name|'segment_size'
newline|'\n'
name|'pieces'
op|'='
op|'['
op|']'
newline|'\n'
name|'while'
name|'to_take'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'piece'
op|'='
name|'buf'
op|'.'
name|'popleft'
op|'('
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'piece'
op|')'
op|'>'
name|'to_take'
op|':'
newline|'\n'
indent|'                        '
name|'buf'
op|'.'
name|'appendleft'
op|'('
name|'piece'
op|'['
name|'to_take'
op|':'
op|']'
op|')'
newline|'\n'
name|'piece'
op|'='
name|'piece'
op|'['
op|':'
name|'to_take'
op|']'
newline|'\n'
dedent|''
name|'pieces'
op|'.'
name|'append'
op|'('
name|'piece'
op|')'
newline|'\n'
name|'to_take'
op|'-='
name|'len'
op|'('
name|'piece'
op|')'
newline|'\n'
name|'total_buf_len'
op|'-='
name|'len'
op|'('
name|'piece'
op|')'
newline|'\n'
dedent|''
name|'chunks_to_encode'
op|'.'
name|'append'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'pieces'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'frags_by_byte_order'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'chunk_to_encode'
name|'in'
name|'chunks_to_encode'
op|':'
newline|'\n'
indent|'                '
name|'frags_by_byte_order'
op|'.'
name|'append'
op|'('
nl|'\n'
name|'policy'
op|'.'
name|'pyeclib_driver'
op|'.'
name|'encode'
op|'('
name|'chunk_to_encode'
op|')'
op|')'
newline|'\n'
comment|'# Sequential calls to encode() have given us a list that'
nl|'\n'
comment|'# looks like this:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# [[frag_A1, frag_B1, frag_C1, ...],'
nl|'\n'
comment|'#  [frag_A2, frag_B2, frag_C2, ...], ...]'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# What we need is a list like this:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# [(frag_A1 + frag_A2 + ...),  # destined for node A'
nl|'\n'
comment|'#  (frag_B1 + frag_B2 + ...),  # destined for node B'
nl|'\n'
comment|'#  (frag_C1 + frag_C2 + ...),  # destined for node C'
nl|'\n'
comment|'#  ...]'
nl|'\n'
dedent|''
name|'obj_data'
op|'='
op|'['
string|"''"
op|'.'
name|'join'
op|'('
name|'frags'
op|')'
nl|'\n'
name|'for'
name|'frags'
name|'in'
name|'zip'
op|'('
op|'*'
name|'frags_by_byte_order'
op|')'
op|']'
newline|'\n'
name|'chunk'
op|'='
name|'yield'
name|'obj_data'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# didn't have enough data to encode"
nl|'\n'
indent|'            '
name|'chunk'
op|'='
name|'yield'
name|'None'
newline|'\n'
nl|'\n'
comment|"# Now we've gotten an empty chunk, which indicates end-of-input."
nl|'\n'
comment|'# Take any leftover bytes and encode them.'
nl|'\n'
dedent|''
dedent|''
name|'last_bytes'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'buf'
op|')'
newline|'\n'
name|'if'
name|'last_bytes'
op|':'
newline|'\n'
indent|'        '
name|'last_frags'
op|'='
name|'policy'
op|'.'
name|'pyeclib_driver'
op|'.'
name|'encode'
op|'('
name|'last_bytes'
op|')'
newline|'\n'
name|'yield'
name|'last_frags'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'yield'
op|'['
string|"''"
op|']'
op|'*'
name|'nstreams'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|trailing_metadata
dedent|''
dedent|''
name|'def'
name|'trailing_metadata'
op|'('
name|'policy'
op|','
name|'client_obj_hasher'
op|','
nl|'\n'
name|'bytes_transferred_from_client'
op|','
nl|'\n'
name|'fragment_archive_index'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
op|'{'
nl|'\n'
comment|'# etag and size values are being added twice here.'
nl|'\n'
comment|'# The container override header is used to update the container db'
nl|'\n'
comment|'# with these values as they represent the correct etag and size for'
nl|'\n'
comment|'# the whole object and not just the FA.'
nl|'\n'
comment|'# The object sysmeta headers will be saved on each FA of the object.'
nl|'\n'
string|"'X-Object-Sysmeta-EC-Etag'"
op|':'
name|'client_obj_hasher'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|','
nl|'\n'
string|"'X-Object-Sysmeta-EC-Content-Length'"
op|':'
nl|'\n'
name|'str'
op|'('
name|'bytes_transferred_from_client'
op|')'
op|','
nl|'\n'
string|"'X-Backend-Container-Update-Override-Etag'"
op|':'
nl|'\n'
name|'client_obj_hasher'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|','
nl|'\n'
string|"'X-Backend-Container-Update-Override-Size'"
op|':'
nl|'\n'
name|'str'
op|'('
name|'bytes_transferred_from_client'
op|')'
op|','
nl|'\n'
string|"'X-Object-Sysmeta-Ec-Frag-Index'"
op|':'
name|'str'
op|'('
name|'fragment_archive_index'
op|')'
op|','
nl|'\n'
comment|'# These fields are for debuggability,'
nl|'\n'
comment|'# AKA "what is this thing?"'
nl|'\n'
string|"'X-Object-Sysmeta-EC-Scheme'"
op|':'
name|'policy'
op|'.'
name|'ec_scheme_description'
op|','
nl|'\n'
string|"'X-Object-Sysmeta-EC-Segment-Size'"
op|':'
name|'str'
op|'('
name|'policy'
op|'.'
name|'ec_segment_size'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'ObjectControllerRouter'
op|'.'
name|'register'
op|'('
name|'EC_POLICY'
op|')'
newline|'\n'
DECL|class|ECObjectController
name|'class'
name|'ECObjectController'
op|'('
name|'BaseObjectController'
op|')'
op|':'
newline|'\n'
DECL|member|_fragment_GET_request
indent|'    '
name|'def'
name|'_fragment_GET_request'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Makes a GET request for a fragment.\n        """'
newline|'\n'
name|'backend_headers'
op|'='
name|'self'
op|'.'
name|'generate_request_headers'
op|'('
nl|'\n'
name|'req'
op|','
name|'additional'
op|'='
name|'req'
op|'.'
name|'headers'
op|')'
newline|'\n'
nl|'\n'
name|'getter'
op|'='
name|'ResumingGetter'
op|'('
name|'self'
op|'.'
name|'app'
op|','
name|'req'
op|','
string|"'Object'"
op|','
name|'node_iter'
op|','
nl|'\n'
name|'partition'
op|','
name|'req'
op|'.'
name|'swift_entity_path'
op|','
nl|'\n'
name|'backend_headers'
op|','
nl|'\n'
name|'client_chunk_size'
op|'='
name|'policy'
op|'.'
name|'fragment_size'
op|','
nl|'\n'
name|'newest'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
op|'('
name|'getter'
op|','
name|'getter'
op|'.'
name|'response_parts_iter'
op|'('
name|'req'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_convert_range
dedent|''
name|'def'
name|'_convert_range'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Take the requested range(s) from the client and convert it to range(s)\n        to be sent to the object servers.\n\n        This includes widening requested ranges to full segments, then\n        converting those ranges to fragments so that we retrieve the minimum\n        number of fragments from the object server.\n\n        Mutates the request passed in.\n\n        Returns a list of range specs (dictionaries with the different byte\n        indices in them).\n        """'
newline|'\n'
comment|'# Since segments and fragments have different sizes, we need'
nl|'\n'
comment|'# to modify the Range header sent to the object servers to'
nl|'\n'
comment|'# make sure we get the right fragments out of the fragment'
nl|'\n'
comment|'# archives.'
nl|'\n'
name|'segment_size'
op|'='
name|'policy'
op|'.'
name|'ec_segment_size'
newline|'\n'
name|'fragment_size'
op|'='
name|'policy'
op|'.'
name|'fragment_size'
newline|'\n'
nl|'\n'
name|'range_specs'
op|'='
op|'['
op|']'
newline|'\n'
name|'new_ranges'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'client_start'
op|','
name|'client_end'
name|'in'
name|'req'
op|'.'
name|'range'
op|'.'
name|'ranges'
op|':'
newline|'\n'
comment|'# TODO: coalesce ranges that overlap segments. For'
nl|'\n'
comment|'# example, "bytes=0-10,20-30,40-50" with a 64 KiB'
nl|'\n'
comment|'# segment size will result in a a Range header in the'
nl|'\n'
comment|'# object request of "bytes=0-65535,0-65535,0-65535",'
nl|'\n'
comment|'# which is wasteful. We should be smarter and only'
nl|'\n'
comment|'# request that first segment once.'
nl|'\n'
indent|'            '
name|'segment_start'
op|','
name|'segment_end'
op|'='
name|'client_range_to_segment_range'
op|'('
nl|'\n'
name|'client_start'
op|','
name|'client_end'
op|','
name|'segment_size'
op|')'
newline|'\n'
nl|'\n'
name|'fragment_start'
op|','
name|'fragment_end'
op|'='
name|'segment_range_to_fragment_range'
op|'('
nl|'\n'
name|'segment_start'
op|','
name|'segment_end'
op|','
nl|'\n'
name|'segment_size'
op|','
name|'fragment_size'
op|')'
newline|'\n'
nl|'\n'
name|'new_ranges'
op|'.'
name|'append'
op|'('
op|'('
name|'fragment_start'
op|','
name|'fragment_end'
op|')'
op|')'
newline|'\n'
name|'range_specs'
op|'.'
name|'append'
op|'('
op|'{'
string|"'req_client_start'"
op|':'
name|'client_start'
op|','
nl|'\n'
string|"'req_client_end'"
op|':'
name|'client_end'
op|','
nl|'\n'
string|"'req_segment_start'"
op|':'
name|'segment_start'
op|','
nl|'\n'
string|"'req_segment_end'"
op|':'
name|'segment_end'
op|','
nl|'\n'
string|"'req_fragment_start'"
op|':'
name|'fragment_start'
op|','
nl|'\n'
string|"'req_fragment_end'"
op|':'
name|'fragment_end'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'req'
op|'.'
name|'range'
op|'='
string|'"bytes="'
op|'+'
string|'","'
op|'.'
name|'join'
op|'('
nl|'\n'
string|'"%s-%s"'
op|'%'
op|'('
name|'s'
name|'if'
name|'s'
name|'is'
name|'not'
name|'None'
name|'else'
string|'""'
op|','
nl|'\n'
name|'e'
name|'if'
name|'e'
name|'is'
name|'not'
name|'None'
name|'else'
string|'""'
op|')'
nl|'\n'
name|'for'
name|'s'
op|','
name|'e'
name|'in'
name|'new_ranges'
op|')'
newline|'\n'
name|'return'
name|'range_specs'
newline|'\n'
nl|'\n'
DECL|member|_get_or_head_response
dedent|''
name|'def'
name|'_get_or_head_response'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'req'
op|'.'
name|'headers'
op|'.'
name|'setdefault'
op|'('
string|'"X-Backend-Etag-Is-At"'
op|','
nl|'\n'
string|'"X-Object-Sysmeta-Ec-Etag"'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'req'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
op|':'
newline|'\n'
comment|'# no fancy EC decoding here, just one plain old HEAD request to'
nl|'\n'
comment|'# one object server because all fragments hold all metadata'
nl|'\n'
comment|'# information about the object.'
nl|'\n'
indent|'            '
name|'resp'
op|'='
name|'self'
op|'.'
name|'GETorHEAD_base'
op|'('
nl|'\n'
name|'req'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
name|'node_iter'
op|','
name|'partition'
op|','
nl|'\n'
name|'req'
op|'.'
name|'swift_entity_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|'# GET request'
newline|'\n'
indent|'            '
name|'orig_range'
op|'='
name|'None'
newline|'\n'
name|'range_specs'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'req'
op|'.'
name|'range'
op|':'
newline|'\n'
indent|'                '
name|'orig_range'
op|'='
name|'req'
op|'.'
name|'range'
newline|'\n'
name|'range_specs'
op|'='
name|'self'
op|'.'
name|'_convert_range'
op|'('
name|'req'
op|','
name|'policy'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'safe_iter'
op|'='
name|'GreenthreadSafeIterator'
op|'('
name|'node_iter'
op|')'
newline|'\n'
name|'with'
name|'ContextPool'
op|'('
name|'policy'
op|'.'
name|'ec_ndata'
op|')'
name|'as'
name|'pool'
op|':'
newline|'\n'
indent|'                '
name|'pile'
op|'='
name|'GreenAsyncPile'
op|'('
name|'pool'
op|')'
newline|'\n'
name|'for'
name|'_junk'
name|'in'
name|'range'
op|'('
name|'policy'
op|'.'
name|'ec_ndata'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'pile'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_fragment_GET_request'
op|','
nl|'\n'
name|'req'
op|','
name|'safe_iter'
op|','
name|'partition'
op|','
nl|'\n'
name|'policy'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'bad_gets'
op|'='
op|'['
op|']'
newline|'\n'
name|'etag_buckets'
op|'='
name|'collections'
op|'.'
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'best_etag'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'get'
op|','
name|'parts_iter'
name|'in'
name|'pile'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'is_success'
op|'('
name|'get'
op|'.'
name|'last_status'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'etag'
op|'='
name|'HeaderKeyDict'
op|'('
nl|'\n'
name|'get'
op|'.'
name|'last_headers'
op|')'
op|'['
string|"'X-Object-Sysmeta-Ec-Etag'"
op|']'
newline|'\n'
name|'etag_buckets'
op|'['
name|'etag'
op|']'
op|'.'
name|'append'
op|'('
op|'('
name|'get'
op|','
name|'parts_iter'
op|')'
op|')'
newline|'\n'
name|'if'
name|'etag'
op|'!='
name|'best_etag'
name|'and'
op|'('
nl|'\n'
name|'len'
op|'('
name|'etag_buckets'
op|'['
name|'etag'
op|']'
op|')'
op|'>'
nl|'\n'
name|'len'
op|'('
name|'etag_buckets'
op|'['
name|'best_etag'
op|']'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'best_etag'
op|'='
name|'etag'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'bad_gets'
op|'.'
name|'append'
op|'('
op|'('
name|'get'
op|','
name|'parts_iter'
op|')'
op|')'
newline|'\n'
dedent|''
name|'matching_response_count'
op|'='
name|'max'
op|'('
nl|'\n'
name|'len'
op|'('
name|'etag_buckets'
op|'['
name|'best_etag'
op|']'
op|')'
op|','
name|'len'
op|'('
name|'bad_gets'
op|')'
op|')'
newline|'\n'
name|'if'
op|'('
name|'policy'
op|'.'
name|'ec_ndata'
op|'-'
name|'matching_response_count'
op|'>'
nl|'\n'
name|'pile'
op|'.'
name|'_pending'
op|')'
name|'and'
name|'node_iter'
op|'.'
name|'nodes_left'
op|'>'
number|'0'
op|':'
newline|'\n'
comment|'# we need more matching responses to reach ec_ndata'
nl|'\n'
comment|'# than we have pending gets, as long as we still have'
nl|'\n'
comment|'# nodes in node_iter we can spawn another'
nl|'\n'
indent|'                        '
name|'pile'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_fragment_GET_request'
op|','
name|'req'
op|','
nl|'\n'
name|'safe_iter'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'req'
op|'.'
name|'range'
op|'='
name|'orig_range'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'etag_buckets'
op|'['
name|'best_etag'
op|']'
op|')'
op|'>='
name|'policy'
op|'.'
name|'ec_ndata'
op|':'
newline|'\n'
comment|'# headers can come from any of the getters'
nl|'\n'
indent|'                '
name|'resp_headers'
op|'='
name|'HeaderKeyDict'
op|'('
nl|'\n'
name|'etag_buckets'
op|'['
name|'best_etag'
op|']'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'source_headers'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'resp_headers'
op|'.'
name|'pop'
op|'('
string|"'Content-Range'"
op|','
name|'None'
op|')'
newline|'\n'
name|'eccl'
op|'='
name|'resp_headers'
op|'.'
name|'get'
op|'('
string|"'X-Object-Sysmeta-Ec-Content-Length'"
op|')'
newline|'\n'
name|'obj_length'
op|'='
name|'int'
op|'('
name|'eccl'
op|')'
name|'if'
name|'eccl'
name|'is'
name|'not'
name|'None'
name|'else'
name|'None'
newline|'\n'
nl|'\n'
comment|"# This is only true if we didn't get a 206 response, but"
nl|'\n'
comment|"# that's the only time this is used anyway."
nl|'\n'
name|'fa_length'
op|'='
name|'int'
op|'('
name|'resp_headers'
op|'['
string|"'Content-Length'"
op|']'
op|')'
newline|'\n'
name|'app_iter'
op|'='
name|'ECAppIter'
op|'('
nl|'\n'
name|'req'
op|'.'
name|'swift_entity_path'
op|','
nl|'\n'
name|'policy'
op|','
nl|'\n'
op|'['
name|'iterator'
name|'for'
name|'getter'
op|','
name|'iterator'
name|'in'
name|'etag_buckets'
op|'['
name|'best_etag'
op|']'
op|']'
op|','
nl|'\n'
name|'range_specs'
op|','
name|'fa_length'
op|','
name|'obj_length'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|')'
newline|'\n'
name|'resp'
op|'='
name|'Response'
op|'('
nl|'\n'
name|'request'
op|'='
name|'req'
op|','
nl|'\n'
name|'headers'
op|'='
name|'resp_headers'
op|','
nl|'\n'
name|'conditional_response'
op|'='
name|'True'
op|','
nl|'\n'
name|'app_iter'
op|'='
name|'app_iter'
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'accept_ranges'
op|'='
string|"'bytes'"
newline|'\n'
name|'app_iter'
op|'.'
name|'kickoff'
op|'('
name|'req'
op|','
name|'resp'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'statuses'
op|'='
op|'['
op|']'
newline|'\n'
name|'reasons'
op|'='
op|'['
op|']'
newline|'\n'
name|'bodies'
op|'='
op|'['
op|']'
newline|'\n'
name|'headers'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'getter'
op|','
name|'body_parts_iter'
name|'in'
name|'bad_gets'
op|':'
newline|'\n'
indent|'                    '
name|'statuses'
op|'.'
name|'extend'
op|'('
name|'getter'
op|'.'
name|'statuses'
op|')'
newline|'\n'
name|'reasons'
op|'.'
name|'extend'
op|'('
name|'getter'
op|'.'
name|'reasons'
op|')'
newline|'\n'
name|'bodies'
op|'.'
name|'extend'
op|'('
name|'getter'
op|'.'
name|'bodies'
op|')'
newline|'\n'
name|'headers'
op|'.'
name|'extend'
op|'('
name|'getter'
op|'.'
name|'source_headers'
op|')'
newline|'\n'
dedent|''
name|'resp'
op|'='
name|'self'
op|'.'
name|'best_response'
op|'('
nl|'\n'
name|'req'
op|','
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
string|"'Object'"
op|','
nl|'\n'
name|'headers'
op|'='
name|'headers'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_fix_response'
op|'('
name|'resp'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
DECL|member|_fix_response
dedent|''
name|'def'
name|'_fix_response'
op|'('
name|'self'
op|','
name|'resp'
op|')'
op|':'
newline|'\n'
comment|'# EC fragment archives each have different bytes, hence different'
nl|'\n'
comment|"# etags. However, they all have the original object's etag stored in"
nl|'\n'
comment|'# sysmeta, so we copy that here so the client gets it.'
nl|'\n'
indent|'        '
name|'if'
name|'is_success'
op|'('
name|'resp'
op|'.'
name|'status_int'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'Etag'"
op|']'
op|'='
name|'resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'X-Object-Sysmeta-Ec-Etag'"
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'headers'
op|'['
string|"'Content-Length'"
op|']'
op|'='
name|'resp'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'X-Object-Sysmeta-Ec-Content-Length'"
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'fix_conditional_response'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_connect_put_node
dedent|''
dedent|''
name|'def'
name|'_connect_put_node'
op|'('
name|'self'
op|','
name|'node_iter'
op|','
name|'part'
op|','
name|'path'
op|','
name|'headers'
op|','
nl|'\n'
name|'logger_thread_locals'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make a connection for a erasure encoded object.\n\n        Connects to the first working node that it finds in node_iter and sends\n        over the request headers. Returns a Putter to handle the rest of the\n        streaming, or None if no working nodes were found.\n        """'
newline|'\n'
comment|'# the object server will get different bytes, so these'
nl|'\n'
comment|'# values do not apply (Content-Length might, in general, but'
nl|'\n'
comment|"# in the specific case of replication vs. EC, it doesn't)."
nl|'\n'
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'Content-Length'"
op|','
name|'None'
op|')'
newline|'\n'
name|'headers'
op|'.'
name|'pop'
op|'('
string|"'Etag'"
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|'='
name|'logger_thread_locals'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'node_iter'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'putter'
op|'='
name|'ECPutter'
op|'.'
name|'connect'
op|'('
nl|'\n'
name|'node'
op|','
name|'part'
op|','
name|'path'
op|','
name|'headers'
op|','
nl|'\n'
name|'conn_timeout'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'conn_timeout'
op|','
nl|'\n'
name|'node_timeout'
op|'='
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'set_node_timing'
op|'('
name|'node'
op|','
name|'putter'
op|'.'
name|'connect_duration'
op|')'
newline|'\n'
name|'return'
name|'putter'
newline|'\n'
dedent|''
name|'except'
name|'InsufficientStorage'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_limit'
op|'('
name|'node'
op|','
name|'_'
op|'('
string|"'ERROR Insufficient Storage'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PutterConnectError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_occurred'
op|'('
nl|'\n'
name|'node'
op|','
name|'_'
op|'('
string|"'ERROR %(status)d Expect: 100-continue '"
nl|'\n'
string|"'From Object Server'"
op|')'
op|'%'
op|'{'
nl|'\n'
string|"'status'"
op|':'
name|'e'
op|'.'
name|'status'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|'('
nl|'\n'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Expect: 100-continue on %s'"
op|')'
op|'%'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_determine_chunk_destinations
dedent|''
dedent|''
dedent|''
name|'def'
name|'_determine_chunk_destinations'
op|'('
name|'self'
op|','
name|'putters'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a list of putters, return a dict where the key is the putter\n        and the value is the node index to use.\n\n        This is done so that we line up handoffs using the same node index\n        (in the primary part list) as the primary that the handoff is standing\n        in for.  This lets erasure-code fragment archives wind up on the\n        preferred local primary nodes when possible.\n        """'
newline|'\n'
comment|'# Give each putter a "chunk index": the index of the'
nl|'\n'
comment|"# transformed chunk that we'll send to it."
nl|'\n'
comment|'#'
nl|'\n'
comment|"# For primary nodes, that's just its index (primary 0 gets"
nl|'\n'
comment|'# chunk 0, primary 1 gets chunk 1, and so on). For handoffs,'
nl|'\n'
comment|'# we assign the chunk index of a missing primary.'
nl|'\n'
name|'handoff_conns'
op|'='
op|'['
op|']'
newline|'\n'
name|'chunk_index'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'p'
op|'.'
name|'node_index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'chunk_index'
op|'['
name|'p'
op|']'
op|'='
name|'p'
op|'.'
name|'node_index'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'handoff_conns'
op|'.'
name|'append'
op|'('
name|'p'
op|')'
newline|'\n'
nl|'\n'
comment|'# Note: we may have more holes than handoffs. This is okay; it'
nl|'\n'
comment|'# just means that we failed to connect to one or more storage'
nl|'\n'
comment|'# nodes. Holes occur when a storage node is down, in which'
nl|'\n'
comment|'# case the connection is not replaced, and when a storage node'
nl|'\n'
comment|'# returns 507, in which case a handoff is used to replace it.'
nl|'\n'
dedent|''
dedent|''
name|'holes'
op|'='
op|'['
name|'x'
name|'for'
name|'x'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'putters'
op|')'
op|')'
nl|'\n'
name|'if'
name|'x'
name|'not'
name|'in'
name|'chunk_index'
op|'.'
name|'values'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'hole'
op|','
name|'p'
name|'in'
name|'zip'
op|'('
name|'holes'
op|','
name|'handoff_conns'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'chunk_index'
op|'['
name|'p'
op|']'
op|'='
name|'hole'
newline|'\n'
dedent|''
name|'return'
name|'chunk_index'
newline|'\n'
nl|'\n'
DECL|member|_transfer_data
dedent|''
name|'def'
name|'_transfer_data'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'policy'
op|','
name|'data_source'
op|','
name|'putters'
op|','
name|'nodes'
op|','
nl|'\n'
name|'min_conns'
op|','
name|'etag_hasher'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Transfer data for an erasure coded object.\n\n        This method was added in the PUT method extraction change\n        """'
newline|'\n'
name|'bytes_transferred'
op|'='
number|'0'
newline|'\n'
name|'chunk_transform'
op|'='
name|'chunk_transformer'
op|'('
name|'policy'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|')'
newline|'\n'
name|'chunk_transform'
op|'.'
name|'send'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|function|send_chunk
name|'def'
name|'send_chunk'
op|'('
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'etag_hasher'
op|':'
newline|'\n'
indent|'                '
name|'etag_hasher'
op|'.'
name|'update'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'backend_chunks'
op|'='
name|'chunk_transform'
op|'.'
name|'send'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'backend_chunks'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# If there's not enough bytes buffered for erasure-encoding"
nl|'\n'
comment|"# or whatever we're doing, the transform will give us None."
nl|'\n'
indent|'                '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'putter'
name|'in'
name|'list'
op|'('
name|'putters'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'backend_chunk'
op|'='
name|'backend_chunks'
op|'['
name|'chunk_index'
op|'['
name|'putter'
op|']'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'putter'
op|'.'
name|'failed'
op|':'
newline|'\n'
indent|'                    '
name|'putter'
op|'.'
name|'chunk_hasher'
op|'.'
name|'update'
op|'('
name|'backend_chunk'
op|')'
newline|'\n'
name|'putter'
op|'.'
name|'send_chunk'
op|'('
name|'backend_chunk'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'putters'
op|'.'
name|'remove'
op|'('
name|'putter'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_check_min_conn'
op|'('
nl|'\n'
name|'req'
op|','
name|'putters'
op|','
name|'min_conns'
op|','
name|'msg'
op|'='
string|"'Object PUT exceptions during'"
nl|'\n'
string|"' send, %(conns)s/%(nodes)s required connections'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'ContextPool'
op|'('
name|'len'
op|'('
name|'putters'
op|')'
op|')'
name|'as'
name|'pool'
op|':'
newline|'\n'
nl|'\n'
comment|'# build our chunk index dict to place handoffs in the'
nl|'\n'
comment|'# same part nodes index as the primaries they are covering'
nl|'\n'
indent|'                '
name|'chunk_index'
op|'='
name|'self'
op|'.'
name|'_determine_chunk_destinations'
op|'('
name|'putters'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'                    '
name|'putter'
op|'.'
name|'spawn_sender_greenthread'
op|'('
nl|'\n'
name|'pool'
op|','
name|'self'
op|'.'
name|'app'
op|'.'
name|'put_queue_depth'
op|','
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|')'
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'ChunkReadTimeout'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'client_timeout'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'try'
op|':'
newline|'\n'
indent|'                            '
name|'chunk'
op|'='
name|'next'
op|'('
name|'data_source'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
indent|'                            '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'bytes_transferred'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'bytes_transferred'
op|'>'
name|'constraints'
op|'.'
name|'MAX_FILE_SIZE'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'HTTPRequestEntityTooLarge'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'send_chunk'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'req'
op|'.'
name|'content_length'
name|'and'
op|'('
nl|'\n'
name|'bytes_transferred'
op|'<'
name|'req'
op|'.'
name|'content_length'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'req'
op|'.'
name|'client_disconnect'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client disconnected without sending enough data'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_disconnects'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'computed_etag'
op|'='
op|'('
name|'etag_hasher'
op|'.'
name|'hexdigest'
op|'('
op|')'
nl|'\n'
name|'if'
name|'etag_hasher'
name|'else'
name|'None'
op|')'
newline|'\n'
name|'received_etag'
op|'='
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'etag'"
op|','
string|"''"
op|')'
op|'.'
name|'strip'
op|'('
string|'\'"\''
op|')'
newline|'\n'
name|'if'
op|'('
name|'computed_etag'
name|'and'
name|'received_etag'
name|'and'
nl|'\n'
name|'computed_etag'
op|'!='
name|'received_etag'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'HTTPUnprocessableEntity'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'send_chunk'
op|'('
string|"''"
op|')'
comment|'# flush out any buffered data'
newline|'\n'
nl|'\n'
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'                    '
name|'trail_md'
op|'='
name|'trailing_metadata'
op|'('
nl|'\n'
name|'policy'
op|','
name|'etag_hasher'
op|','
nl|'\n'
name|'bytes_transferred'
op|','
nl|'\n'
name|'chunk_index'
op|'['
name|'putter'
op|']'
op|')'
newline|'\n'
name|'trail_md'
op|'['
string|"'Etag'"
op|']'
op|'='
name|'putter'
op|'.'
name|'chunk_hasher'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
name|'putter'
op|'.'
name|'end_of_object_data'
op|'('
name|'trail_md'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'                    '
name|'putter'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# for storage policies requiring 2-phase commit (e.g.'
nl|'\n'
comment|"# erasure coding), enforce >= 'quorum' number of"
nl|'\n'
comment|'# 100-continue responses - this indicates successful'
nl|'\n'
comment|'# object data and metadata commit and is a necessary'
nl|'\n'
comment|'# condition to be met before starting 2nd PUT phase'
nl|'\n'
dedent|''
name|'final_phase'
op|'='
name|'False'
newline|'\n'
name|'need_quorum'
op|'='
name|'True'
newline|'\n'
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
name|'_junk'
op|','
name|'quorum'
op|'='
name|'self'
op|'.'
name|'_get_put_responses'
op|'('
nl|'\n'
name|'req'
op|','
name|'putters'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|','
name|'final_phase'
op|','
nl|'\n'
name|'min_conns'
op|','
name|'need_quorum'
op|'='
name|'need_quorum'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'quorum'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Not enough object servers ack\\'ed (got %d)'"
op|')'
op|','
nl|'\n'
name|'statuses'
op|'.'
name|'count'
op|'('
name|'HTTP_CONTINUE'
op|')'
op|')'
newline|'\n'
name|'raise'
name|'HTTPServiceUnavailable'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'not'
name|'self'
op|'.'
name|'_have_adequate_informational'
op|'('
nl|'\n'
name|'statuses'
op|','
name|'min_conns'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'resp'
op|'='
name|'self'
op|'.'
name|'best_response'
op|'('
name|'req'
op|','
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Object PUT'"
op|')'
op|','
nl|'\n'
name|'quorum_size'
op|'='
name|'min_conns'
op|')'
newline|'\n'
name|'if'
name|'is_client_error'
op|'('
name|'resp'
op|'.'
name|'status_int'
op|')'
op|':'
newline|'\n'
comment|'# if 4xx occurred in this state it is absolutely'
nl|'\n'
comment|'# a bad conversation between proxy-server and'
nl|'\n'
comment|"# object-server (even if it's"
nl|'\n'
comment|'# HTTP_UNPROCESSABLE_ENTITY) so we should regard this'
nl|'\n'
comment|'# as HTTPServiceUnavailable.'
nl|'\n'
indent|'                        '
name|'raise'
name|'HTTPServiceUnavailable'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Other errors should use raw best_response'
nl|'\n'
indent|'                        '
name|'raise'
name|'resp'
newline|'\n'
nl|'\n'
comment|'# quorum achieved, start 2nd phase - send commit'
nl|'\n'
comment|'# confirmation to participating object servers'
nl|'\n'
comment|'# so they write a .durable state file indicating'
nl|'\n'
comment|'# a successful PUT'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'                    '
name|'putter'
op|'.'
name|'send_commit_confirmation'
op|'('
op|')'
newline|'\n'
dedent|''
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'                    '
name|'putter'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'ChunkReadTimeout'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Client read timeout (%ss)'"
op|')'
op|','
name|'err'
op|'.'
name|'seconds'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_timeouts'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPRequestTimeout'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ChunkReadError'
op|':'
newline|'\n'
indent|'            '
name|'req'
op|'.'
name|'client_disconnect'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client disconnected without sending last chunk'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'client_disconnects'"
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'HTTPException'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'except'
name|'Timeout'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Exception causing client disconnect'"
op|')'
op|')'
newline|'\n'
name|'raise'
name|'HTTPClientDisconnect'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'ERROR Exception transferring data to object servers %s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'req'
op|'.'
name|'path'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'HTTPInternalServerError'
op|'('
name|'request'
op|'='
name|'req'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_have_adequate_responses
dedent|''
dedent|''
name|'def'
name|'_have_adequate_responses'
op|'('
nl|'\n'
name|'self'
op|','
name|'statuses'
op|','
name|'min_responses'
op|','
name|'conditional_func'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a list of statuses from several requests, determine if a\n        satisfactory number of nodes have responded with 1xx or 2xx statuses to\n        deem the transaction for a succssful response to the client.\n\n        :param statuses: list of statuses returned so far\n        :param min_responses: minimal pass criterion for number of successes\n        :param conditional_func: a callable function to check http status code\n        :returns: True or False, depending on current number of successes\n        """'
newline|'\n'
name|'if'
name|'sum'
op|'('
number|'1'
name|'for'
name|'s'
name|'in'
name|'statuses'
name|'if'
op|'('
name|'conditional_func'
op|'('
name|'s'
op|')'
op|')'
op|')'
op|'>='
name|'min_responses'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_have_adequate_successes
dedent|''
name|'def'
name|'_have_adequate_successes'
op|'('
name|'self'
op|','
name|'statuses'
op|','
name|'min_responses'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Partial method of _have_adequate_responses for 2xx\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_have_adequate_responses'
op|'('
nl|'\n'
name|'statuses'
op|','
name|'min_responses'
op|','
name|'is_success'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_have_adequate_informational
dedent|''
name|'def'
name|'_have_adequate_informational'
op|'('
name|'self'
op|','
name|'statuses'
op|','
name|'min_responses'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Partial method of _have_adequate_responses for 1xx\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_have_adequate_responses'
op|'('
nl|'\n'
name|'statuses'
op|','
name|'min_responses'
op|','
name|'is_informational'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_await_response
dedent|''
name|'def'
name|'_await_response'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'final_phase'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'conn'
op|'.'
name|'await_response'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'node_timeout'
op|','
name|'not'
name|'final_phase'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_conn_response
dedent|''
name|'def'
name|'_get_conn_response'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'req'
op|','
name|'logger_thread_locals'
op|','
nl|'\n'
name|'final_phase'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|'='
name|'logger_thread_locals'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'='
name|'self'
op|'.'
name|'_await_response'
op|'('
name|'conn'
op|','
name|'final_phase'
op|'='
name|'final_phase'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'resp'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'final_phase'
op|':'
newline|'\n'
indent|'                '
name|'status_type'
op|'='
string|"'final'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'status_type'
op|'='
string|"'commit'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'app'
op|'.'
name|'exception_occurred'
op|'('
nl|'\n'
name|'conn'
op|'.'
name|'node'
op|','
name|'_'
op|'('
string|"'Object'"
op|')'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Trying to get %s status of PUT to %s'"
op|')'
op|'%'
op|'('
nl|'\n'
name|'status_type'
op|','
name|'req'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'('
name|'conn'
op|','
name|'resp'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_put_responses
dedent|''
name|'def'
name|'_get_put_responses'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'putters'
op|','
name|'num_nodes'
op|','
name|'final_phase'
op|','
nl|'\n'
name|'min_responses'
op|','
name|'need_quorum'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Collect erasure coded object responses.\n\n        Collect object responses to a PUT request and determine if\n        satisfactory number of nodes have returned success.  Return\n        statuses, quorum result if indicated by \'need_quorum\' and\n        etags if this is a final phase or a multiphase PUT transaction.\n\n        :param req: the request\n        :param putters: list of putters for the request\n        :param num_nodes: number of nodes involved\n        :param final_phase: boolean indicating if this is the last phase\n        :param min_responses: minimum needed when not requiring quorum\n        :param need_quorum: boolean indicating if quorum is required\n        """'
newline|'\n'
name|'statuses'
op|'='
op|'['
op|']'
newline|'\n'
name|'reasons'
op|'='
op|'['
op|']'
newline|'\n'
name|'bodies'
op|'='
op|'['
op|']'
newline|'\n'
name|'etags'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'pile'
op|'='
name|'GreenAsyncPile'
op|'('
name|'len'
op|'('
name|'putters'
op|')'
op|')'
newline|'\n'
name|'for'
name|'putter'
name|'in'
name|'putters'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'putter'
op|'.'
name|'failed'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'pile'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_get_conn_response'
op|','
name|'putter'
op|','
name|'req'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'logger'
op|'.'
name|'thread_locals'
op|','
name|'final_phase'
op|'='
name|'final_phase'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_handle_response
dedent|''
name|'def'
name|'_handle_response'
op|'('
name|'putter'
op|','
name|'response'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'statuses'
op|'.'
name|'append'
op|'('
name|'response'
op|'.'
name|'status'
op|')'
newline|'\n'
name|'reasons'
op|'.'
name|'append'
op|'('
name|'response'
op|'.'
name|'reason'
op|')'
newline|'\n'
name|'if'
name|'final_phase'
op|':'
newline|'\n'
indent|'                '
name|'body'
op|'='
name|'response'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'body'
op|'='
string|"''"
newline|'\n'
dedent|''
name|'bodies'
op|'.'
name|'append'
op|'('
name|'body'
op|')'
newline|'\n'
name|'if'
name|'response'
op|'.'
name|'status'
op|'=='
name|'HTTP_INSUFFICIENT_STORAGE'
op|':'
newline|'\n'
indent|'                '
name|'putter'
op|'.'
name|'failed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_limit'
op|'('
name|'putter'
op|'.'
name|'node'
op|','
nl|'\n'
name|'_'
op|'('
string|"'ERROR Insufficient Storage'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'response'
op|'.'
name|'status'
op|'>='
name|'HTTP_INTERNAL_SERVER_ERROR'
op|':'
newline|'\n'
indent|'                '
name|'putter'
op|'.'
name|'failed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'app'
op|'.'
name|'error_occurred'
op|'('
nl|'\n'
name|'putter'
op|'.'
name|'node'
op|','
nl|'\n'
name|'_'
op|'('
string|"'ERROR %(status)d %(body)s From Object Server '"
nl|'\n'
string|"'re: %(path)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'status'"
op|':'
name|'response'
op|'.'
name|'status'
op|','
nl|'\n'
string|"'body'"
op|':'
name|'body'
op|'['
op|':'
number|'1024'
op|']'
op|','
string|"'path'"
op|':'
name|'req'
op|'.'
name|'path'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'is_success'
op|'('
name|'response'
op|'.'
name|'status'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'etags'
op|'.'
name|'add'
op|'('
name|'response'
op|'.'
name|'getheader'
op|'('
string|"'etag'"
op|')'
op|'.'
name|'strip'
op|'('
string|'\'"\''
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'quorum'
op|'='
name|'False'
newline|'\n'
name|'for'
op|'('
name|'putter'
op|','
name|'response'
op|')'
name|'in'
name|'pile'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'response'
op|':'
newline|'\n'
indent|'                '
name|'_handle_response'
op|'('
name|'putter'
op|','
name|'response'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_have_adequate_successes'
op|'('
name|'statuses'
op|','
name|'min_responses'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'putter'
op|'.'
name|'failed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# give any pending requests *some* chance to finish'
nl|'\n'
dedent|''
dedent|''
name|'finished_quickly'
op|'='
name|'pile'
op|'.'
name|'waitall'
op|'('
name|'self'
op|'.'
name|'app'
op|'.'
name|'post_quorum_timeout'
op|')'
newline|'\n'
name|'for'
op|'('
name|'putter'
op|','
name|'response'
op|')'
name|'in'
name|'finished_quickly'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'response'
op|':'
newline|'\n'
indent|'                '
name|'_handle_response'
op|'('
name|'putter'
op|','
name|'response'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'need_quorum'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'final_phase'
op|':'
newline|'\n'
indent|'                '
name|'while'
name|'len'
op|'('
name|'statuses'
op|')'
op|'<'
name|'num_nodes'
op|':'
newline|'\n'
indent|'                    '
name|'statuses'
op|'.'
name|'append'
op|'('
name|'HTTP_SERVICE_UNAVAILABLE'
op|')'
newline|'\n'
name|'reasons'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
name|'bodies'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# intermediate response phase - set return value to true only'
nl|'\n'
comment|'# if there are responses having same value of *any* status'
nl|'\n'
comment|'# except 5xx'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'have_quorum'
op|'('
name|'statuses'
op|','
name|'num_nodes'
op|','
name|'quorum'
op|'='
name|'min_responses'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'quorum'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
name|'etags'
op|','
name|'quorum'
newline|'\n'
nl|'\n'
DECL|member|_store_object
dedent|''
name|'def'
name|'_store_object'
op|'('
name|'self'
op|','
name|'req'
op|','
name|'data_source'
op|','
name|'nodes'
op|','
name|'partition'
op|','
nl|'\n'
name|'outgoing_headers'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Store an erasure coded object.\n        """'
newline|'\n'
name|'policy_index'
op|'='
name|'int'
op|'('
name|'req'
op|'.'
name|'headers'
op|'.'
name|'get'
op|'('
string|"'X-Backend-Storage-Policy-Index'"
op|')'
op|')'
newline|'\n'
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'get_by_index'
op|'('
name|'policy_index'
op|')'
newline|'\n'
comment|'# Since the request body sent from client -> proxy is not'
nl|'\n'
comment|'# the same as the request body sent proxy -> object, we'
nl|'\n'
comment|"# can't rely on the object-server to do the etag checking -"
nl|'\n'
comment|'# so we have to do it here.'
nl|'\n'
name|'etag_hasher'
op|'='
name|'md5'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'min_conns'
op|'='
name|'policy'
op|'.'
name|'quorum'
newline|'\n'
name|'putters'
op|'='
name|'self'
op|'.'
name|'_get_put_connections'
op|'('
nl|'\n'
name|'req'
op|','
name|'nodes'
op|','
name|'partition'
op|','
name|'outgoing_headers'
op|','
nl|'\n'
name|'policy'
op|','
name|'expect'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# check that a minimum number of connections were established and'
nl|'\n'
comment|'# meet all the correct conditions set in the request'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_check_failure_put_connections'
op|'('
name|'putters'
op|','
name|'req'
op|','
name|'nodes'
op|','
name|'min_conns'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_transfer_data'
op|'('
name|'req'
op|','
name|'policy'
op|','
name|'data_source'
op|','
name|'putters'
op|','
nl|'\n'
name|'nodes'
op|','
name|'min_conns'
op|','
name|'etag_hasher'
op|')'
newline|'\n'
name|'final_phase'
op|'='
name|'True'
newline|'\n'
name|'need_quorum'
op|'='
name|'False'
newline|'\n'
comment|'# The .durable file will propagate in a replicated fashion; if'
nl|'\n'
comment|'# one exists, the reconstructor will spread it around.'
nl|'\n'
comment|'# In order to avoid successfully writing an object, but refusing'
nl|'\n'
comment|"# to serve it on a subsequent GET because don't have enough"
nl|'\n'
comment|'# durable data fragments - we require the same number of durable'
nl|'\n'
comment|'# writes as quorum fragment writes.  If object servers are in the'
nl|'\n'
comment|'# future able to serve their non-durable fragment archives we may'
nl|'\n'
comment|'# be able to reduce this quorum count if needed.'
nl|'\n'
name|'min_conns'
op|'='
name|'policy'
op|'.'
name|'quorum'
newline|'\n'
name|'putters'
op|'='
op|'['
name|'p'
name|'for'
name|'p'
name|'in'
name|'putters'
name|'if'
name|'not'
name|'p'
op|'.'
name|'failed'
op|']'
newline|'\n'
comment|'# ignore response etags, and quorum boolean'
nl|'\n'
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
name|'_etags'
op|','
name|'_quorum'
op|'='
name|'self'
op|'.'
name|'_get_put_responses'
op|'('
name|'req'
op|','
name|'putters'
op|','
name|'len'
op|'('
name|'nodes'
op|')'
op|','
nl|'\n'
name|'final_phase'
op|','
name|'min_conns'
op|','
nl|'\n'
name|'need_quorum'
op|'='
name|'need_quorum'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'HTTPException'
name|'as'
name|'resp'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'resp'
newline|'\n'
nl|'\n'
dedent|''
name|'etag'
op|'='
name|'etag_hasher'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
name|'resp'
op|'='
name|'self'
op|'.'
name|'best_response'
op|'('
name|'req'
op|','
name|'statuses'
op|','
name|'reasons'
op|','
name|'bodies'
op|','
nl|'\n'
name|'_'
op|'('
string|"'Object PUT'"
op|')'
op|','
name|'etag'
op|'='
name|'etag'
op|','
nl|'\n'
name|'quorum_size'
op|'='
name|'min_conns'
op|')'
newline|'\n'
name|'resp'
op|'.'
name|'last_modified'
op|'='
name|'math'
op|'.'
name|'ceil'
op|'('
nl|'\n'
name|'float'
op|'('
name|'Timestamp'
op|'('
name|'req'
op|'.'
name|'headers'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'resp'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
