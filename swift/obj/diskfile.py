begin_unit
comment|'# Copyright (c) 2010-2013 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or'
nl|'\n'
comment|'# implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
string|'"""\nDisk File Interface for the Swift Object Server\n\nThe `DiskFile`, `DiskFileWriter` and `DiskFileReader` classes combined define\nthe on-disk abstraction layer for supporting the object server REST API\ninterfaces (excluding `REPLICATE`). Other implementations wishing to provide\nan alternative backend for the object server must implement the three\nclasses. An example alternative implementation can be found in the\n`mem_server.py` and `mem_diskfile.py` modules along size this one.\n\nThe `DiskFileManager` is a reference implemenation specific class and is not\npart of the backend API.\n\nThe remaining methods in this module are considered implementation specific and\nare also not considered part of the backend API.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'fcntl'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'import'
name|'hashlib'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
name|'import'
name|'xattr'
newline|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'basename'
op|','
name|'dirname'
op|','
name|'exists'
op|','
name|'getmtime'
op|','
name|'join'
op|','
name|'splitext'
newline|'\n'
name|'from'
name|'random'
name|'import'
name|'shuffle'
newline|'\n'
name|'from'
name|'tempfile'
name|'import'
name|'mkstemp'
newline|'\n'
name|'from'
name|'contextlib'
name|'import'
name|'contextmanager'
newline|'\n'
name|'from'
name|'collections'
name|'import'
name|'defaultdict'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'Timeout'
newline|'\n'
name|'from'
name|'eventlet'
op|'.'
name|'hubs'
name|'import'
name|'trampoline'
newline|'\n'
nl|'\n'
name|'from'
name|'swift'
name|'import'
name|'gettext_'
name|'as'
name|'_'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'constraints'
name|'import'
name|'check_mount'
op|','
name|'check_dir'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'request_helpers'
name|'import'
name|'is_sys_meta'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'utils'
name|'import'
name|'mkdirs'
op|','
name|'Timestamp'
op|','
name|'storage_directory'
op|','
name|'hash_path'
op|','
name|'renamer'
op|','
name|'fallocate'
op|','
name|'fsync'
op|','
name|'fdatasync'
op|','
name|'drop_buffer_cache'
op|','
name|'ThreadPool'
op|','
name|'lock_path'
op|','
name|'write_pickle'
op|','
name|'config_true_value'
op|','
name|'listdir'
op|','
name|'split_path'
op|','
name|'ismount'
op|','
name|'remove_file'
op|','
name|'get_md5_socket'
op|','
name|'F_SETPIPE_SZ'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'splice'
name|'import'
name|'splice'
op|','
name|'tee'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'exceptions'
name|'import'
name|'DiskFileQuarantined'
op|','
name|'DiskFileNotExist'
op|','
name|'DiskFileCollision'
op|','
name|'DiskFileNoSpace'
op|','
name|'DiskFileDeviceUnavailable'
op|','
name|'DiskFileDeleted'
op|','
name|'DiskFileError'
op|','
name|'DiskFileNotOpen'
op|','
name|'PathNotDir'
op|','
name|'ReplicationLockTimeout'
op|','
name|'DiskFileExpired'
op|','
name|'DiskFileXattrNotSupported'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'swob'
name|'import'
name|'multi_range_iterator'
newline|'\n'
name|'from'
name|'swift'
op|'.'
name|'common'
op|'.'
name|'storage_policy'
name|'import'
op|'('
nl|'\n'
name|'get_policy_string'
op|','
name|'split_policy_string'
op|','
name|'PolicyError'
op|','
name|'POLICIES'
op|','
nl|'\n'
name|'REPL_POLICY'
op|','
name|'EC_POLICY'
op|')'
newline|'\n'
name|'from'
name|'functools'
name|'import'
name|'partial'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|PICKLE_PROTOCOL
name|'PICKLE_PROTOCOL'
op|'='
number|'2'
newline|'\n'
DECL|variable|ONE_WEEK
name|'ONE_WEEK'
op|'='
number|'604800'
newline|'\n'
DECL|variable|HASH_FILE
name|'HASH_FILE'
op|'='
string|"'hashes.pkl'"
newline|'\n'
DECL|variable|METADATA_KEY
name|'METADATA_KEY'
op|'='
string|"'user.swift.metadata'"
newline|'\n'
DECL|variable|DROP_CACHE_WINDOW
name|'DROP_CACHE_WINDOW'
op|'='
number|'1024'
op|'*'
number|'1024'
newline|'\n'
comment|'# These are system-set metadata keys that cannot be changed with a POST.'
nl|'\n'
comment|'# They should be lowercase.'
nl|'\n'
DECL|variable|DATAFILE_SYSTEM_META
name|'DATAFILE_SYSTEM_META'
op|'='
name|'set'
op|'('
string|"'content-length content-type deleted etag'"
op|'.'
name|'split'
op|'('
op|')'
op|')'
newline|'\n'
DECL|variable|DATADIR_BASE
name|'DATADIR_BASE'
op|'='
string|"'objects'"
newline|'\n'
DECL|variable|ASYNCDIR_BASE
name|'ASYNCDIR_BASE'
op|'='
string|"'async_pending'"
newline|'\n'
DECL|variable|TMP_BASE
name|'TMP_BASE'
op|'='
string|"'tmp'"
newline|'\n'
DECL|variable|get_data_dir
name|'get_data_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'DATADIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_async_dir
name|'get_async_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'ASYNCDIR_BASE'
op|')'
newline|'\n'
DECL|variable|get_tmp_dir
name|'get_tmp_dir'
op|'='
name|'partial'
op|'('
name|'get_policy_string'
op|','
name|'TMP_BASE'
op|')'
newline|'\n'
DECL|variable|MD5_OF_EMPTY_STRING
name|'MD5_OF_EMPTY_STRING'
op|'='
string|"'d41d8cd98f00b204e9800998ecf8427e'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_filename
name|'def'
name|'_get_filename'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to get to file name from a file descriptor or filename.\n\n    :param fd: file descriptor or filename.\n\n    :returns: the filename.\n    """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'fd'
op|','
string|"'name'"
op|')'
op|':'
newline|'\n'
comment|'# fd object'
nl|'\n'
indent|'        '
name|'return'
name|'fd'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
comment|'# fd is a filename'
nl|'\n'
dedent|''
name|'return'
name|'fd'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|read_metadata
dedent|''
name|'def'
name|'read_metadata'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to read the pickled metadata from an object file.\n\n    :param fd: file descriptor or filename to load the metadata from\n\n    :returns: dictionary of metadata\n    """'
newline|'\n'
name|'metadata'
op|'='
string|"''"
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'+='
name|'xattr'
op|'.'
name|'getxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
nl|'\n'
op|'('
name|'key'
name|'or'
string|"''"
op|')'
op|')'
op|')'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'err'
name|'in'
string|"'ENOTSUP'"
op|','
string|"'EOPNOTSUPP'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
name|'and'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'getattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
string|'"Filesystem at %s does not support xattr"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileXattrNotSupported'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|write_metadata
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'fd'
op|','
name|'metadata'
op|','
name|'xattr_size'
op|'='
number|'65536'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function to write pickled metadata for an object file.\n\n    :param fd: file descriptor or filename to write the metadata\n    :param metadata: metadata to write\n    """'
newline|'\n'
name|'metastr'
op|'='
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'metadata'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'key'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'metastr'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'xattr'
op|'.'
name|'setxattr'
op|'('
name|'fd'
op|','
string|"'%s%s'"
op|'%'
op|'('
name|'METADATA_KEY'
op|','
name|'key'
name|'or'
string|"''"
op|')'
op|','
nl|'\n'
name|'metastr'
op|'['
op|':'
name|'xattr_size'
op|']'
op|')'
newline|'\n'
name|'metastr'
op|'='
name|'metastr'
op|'['
name|'xattr_size'
op|':'
op|']'
newline|'\n'
name|'key'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'err'
name|'in'
string|"'ENOTSUP'"
op|','
string|"'EOPNOTSUPP'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'hasattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
name|'and'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'getattr'
op|'('
name|'errno'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'msg'
op|'='
string|'"Filesystem at %s does not support xattr"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileXattrNotSupported'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'e'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
string|'"No space left on device for %s"'
op|'%'
name|'_get_filename'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|extract_policy
dedent|''
dedent|''
dedent|''
name|'def'
name|'extract_policy'
op|'('
name|'obj_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Extracts the policy for an object (based on the name of the objects\n    directory) given the device-relative path to the object. Returns None in\n    the event that the path is malformed in some way.\n\n    The device-relative path is everything after the mount point; for example:\n\n    /srv/node/d42/objects-5/179/\n        485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    would have device-relative path:\n\n    objects-5/179/485dc017205a81df3af616d917c90179/1401811134.873649.data\n\n    :param obj_path: device-relative path of an object\n    :returns: a :class:`~swift.common.storage_policy.BaseStoragePolicy` or None\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'obj_portion'
op|'='
name|'obj_path'
op|'['
name|'obj_path'
op|'.'
name|'index'
op|'('
name|'DATADIR_BASE'
op|')'
op|':'
op|']'
newline|'\n'
name|'obj_dirname'
op|'='
name|'obj_portion'
op|'['
op|':'
name|'obj_portion'
op|'.'
name|'index'
op|'('
string|"'/'"
op|')'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|','
name|'policy'
op|'='
name|'split_policy_string'
op|'('
name|'obj_dirname'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PolicyError'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'policy'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|quarantine_renamer
dedent|''
name|'def'
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'corrupted_file_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    In the case that a file is corrupted, move it to a quarantined\n    area to allow replication to fix it.\n\n    :params device_path: The path to the device the corrupted file is on.\n    :params corrupted_file_path: The path to the file you want quarantined.\n\n    :returns: path (str) of directory the file was moved to\n    :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY\n                     exceptions from rename\n    """'
newline|'\n'
name|'policy'
op|'='
name|'extract_policy'
op|'('
name|'corrupted_file_path'
op|')'
newline|'\n'
name|'if'
name|'policy'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# TODO: support a quarantine-unknown location'
nl|'\n'
indent|'        '
name|'policy'
op|'='
name|'POLICIES'
op|'.'
name|'legacy'
newline|'\n'
dedent|''
name|'from_dir'
op|'='
name|'dirname'
op|'('
name|'corrupted_file_path'
op|')'
newline|'\n'
name|'to_dir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
string|"'quarantined'"
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'basename'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'from_dir'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|','
name|'fsync'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e'
op|'.'
name|'errno'
name|'not'
name|'in'
op|'('
name|'errno'
op|'.'
name|'EEXIST'
op|','
name|'errno'
op|'.'
name|'ENOTEMPTY'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'to_dir'
op|'='
string|'"%s-%s"'
op|'%'
op|'('
name|'to_dir'
op|','
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|')'
newline|'\n'
name|'renamer'
op|'('
name|'from_dir'
op|','
name|'to_dir'
op|','
name|'fsync'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'to_dir'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_ondisk_files
dedent|''
name|'def'
name|'get_ondisk_files'
op|'('
name|'files'
op|','
name|'datadir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a simple list of files names, determine the files to use.\n\n    :params files: simple set of files as a python list\n    :params datadir: directory name files are from for convenience\n    :returns: a tuple of data, meta and ts (tombstone) files, in one of\n              two states:\n\n    * ts_file is not None, data_file is None, meta_file is None\n\n      object is considered deleted\n\n    * data_file is not None, ts_file is None\n\n      object exists, and optionally has fast-POST metadata\n    """'
newline|'\n'
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'data_file'
op|'='
name|'meta_file'
op|'='
name|'ts_file'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'afile'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'ts_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after tombstone, %s, encountered"'
op|'%'
name|'ts_file'
newline|'\n'
name|'assert'
name|'data_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after data file, %s, encountered"'
op|'%'
name|'data_file'
newline|'\n'
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'meta_file'
op|'='
name|'None'
newline|'\n'
name|'ts_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.meta'"
op|')'
name|'and'
name|'not'
name|'meta_file'
op|':'
newline|'\n'
indent|'            '
name|'meta_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
comment|'# NOTE: this does not exit this loop, since a fast-POST'
nl|'\n'
comment|'# operation just updates metadata, writing one or more'
nl|'\n'
comment|'# .meta files, the data file will have an older timestamp,'
nl|'\n'
comment|'# so we keep looking.'
nl|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'afile'
op|'.'
name|'endswith'
op|'('
string|"'.data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'data_file'
op|'='
name|'join'
op|'('
name|'datadir'
op|','
name|'afile'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'assert'
op|'('
op|'('
name|'data_file'
name|'is'
name|'None'
name|'and'
name|'meta_file'
name|'is'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'ts_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'data_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'meta_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'data_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
op|')'
op|','
string|'"On-disk file search algorithm contract is broken: data_file:"'
string|'" %s, meta_file: %s, ts_file: %s"'
op|'%'
op|'('
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|')'
newline|'\n'
name|'return'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hash_cleanup_listdir
dedent|''
name|'def'
name|'hash_cleanup_listdir'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    List contents of a hash directory and clean up any old files.\n\n    :param hsh_path: object hash path\n    :param reclaim_age: age in seconds at which to remove tombstones\n    :returns: list of files remaining in the directory, reverse sorted\n    """'
newline|'\n'
name|'files'
op|'='
name|'listdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'files'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'files'
op|'['
number|'0'
op|']'
op|'.'
name|'endswith'
op|'('
string|"'.ts'"
op|')'
op|':'
newline|'\n'
comment|'# remove tombstones older than reclaim_age'
nl|'\n'
indent|'            '
name|'ts'
op|'='
name|'files'
op|'['
number|'0'
op|']'
op|'.'
name|'rsplit'
op|'('
string|"'.'"
op|','
number|'1'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'float'
op|'('
name|'Timestamp'
op|'('
name|'ts'
op|')'
op|')'
op|')'
op|'>'
name|'reclaim_age'
op|':'
newline|'\n'
indent|'                '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'files'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'files'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'elif'
name|'files'
op|':'
newline|'\n'
indent|'        '
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|'='
name|'get_ondisk_files'
op|'('
name|'files'
op|','
string|"''"
op|')'
newline|'\n'
name|'newest_file'
op|'='
name|'data_file'
name|'or'
name|'ts_file'
newline|'\n'
name|'for'
name|'filename'
name|'in'
name|'list'
op|'('
name|'files'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'filename'
op|'<'
name|'newest_file'
op|')'
nl|'\n'
name|'or'
op|'('
name|'meta_file'
nl|'\n'
name|'and'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'.meta'"
op|')'
nl|'\n'
name|'and'
name|'filename'
op|'<'
name|'meta_file'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'filename'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'files'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hash_suffix
dedent|''
name|'def'
name|'hash_suffix'
op|'('
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Performs reclamation and returns an md5 of all (remaining) files.\n\n    :param reclaim_age: age in seconds at which to remove tombstones\n    :raises PathNotDir: if given path is not a valid directory\n    :raises OSError: for non-ENOTDIR errors\n    """'
newline|'\n'
name|'md5'
op|'='
name|'hashlib'
op|'.'
name|'md5'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'path_contents'
op|'='
name|'sorted'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOTDIR'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'path_contents'
op|':'
newline|'\n'
indent|'        '
name|'hsh_path'
op|'='
name|'join'
op|'('
name|'path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'hash_cleanup_listdir'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                '
name|'partition_path'
op|'='
name|'dirname'
op|'('
name|'path'
op|')'
newline|'\n'
name|'objects_path'
op|'='
name|'dirname'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'device_path'
op|'='
name|'dirname'
op|'('
name|'objects_path'
op|')'
newline|'\n'
name|'quar_path'
op|'='
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'hsh_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(hsh_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'hsh_path'"
op|':'
name|'hsh_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'filename'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'md5'
op|'.'
name|'update'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'md5'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|invalidate_hash
dedent|''
name|'def'
name|'invalidate_hash'
op|'('
name|'suffix_dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Invalidates the hash for a suffix_dir in the partition\'s hashes file.\n\n    :param suffix_dir: absolute path to suffix dir whose hash needs\n                       invalidating\n    """'
newline|'\n'
nl|'\n'
name|'suffix'
op|'='
name|'basename'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'partition_dir'
op|'='
name|'dirname'
op|'('
name|'suffix_dir'
op|')'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'hashes_file'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
dedent|''
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffix'
name|'in'
name|'hashes'
name|'and'
name|'not'
name|'hashes'
op|'['
name|'suffix'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'None'
newline|'\n'
name|'write_pickle'
op|'('
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_dir'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_hashes
dedent|''
dedent|''
name|'def'
name|'get_hashes'
op|'('
name|'partition_dir'
op|','
name|'recalculate'
op|'='
name|'None'
op|','
name|'do_listdir'
op|'='
name|'False'
op|','
nl|'\n'
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a list of hashes for the suffix dir.  do_listdir causes it to mistrust\n    the hash cache for suffix existence at the (unexpectedly high) cost of a\n    listdir.  reclaim_age is just passed on to hash_suffix.\n\n    :param partition_dir: absolute path of partition to get hashes for\n    :param recalculate: list of suffixes which should be recalculated when got\n    :param do_listdir: force existence check for all hashes in the partition\n    :param reclaim_age: age at which to remove tombstones\n\n    :returns: tuple of (number of suffix dirs hashed, dictionary of hashes)\n    """'
newline|'\n'
nl|'\n'
name|'hashed'
op|'='
number|'0'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'modified'
op|'='
name|'False'
newline|'\n'
name|'force_rewrite'
op|'='
name|'False'
newline|'\n'
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'mtime'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'recalculate'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'recalculate'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'mtime'
op|'='
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'do_listdir'
op|'='
name|'True'
newline|'\n'
name|'force_rewrite'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'if'
name|'do_listdir'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'suff'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'suff'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'.'
name|'setdefault'
op|'('
name|'suff'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'hashes'
op|'.'
name|'update'
op|'('
op|'('
name|'suffix'
op|','
name|'None'
op|')'
name|'for'
name|'suffix'
name|'in'
name|'recalculate'
op|')'
newline|'\n'
name|'for'
name|'suffix'
op|','
name|'hash_'
name|'in'
name|'hashes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'hash_'
op|':'
newline|'\n'
indent|'            '
name|'suffix_dir'
op|'='
name|'join'
op|'('
name|'partition_dir'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'hash_suffix'
op|'('
name|'suffix_dir'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'hashed'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'PathNotDir'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'hashes'
op|'['
name|'suffix'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Error hashing suffix'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'modified'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'lock_path'
op|'('
name|'partition_dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'force_rewrite'
name|'or'
name|'not'
name|'exists'
op|'('
name|'hashes_file'
op|')'
name|'or'
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
op|'=='
name|'mtime'
op|':'
newline|'\n'
indent|'                '
name|'write_pickle'
op|'('
nl|'\n'
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_dir'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'get_hashes'
op|'('
name|'partition_dir'
op|','
name|'recalculate'
op|','
name|'do_listdir'
op|','
nl|'\n'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AuditLocation
dedent|''
dedent|''
name|'class'
name|'AuditLocation'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Represents an object location to be audited.\n\n    Other than being a bucket of data, the only useful thing this does is\n    stringify to a filesystem path so the auditor\'s logs look okay.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'device'
op|','
name|'self'
op|'.'
name|'partition'
op|','
name|'self'
op|'.'
name|'policy'
op|'='
op|'('
nl|'\n'
name|'path'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|object_audit_location_generator
dedent|''
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'devices'
op|','
name|'mount_check'
op|'='
name|'True'
op|','
name|'logger'
op|'='
name|'None'
op|','
nl|'\n'
name|'device_dirs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a devices path (e.g. "/srv/node"), yield an AuditLocation for all\n    objects stored under that directory if device_dirs isn\'t set.  If\n    device_dirs is set, only yield AuditLocation for the objects under the\n    entries in device_dirs. The AuditLocation only knows the path to the hash\n    directory, not to the .data file therein (if any). This is to avoid a\n    double listdir(hash_dir); the DiskFile object will always do one, so\n    we don\'t.\n\n    :param devices: parent directory of the devices to be audited\n    :param mount_check: flag to check if a mount check should be performed\n                        on devices\n    :param logger: a logger object\n    :device_dirs: a list of directories under devices to traverse\n    """'
newline|'\n'
name|'if'
name|'not'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'listdir'
op|'('
name|'devices'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# remove bogus devices and duplicates from device_dirs'
nl|'\n'
indent|'        '
name|'device_dirs'
op|'='
name|'list'
op|'('
nl|'\n'
name|'set'
op|'('
name|'listdir'
op|'('
name|'devices'
op|')'
op|')'
op|'.'
name|'intersection'
op|'('
name|'set'
op|'('
name|'device_dirs'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# randomize devices in case of process restart before sweep completed'
nl|'\n'
dedent|''
name|'shuffle'
op|'('
name|'device_dirs'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'device'
name|'in'
name|'device_dirs'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'mount_check'
name|'and'
name|'not'
name|'ismount'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                '
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Skipping %s as it is not mounted'"
op|')'
op|','
name|'device'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
comment|'# loop through object dirs for all policies'
nl|'\n'
dedent|''
name|'for'
name|'dir_'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'dir_'
op|'.'
name|'startswith'
op|'('
name|'DATADIR_BASE'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'base'
op|','
name|'policy'
op|'='
name|'split_policy_string'
op|'('
name|'dir_'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PolicyError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'logger'
op|':'
newline|'\n'
indent|'                    '
name|'logger'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'Directory %r does not map '"
nl|'\n'
string|"'to a valid policy (%s)'"
op|')'
op|'%'
op|'('
name|'dir_'
op|','
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'datadir_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'devices'
op|','
name|'device'
op|','
name|'dir_'
op|')'
newline|'\n'
name|'partitions'
op|'='
name|'listdir'
op|'('
name|'datadir_path'
op|')'
newline|'\n'
name|'for'
name|'partition'
name|'in'
name|'partitions'
op|':'
newline|'\n'
indent|'                '
name|'part_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'datadir_path'
op|','
name|'partition'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'suffixes'
op|'='
name|'listdir'
op|'('
name|'part_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'asuffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'                    '
name|'suff_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'part_path'
op|','
name|'asuffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'hashes'
op|'='
name|'listdir'
op|'('
name|'suff_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'hashes'
op|':'
newline|'\n'
indent|'                        '
name|'hsh_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suff_path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'yield'
name|'AuditLocation'
op|'('
name|'hsh_path'
op|','
name|'device'
op|','
name|'partition'
op|','
nl|'\n'
name|'policy'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|strip_self
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'strip_self'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Wrapper to attach module level functions to base class.\n    """'
newline|'\n'
DECL|function|wrapper
name|'def'
name|'wrapper'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'f'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'wrapper'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileRouter
dedent|''
name|'class'
name|'DiskFileRouter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|policy_type_to_manager_cls
indent|'    '
name|'policy_type_to_manager_cls'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|register
name|'def'
name|'register'
op|'('
name|'cls'
op|','
name|'policy_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Decorator for Storage Policy implementations to register\n        their DiskFile implementation.\n        """'
newline|'\n'
DECL|function|register_wrapper
name|'def'
name|'register_wrapper'
op|'('
name|'diskfile_cls'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'policy_type'
name|'in'
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PolicyError'
op|'('
nl|'\n'
string|"'%r is already registered for the policy_type %r'"
op|'%'
op|'('
nl|'\n'
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy_type'
op|']'
op|','
nl|'\n'
name|'policy_type'
op|')'
op|')'
newline|'\n'
dedent|''
name|'cls'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy_type'
op|']'
op|'='
name|'diskfile_cls'
newline|'\n'
name|'return'
name|'diskfile_cls'
newline|'\n'
dedent|''
name|'return'
name|'register_wrapper'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'policy_to_manager'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'policy'
name|'in'
name|'POLICIES'
op|':'
newline|'\n'
indent|'            '
name|'manager_cls'
op|'='
name|'self'
op|'.'
name|'policy_type_to_manager_cls'
op|'['
name|'policy'
op|'.'
name|'policy_type'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'policy_to_manager'
op|'['
name|'policy'
op|']'
op|'='
name|'manager_cls'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'policy_to_manager'
op|'['
name|'policy'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'DiskFileRouter'
op|'.'
name|'register'
op|'('
name|'REPL_POLICY'
op|')'
newline|'\n'
DECL|class|DiskFileManager
name|'class'
name|'DiskFileManager'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Management class for devices, providing common place for shared parameters\n    and methods not provided by the DiskFile class (which primarily services\n    the object server REST API layer).\n\n    The `get_diskfile()` method is how this implementation creates a `DiskFile`\n    object.\n\n    .. note::\n\n        This class is reference implementation specific and not part of the\n        pluggable on-disk backend API.\n\n    .. note::\n\n        TODO(portante): Not sure what the right name to recommend here, as\n        "manager" seemed generic enough, though suggestions are welcome.\n\n    :param conf: caller provided configuration object\n    :param logger: caller provided logger\n    """'
newline|'\n'
nl|'\n'
DECL|variable|diskfile_cls
name|'diskfile_cls'
op|'='
name|'None'
comment|'# DiskFile will be set after that class is defined'
newline|'\n'
nl|'\n'
comment|'# module level functions dropped to implementation specific'
nl|'\n'
DECL|variable|hash_cleanup_listdir
name|'hash_cleanup_listdir'
op|'='
name|'strip_self'
op|'('
name|'hash_cleanup_listdir'
op|')'
newline|'\n'
DECL|variable|_get_hashes
name|'_get_hashes'
op|'='
name|'strip_self'
op|'('
name|'get_hashes'
op|')'
newline|'\n'
DECL|variable|invalidate_hash
name|'invalidate_hash'
op|'='
name|'strip_self'
op|'('
name|'invalidate_hash'
op|')'
newline|'\n'
DECL|variable|get_ondisk_files
name|'get_ondisk_files'
op|'='
name|'strip_self'
op|'('
name|'get_ondisk_files'
op|')'
newline|'\n'
DECL|variable|quarantine_renamer
name|'quarantine_renamer'
op|'='
name|'strip_self'
op|'('
name|'quarantine_renamer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'conf'
op|','
name|'logger'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'devices'
op|'='
name|'conf'
op|'.'
name|'get'
op|'('
string|"'devices'"
op|','
string|"'/srv/node'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'disk_chunk_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'disk_chunk_size'"
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'keep_cache_size'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'keep_cache_size'"
op|','
number|'5242880'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bytes_per_sync'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mb_per_sync'"
op|','
number|'512'
op|')'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'self'
op|'.'
name|'mount_check'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'mount_check'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reclaim_age'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'reclaim_age'"
op|','
name|'ONE_WEEK'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_one_per_device'
op|'='
name|'config_true_value'
op|'('
nl|'\n'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'replication_one_per_device'"
op|','
string|"'true'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replication_lock_timeout'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'replication_lock_timeout'"
op|','
number|'15'
op|')'
op|')'
newline|'\n'
name|'threads_per_disk'
op|'='
name|'int'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'threads_per_disk'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'='
name|'defaultdict'
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
name|'threads_per_disk'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'conf_wants_splice'
op|'='
name|'config_true_value'
op|'('
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|','
string|"'no'"
op|')'
op|')'
newline|'\n'
comment|"# If the operator wants zero-copy with splice() but we don't have the"
nl|'\n'
comment|'# requisite kernel support, complain so they can go fix it.'
nl|'\n'
name|'if'
name|'conf_wants_splice'
name|'and'
name|'not'
name|'splice'
op|'.'
name|'available'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warn'
op|'('
nl|'\n'
string|'"Use of splice() requested (config says \\"splice = %s\\"), "'
nl|'\n'
string|'"but the system does not support it. "'
nl|'\n'
string|'"splice() will not be used."'
op|'%'
name|'conf'
op|'.'
name|'get'
op|'('
string|"'splice'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'conf_wants_splice'
name|'and'
name|'splice'
op|'.'
name|'available'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'sockfd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|'# AF_ALG socket support was introduced in kernel 2.6.38; on'
nl|'\n'
comment|'# systems with older kernels (or custom-built kernels lacking'
nl|'\n'
comment|"# AF_ALG support), we can't use zero-copy."
nl|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'EAFNOSUPPORT'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'logger'
op|'.'
name|'warn'
op|'('
string|'"MD5 sockets not supported. "'
nl|'\n'
string|'"splice() will not be used."'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'use_splice'
op|'='
name|'True'
newline|'\n'
name|'with'
name|'open'
op|'('
string|"'/proc/sys/fs/pipe-max-size'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'                    '
name|'max_pipe_size'
op|'='
name|'int'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'pipe_size'
op|'='
name|'min'
op|'('
name|'max_pipe_size'
op|','
name|'self'
op|'.'
name|'disk_chunk_size'
op|')'
newline|'\n'
nl|'\n'
DECL|member|construct_dev_path
dedent|''
dedent|''
dedent|''
name|'def'
name|'construct_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Construct the path to a device without checking if it is mounted.\n\n        :param device: name of target device\n        :returns: full path to the device\n        """'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_dev_path
dedent|''
name|'def'
name|'get_dev_path'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'mount_check'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the path to a device, first checking to see if either it\n        is a proper mount point, or at least a directory depending on\n        the mount_check configuration option.\n\n        :param device: name of target device\n        :param mount_check: whether or not to check mountedness of device.\n                            Defaults to bool(self.mount_check).\n        :returns: full path to the device, None if the path to the device is\n                  not a proper mount point or directory.\n        """'
newline|'\n'
comment|"# we'll do some kind of check unless explicitly forbidden"
nl|'\n'
name|'if'
name|'mount_check'
name|'is'
name|'not'
name|'False'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mount_check'
name|'or'
name|'self'
op|'.'
name|'mount_check'
op|':'
newline|'\n'
indent|'                '
name|'check'
op|'='
name|'check_mount'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'check'
op|'='
name|'check_dir'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'check'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'device'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|replication_lock
name|'def'
name|'replication_lock'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A context manager that will lock on the device given, if\n        configured to do so.\n\n        :raises ReplicationLockTimeout: If the lock on the device\n            cannot be granted within the configured timeout.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'replication_one_per_device'
op|':'
newline|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'with'
name|'lock_path'
op|'('
nl|'\n'
name|'dev_path'
op|','
nl|'\n'
name|'timeout'
op|'='
name|'self'
op|'.'
name|'replication_lock_timeout'
op|','
nl|'\n'
name|'timeout_class'
op|'='
name|'ReplicationLockTimeout'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|pickle_async_update
dedent|''
dedent|''
name|'def'
name|'pickle_async_update'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
name|'data'
op|','
nl|'\n'
name|'timestamp'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'device_path'
op|'='
name|'self'
op|'.'
name|'construct_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'async_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_async_dir'
op|'('
name|'policy'
op|')'
op|')'
newline|'\n'
name|'ohash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'write_pickle'
op|','
nl|'\n'
name|'data'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'async_dir'
op|','
name|'ohash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
name|'ohash'
op|'+'
string|"'-'"
op|'+'
nl|'\n'
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
op|'.'
name|'internal'
op|')'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'logger'
op|'.'
name|'increment'
op|'('
string|"'async_pendings'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile
dedent|''
name|'def'
name|'get_diskfile'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|','
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'use_splice'
op|','
nl|'\n'
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'pipe_size'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|object_audit_location_generator
dedent|''
name|'def'
name|'object_audit_location_generator'
op|'('
name|'self'
op|','
name|'device_dirs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'object_audit_location_generator'
op|'('
name|'self'
op|'.'
name|'devices'
op|','
name|'self'
op|'.'
name|'mount_check'
op|','
nl|'\n'
name|'self'
op|'.'
name|'logger'
op|','
name|'device_dirs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_audit_location
dedent|''
name|'def'
name|'get_diskfile_from_audit_location'
op|'('
name|'self'
op|','
name|'audit_location'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'audit_location'
op|'.'
name|'device'
op|','
name|'mount_check'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'.'
name|'from_hash_dir'
op|'('
nl|'\n'
name|'self'
op|','
name|'audit_location'
op|'.'
name|'path'
op|','
name|'dev_path'
op|','
nl|'\n'
name|'audit_location'
op|'.'
name|'partition'
op|','
name|'policy'
op|'='
name|'audit_location'
op|'.'
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diskfile_from_hash
dedent|''
name|'def'
name|'get_diskfile_from_hash'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'object_hash'
op|','
nl|'\n'
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a DiskFile instance for an object at the given\n        object_hash. Just in case someone thinks of refactoring, be\n        sure DiskFileDeleted is *not* raised, but the DiskFile\n        instance representing the tombstoned object is returned\n        instead.\n\n        :raises DiskFileNotExist: if the object does not exist\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
name|'str'
op|'('
name|'partition'
op|')'
op|','
name|'object_hash'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|','
nl|'\n'
name|'object_hash'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'filenames'
op|'='
name|'self'
op|'.'
name|'hash_cleanup_listdir'
op|'('
name|'object_path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                '
name|'quar_path'
op|'='
name|'self'
op|'.'
name|'quarantine_renamer'
op|'('
name|'dev_path'
op|','
name|'object_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(object_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'object_path'"
op|':'
name|'object_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'filenames'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'='
name|'read_metadata'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'object_path'
op|','
name|'filenames'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'EOFError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|'='
name|'split_path'
op|'('
nl|'\n'
name|'metadata'
op|'.'
name|'get'
op|'('
string|"'name'"
op|','
string|"''"
op|')'
op|','
number|'3'
op|','
number|'3'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'diskfile_cls'
op|'('
name|'self'
op|','
name|'dev_path'
op|','
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|','
nl|'\n'
name|'partition'
op|','
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hashes
dedent|''
name|'def'
name|'get_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'suffixes'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'partition_path'
op|')'
newline|'\n'
dedent|''
name|'_junk'
op|','
name|'hashes'
op|'='
name|'self'
op|'.'
name|'threadpools'
op|'['
name|'device'
op|']'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_hashes'
op|','
name|'partition_path'
op|','
name|'recalculate'
op|'='
name|'suffixes'
op|')'
newline|'\n'
name|'return'
name|'hashes'
newline|'\n'
nl|'\n'
DECL|member|_listdir
dedent|''
name|'def'
name|'_listdir'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'error'
op|'('
nl|'\n'
string|"'ERROR: Skipping %r due to error with listdir attempt: %s'"
op|','
nl|'\n'
name|'path'
op|','
name|'err'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|yield_suffixes
dedent|''
name|'def'
name|'yield_suffixes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, suffix_only) for suffixes stored\n        on the given device and partition.\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|')'
newline|'\n'
name|'for'
name|'suffix'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'suffix'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'int'
op|'('
name|'suffix'
op|','
number|'16'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|member|yield_hashes
dedent|''
dedent|''
name|'def'
name|'yield_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|','
name|'suffixes'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yields tuples of (full_path, hash_only, timestamp) for object\n        information stored for the given device, partition, and\n        (optionally) suffixes. If suffixes is None, all stored\n        suffixes will be searched for object hashes. Note that if\n        suffixes is not None but empty, such as [], then nothing will\n        be yielded.\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffixes'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'suffixes'
op|'='
name|'self'
op|'.'
name|'yield_suffixes'
op|'('
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'str'
op|'('
name|'partition'
op|')'
op|')'
newline|'\n'
name|'suffixes'
op|'='
op|'('
nl|'\n'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
nl|'\n'
name|'for'
name|'suffix'
name|'in'
name|'suffixes'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'suffix_path'
op|','
name|'suffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'object_hash'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'suffix_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suffix_path'
op|','
name|'object_hash'
op|')'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'self'
op|'.'
name|'hash_cleanup_listdir'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'self'
op|'.'
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ts'
op|','
name|'ext'
op|'='
name|'name'
op|'.'
name|'rsplit'
op|'('
string|"'.'"
op|','
number|'1'
op|')'
newline|'\n'
name|'yield'
op|'('
name|'object_path'
op|','
name|'object_hash'
op|','
name|'ts'
op|')'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileWriter
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFileWriter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the write context for servicing PUT REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.create` method.\n\n    .. note::\n\n        It is the responsibility of the\n        :func:`swift.obj.diskfile.DiskFile.create` method context manager to\n        close the open file descriptor.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param name: name of object from REST API\n    :param datadir: on-disk directory object will end up in on\n                    :func:`swift.obj.diskfile.DiskFileWriter.put`\n    :param fd: open file descriptor of temporary file to receive data\n    :param tmppath: full path name of the opened file descriptor\n    :param bytes_per_sync: number bytes written between sync calls\n    :param threadpool: internal thread pool to use for disk operations\n    :param diskfile: the diskfile creating this DiskFileWriter instance\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
name|'bytes_per_sync'
op|','
name|'threadpool'
op|','
nl|'\n'
name|'diskfile'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'datadir'
newline|'\n'
name|'self'
op|'.'
name|'_fd'
op|'='
name|'fd'
newline|'\n'
name|'self'
op|'.'
name|'_tmppath'
op|'='
name|'tmppath'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'='
name|'diskfile'
newline|'\n'
nl|'\n'
comment|'# Internal attributes'
nl|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_extension'
op|'='
string|"'.data'"
newline|'\n'
name|'self'
op|'.'
name|'_put_succeeded'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'manager'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|put_succeeded
name|'def'
name|'put_succeeded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_put_succeeded'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a chunk of data to disk. All invocations of this method must\n        come before invoking the :func:\n\n        For this implementation, the data is written into a temporary file.\n\n        :param chunk: the chunk of data to write as a string object\n\n        :returns: the total number of bytes written to an object\n        """'
newline|'\n'
nl|'\n'
DECL|function|_write_entire_chunk
name|'def'
name|'_write_entire_chunk'
op|'('
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'chunk'
op|':'
newline|'\n'
indent|'                '
name|'written'
op|'='
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'chunk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_upload_size'
op|'+='
name|'written'
newline|'\n'
name|'chunk'
op|'='
name|'chunk'
op|'['
name|'written'
op|':'
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
name|'_write_entire_chunk'
op|','
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
comment|'# For large files sync every 512MB (by default) written'
nl|'\n'
name|'diff'
op|'='
name|'self'
op|'.'
name|'_upload_size'
op|'-'
name|'self'
op|'.'
name|'_last_sync'
newline|'\n'
name|'if'
name|'diff'
op|'>='
name|'self'
op|'.'
name|'_bytes_per_sync'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
name|'fdatasync'
op|','
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'self'
op|'.'
name|'_last_sync'
op|','
name|'diff'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_last_sync'
op|'='
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_upload_size'
newline|'\n'
nl|'\n'
DECL|member|_finalize_put
dedent|''
name|'def'
name|'_finalize_put'
op|'('
name|'self'
op|','
name|'metadata'
op|','
name|'target_path'
op|')'
op|':'
newline|'\n'
comment|'# Write the metadata before calling fsync() so that both data and'
nl|'\n'
comment|'# metadata are flushed to disk.'
nl|'\n'
indent|'        '
name|'write_metadata'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
name|'metadata'
op|')'
newline|'\n'
comment|'# We call fsync() before calling drop_cache() to lower the amount of'
nl|'\n'
comment|'# redundant work the drop cache code will perform on the pages (now'
nl|'\n'
comment|'# that after fsync the pages will be all clean).'
nl|'\n'
name|'fsync'
op|'('
name|'self'
op|'.'
name|'_fd'
op|')'
newline|'\n'
comment|'# From the Department of the Redundancy Department, make sure we call'
nl|'\n'
comment|'# drop_cache() after fsync() to avoid redundant work (pages all'
nl|'\n'
comment|'# clean).'
nl|'\n'
name|'drop_buffer_cache'
op|'('
name|'self'
op|'.'
name|'_fd'
op|','
number|'0'
op|','
name|'self'
op|'.'
name|'_upload_size'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|')'
newline|'\n'
comment|'# After the rename completes, this object will be available for other'
nl|'\n'
comment|'# requests to reference.'
nl|'\n'
name|'renamer'
op|'('
name|'self'
op|'.'
name|'_tmppath'
op|','
name|'target_path'
op|')'
newline|'\n'
comment|'# If rename is successful, flag put as succeeded. This is done to avoid'
nl|'\n'
comment|'# unnecessary os.unlink() of tempfile later. As renamer() has'
nl|'\n'
comment|'# succeeded, the tempfile would no longer exist at its original path.'
nl|'\n'
name|'self'
op|'.'
name|'_put_succeeded'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'hash_cleanup_listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Problem cleaning up %s'"
op|')'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
nl|'\n'
DECL|member|put
dedent|''
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize writing the file on disk.\n\n        For this implementation, this method is responsible for renaming the\n        temporary file to the final name and directory location.  This method\n        should be called after the final call to\n        :func:`swift.obj.diskfile.DiskFileWriter.write`.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        """'
newline|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'metadata'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
op|'.'
name|'internal'
newline|'\n'
name|'metadata'
op|'['
string|"'name'"
op|']'
op|'='
name|'self'
op|'.'
name|'_name'
newline|'\n'
name|'target_path'
op|'='
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'timestamp'
op|'+'
name|'self'
op|'.'
name|'_extension'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_put'
op|','
name|'metadata'
op|','
name|'target_path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|commit
dedent|''
name|'def'
name|'commit'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform any operations necessary to mark the object as durable. For\n        replication policy type this is a no-op.\n\n        :param timestamp: object put timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFileReader
dedent|''
dedent|''
name|'class'
name|'DiskFileReader'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encapsulation of the WSGI read context for servicing GET REST API\n    requests. Serves as the context manager object for the\n    :class:`swift.obj.diskfile.DiskFile` class\'s\n    :func:`swift.obj.diskfile.DiskFile.reader` method.\n\n    .. note::\n\n        The quarantining behavior of this method is considered implementation\n        specific, and is not required of the API.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param fp: open file object pointer reference\n    :param data_file: on-disk data file name for the object\n    :param obj_size: verified on-disk size of the object\n    :param etag: expected metadata etag value for entire file\n    :param threadpool: thread pool to use for read operations\n    :param disk_chunk_size: size of reads from disk in bytes\n    :param keep_cache_size: maximum object size that will be kept in cache\n    :param device_path: on-disk device path, used when quarantining an obj\n    :param logger: logger caller wants this object to use\n    :param quarantine_hook: 1-arg callable called w/reason when quarantined\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    :param diskfile: the diskfile creating this DiskFileReader instance\n    :param keep_cache: should resulting reads be kept in the buffer cache\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'fp'
op|','
name|'data_file'
op|','
name|'obj_size'
op|','
name|'etag'
op|','
name|'threadpool'
op|','
nl|'\n'
name|'disk_chunk_size'
op|','
name|'keep_cache_size'
op|','
name|'device_path'
op|','
name|'logger'
op|','
nl|'\n'
name|'quarantine_hook'
op|','
name|'use_splice'
op|','
name|'pipe_size'
op|','
name|'diskfile'
op|','
nl|'\n'
name|'keep_cache'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# Parameter tracking'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'_fp'
op|'='
name|'fp'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'data_file'
newline|'\n'
name|'self'
op|'.'
name|'_obj_size'
op|'='
name|'obj_size'
newline|'\n'
name|'self'
op|'.'
name|'_etag'
op|'='
name|'etag'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
newline|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'='
name|'diskfile'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'='
name|'quarantine_hook'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'if'
name|'keep_cache'
op|':'
newline|'\n'
comment|'# Caller suggests we keep this in cache, only do it if the'
nl|'\n'
comment|"# object's size is less than the maximum."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'obj_size'
op|'<'
name|'keep_cache_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_keep_cache'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Internal Attributes'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'manager'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'tell'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_iter_etag'
op|'='
name|'hashlib'
op|'.'
name|'md5'
op|'('
op|')'
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'read'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|')'
newline|'\n'
name|'if'
name|'chunk'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'update'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|can_zero_copy_send
dedent|''
dedent|''
dedent|''
name|'def'
name|'can_zero_copy_send'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_use_splice'
newline|'\n'
nl|'\n'
DECL|member|zero_copy_send
dedent|''
name|'def'
name|'zero_copy_send'
op|'('
name|'self'
op|','
name|'wsockfd'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Does some magic with splice() and tee() to move stuff from disk to\n        network without ever touching userspace.\n\n        :param wsockfd: file descriptor (integer) of the socket out which to\n                        send data\n        """'
newline|'\n'
comment|'# Note: if we ever add support for zero-copy ranged GET responses,'
nl|'\n'
comment|"# we'll have to make this conditional."
nl|'\n'
name|'self'
op|'.'
name|'_started_at_0'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'rfd'
op|'='
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'client_rpipe'
op|','
name|'client_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'hash_rpipe'
op|','
name|'hash_wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'md5_sockfd'
op|'='
name|'get_md5_socket'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The actual amount allocated to the pipe may be rounded up to the'
nl|'\n'
comment|'# nearest multiple of the page size. If we have the memory allocated,'
nl|'\n'
comment|'# we may as well use it.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note: this will raise IOError on failure, so we don't bother"
nl|'\n'
comment|'# checking the return value.'
nl|'\n'
name|'pipe_size'
op|'='
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'client_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'self'
op|'.'
name|'_pipe_size'
op|')'
newline|'\n'
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'hash_rpipe'
op|','
name|'F_SETPIPE_SZ'
op|','
name|'pipe_size'
op|')'
newline|'\n'
nl|'\n'
name|'dropped_cache'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'='
number|'0'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'True'
op|':'
newline|'\n'
comment|'# Read data from disk to pipe'
nl|'\n'
indent|'                '
op|'('
name|'bytes_in_pipe'
op|','
name|'_1'
op|','
name|'_2'
op|')'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'splice'
op|','
name|'rfd'
op|','
name|'None'
op|','
name|'client_wpipe'
op|','
name|'None'
op|','
name|'pipe_size'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_in_pipe'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_read_to_eof'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bytes_read'
op|'+='
name|'bytes_in_pipe'
newline|'\n'
nl|'\n'
comment|'# "Copy" data from pipe A to pipe B (really just some pointer'
nl|'\n'
comment|'# manipulation in the kernel, not actual copying).'
nl|'\n'
name|'bytes_copied'
op|'='
name|'tee'
op|'('
name|'client_rpipe'
op|','
name|'hash_wpipe'
op|','
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'bytes_copied'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
comment|'# We teed data between two pipes of equal size, and the'
nl|'\n'
comment|'# destination pipe was empty. If, somehow, the destination'
nl|'\n'
comment|'# pipe was full before all the data was teed, we should'
nl|'\n'
comment|"# fail here. If we don't raise an exception, then we will"
nl|'\n'
comment|'# have the incorrect MD5 hash once the object has been'
nl|'\n'
comment|'# sent out, causing a false-positive quarantine.'
nl|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"tee() failed: tried to move %d bytes, "'
nl|'\n'
string|'"but only moved %d"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'bytes_copied'
op|')'
op|')'
newline|'\n'
comment|'# Take the data and feed it into an in-kernel MD5 socket. The'
nl|'\n'
comment|'# MD5 socket hashes data that is written to it. Reading from'
nl|'\n'
comment|'# it yields the MD5 checksum of the written data.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Note that we don't have to worry about splice() returning"
nl|'\n'
comment|"# None here (which happens on EWOULDBLOCK); we're splicing"
nl|'\n'
comment|'# $bytes_in_pipe bytes from a pipe with exactly that many'
nl|'\n'
comment|"# bytes in it, so read won't block, and we're splicing it into"
nl|'\n'
comment|'# an MD5 socket, which synchronously hashes any data sent to'
nl|'\n'
comment|"# it, so writing won't block either."
nl|'\n'
dedent|''
op|'('
name|'hashed'
op|','
name|'_1'
op|','
name|'_2'
op|')'
op|'='
name|'splice'
op|'('
name|'hash_rpipe'
op|','
name|'None'
op|','
name|'md5_sockfd'
op|','
name|'None'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
name|'splice'
op|'.'
name|'SPLICE_F_MORE'
op|')'
newline|'\n'
name|'if'
name|'hashed'
op|'!='
name|'bytes_in_pipe'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
string|'"md5 socket didn\'t take all the data? "'
nl|'\n'
string|'"(tried to write %d, but wrote %d)"'
op|'%'
nl|'\n'
op|'('
name|'bytes_in_pipe'
op|','
name|'hashed'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'bytes_in_pipe'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'res'
op|'='
name|'splice'
op|'('
name|'client_rpipe'
op|','
name|'None'
op|','
name|'wsockfd'
op|','
name|'None'
op|','
nl|'\n'
name|'bytes_in_pipe'
op|','
number|'0'
op|')'
newline|'\n'
name|'bytes_in_pipe'
op|'-='
name|'res'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'exc'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EWOULDBLOCK'
op|':'
newline|'\n'
indent|'                            '
name|'trampoline'
op|'('
name|'wsockfd'
op|','
name|'write'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|'>'
name|'DROP_CACHE_WINDOW'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_drop_cache'
op|'('
name|'rfd'
op|','
name|'dropped_cache'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|'-'
name|'dropped_cache'
op|')'
newline|'\n'
name|'dropped_cache'
op|'='
name|'self'
op|'.'
name|'_bytes_read'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|"# Linux MD5 sockets return '00000000000000000000000000000000' for"
nl|'\n'
comment|"# the checksum if you didn't write any bytes to them, instead of"
nl|'\n'
comment|'# returning the correct value.'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'bin_checksum'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'md5_sockfd'
op|','
number|'16'
op|')'
newline|'\n'
name|'hex_checksum'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
string|'"%02x"'
op|'%'
name|'ord'
op|'('
name|'c'
op|')'
name|'for'
name|'c'
name|'in'
name|'bin_checksum'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'hex_checksum'
op|'='
name|'MD5_OF_EMPTY_STRING'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'hex_checksum'
newline|'\n'
nl|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'client_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_rpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'hash_wpipe'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'md5_sockfd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_range
dedent|''
dedent|''
name|'def'
name|'app_iter_range'
op|'('
name|'self'
op|','
name|'start'
op|','
name|'stop'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file for range (start, stop)"""'
newline|'\n'
name|'if'
name|'start'
name|'or'
name|'start'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fp'
op|'.'
name|'seek'
op|'('
name|'start'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stop'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'stop'
op|'-'
name|'start'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'chunk'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'length'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'length'
op|'-='
name|'len'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'length'
op|'<'
number|'0'
op|':'
newline|'\n'
comment|'# Chop off the extra:'
nl|'\n'
indent|'                        '
name|'yield'
name|'chunk'
op|'['
op|':'
name|'length'
op|']'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_suppress_file_closing'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|app_iter_ranges
dedent|''
dedent|''
dedent|''
name|'def'
name|'app_iter_ranges'
op|'('
name|'self'
op|','
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over the data file for a set of ranges"""'
newline|'\n'
name|'if'
name|'not'
name|'ranges'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"''"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'True'
newline|'\n'
name|'for'
name|'chunk'
name|'in'
name|'multi_range_iterator'
op|'('
nl|'\n'
name|'ranges'
op|','
name|'content_type'
op|','
name|'boundary'
op|','
name|'size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'app_iter_range'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'chunk'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_suppress_file_closing'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_drop_cache
dedent|''
dedent|''
dedent|''
name|'def'
name|'_drop_cache'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Method for no-oping buffer cache drop method."""'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_keep_cache'
op|':'
newline|'\n'
indent|'            '
name|'drop_buffer_cache'
op|'('
name|'fd'
op|','
name|'offset'
op|','
name|'length'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warn'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_quarantine_hook'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handle_close_quarantine
dedent|''
name|'def'
name|'_handle_close_quarantine'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if file needs to be quarantined"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_iter_etag'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|'='
name|'self'
op|'.'
name|'_iter_etag'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_bytes_read'
op|'!='
name|'self'
op|'.'
name|'_obj_size'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"Bytes read: %s, does not match metadata: %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_bytes_read'
op|','
name|'self'
op|'.'
name|'_obj_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
name|'and'
name|'self'
op|'.'
name|'_etag'
op|'!='
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
string|'"ETag %s and file\'s md5 %s do not match"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_etag'
op|','
name|'self'
op|'.'
name|'_md5_of_sent_bytes'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the open file handle if present.\n\n        For this specific implementation, this method will handle quarantining\n        the file if necessary.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_started_at_0'
name|'and'
name|'self'
op|'.'
name|'_read_to_eof'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_handle_close_quarantine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'Exception'
op|','
name|'Timeout'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
nl|'\n'
string|"'ERROR DiskFile %(data_file)s'"
nl|'\n'
string|"' close failure: %(exc)s : %(stack)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'exc'"
op|':'
name|'e'
op|','
string|"'stack'"
op|':'
string|"''"
op|'.'
name|'join'
op|'('
name|'traceback'
op|'.'
name|'format_stack'
op|'('
op|')'
op|')'
op|','
nl|'\n'
string|"'data_file'"
op|':'
name|'self'
op|'.'
name|'_data_file'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DiskFile
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'DiskFile'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Manage object files.\n\n    This specific implementation manages object files on a disk formatted with\n    a POSIX-compliant file system that supports extended attributes as\n    metadata on a file or directory.\n\n    .. note::\n\n        The arguments to the constructor are considered implementation\n        specific. The API does not define the constructor arguments.\n\n    :param mgr: associated DiskFileManager instance\n    :param device_path: path to the target device or drive\n    :param threadpool: thread pool to use for blocking operations\n    :param partition: partition on the device in which the object lives\n    :param account: account name for the object\n    :param container: container name for the object\n    :param obj: object name for the object\n    :param _datadir: override the full datadir otherwise constructed here\n    :param policy: the StoragePolicy instance\n    :param use_splice: if true, use zero-copy splice() to send data\n    :param pipe_size: size of pipe buffer used in zero-copy operations\n    """'
newline|'\n'
nl|'\n'
DECL|variable|reader_cls
name|'reader_cls'
op|'='
name|'DiskFileReader'
newline|'\n'
DECL|variable|writer_cls
name|'writer_cls'
op|'='
name|'DiskFileWriter'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'mgr'
op|','
name|'device_path'
op|','
name|'threadpool'
op|','
name|'partition'
op|','
nl|'\n'
name|'account'
op|'='
name|'None'
op|','
name|'container'
op|'='
name|'None'
op|','
name|'obj'
op|'='
name|'None'
op|','
name|'_datadir'
op|'='
name|'None'
op|','
nl|'\n'
name|'policy'
op|'='
name|'None'
op|','
name|'use_splice'
op|'='
name|'False'
op|','
name|'pipe_size'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_manager'
op|'='
name|'mgr'
newline|'\n'
name|'self'
op|'.'
name|'_device_path'
op|'='
name|'device_path'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'='
name|'threadpool'
name|'or'
name|'ThreadPool'
op|'('
name|'nthreads'
op|'='
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'='
name|'mgr'
op|'.'
name|'logger'
newline|'\n'
name|'self'
op|'.'
name|'_disk_chunk_size'
op|'='
name|'mgr'
op|'.'
name|'disk_chunk_size'
newline|'\n'
name|'self'
op|'.'
name|'_bytes_per_sync'
op|'='
name|'mgr'
op|'.'
name|'bytes_per_sync'
newline|'\n'
name|'self'
op|'.'
name|'_use_splice'
op|'='
name|'use_splice'
newline|'\n'
name|'self'
op|'.'
name|'_pipe_size'
op|'='
name|'pipe_size'
newline|'\n'
name|'self'
op|'.'
name|'policy'
op|'='
name|'policy'
newline|'\n'
name|'if'
name|'account'
name|'and'
name|'container'
name|'and'
name|'obj'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'account'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'container'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'obj'
newline|'\n'
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# gets populated when we read the metadata'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_account'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_container'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_obj'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tmpdir'
op|'='
name|'join'
op|'('
name|'device_path'
op|','
name|'get_tmp_dir'
op|'('
name|'policy'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'_datadir'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'_datadir'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'name_hash'
op|'='
name|'hash_path'
op|'('
name|'account'
op|','
name|'container'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datadir'
op|'='
name|'join'
op|'('
nl|'\n'
name|'device_path'
op|','
name|'storage_directory'
op|'('
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'partition'
op|','
name|'name_hash'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|manager
name|'def'
name|'manager'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_manager'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|account
name|'def'
name|'account'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_account'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|container
name|'def'
name|'container'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_container'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|obj
name|'def'
name|'obj'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_obj'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|content_length
name|'def'
name|'content_length'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_content_length'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|timestamp
name|'def'
name|'timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Timestamp'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'get'
op|'('
string|"'X-Timestamp'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_hash_dir
name|'def'
name|'from_hash_dir'
op|'('
name|'cls'
op|','
name|'mgr'
op|','
name|'hash_dir_path'
op|','
name|'device_path'
op|','
name|'partition'
op|','
name|'policy'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cls'
op|'('
name|'mgr'
op|','
name|'device_path'
op|','
name|'None'
op|','
name|'partition'
op|','
name|'_datadir'
op|'='
name|'hash_dir_path'
op|','
nl|'\n'
name|'policy'
op|'='
name|'policy'
op|')'
newline|'\n'
nl|'\n'
DECL|member|open
dedent|''
name|'def'
name|'open'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the object.\n\n        This implementation opens the data file representing the object, reads\n        the associated metadata in the extended attributes, additionally\n        combining metadata from fast-POST `.meta` files.\n\n        .. note::\n\n            An implementation is allowed to raise any of the following\n            exceptions, but is only required to raise `DiskFileNotExist` when\n            the object representation does not exist.\n\n        :raises DiskFileCollision: on name mis-match with metadata\n        :raises DiskFileNotExist: if the object does not exist\n        :raises DiskFileDeleted: if the object was previously deleted\n        :raises DiskFileQuarantined: if while reading metadata of the file\n                                     some data did pass cross checks\n        :returns: itself for use as a context manager\n        """'
newline|'\n'
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|'='
name|'self'
op|'.'
name|'_get_ondisk_file'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'data_file'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_construct_exception_from_ts_file'
op|'('
name|'ts_file'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_construct_from_data_file'
op|'('
nl|'\n'
name|'data_file'
op|','
name|'meta_file'
op|')'
newline|'\n'
comment|'# This method must populate the internal _metadata attribute.'
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_data_file'
op|'='
name|'data_file'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context enter.\n\n        .. note::\n\n            An implementation shall raise `DiskFileNotOpen` when has not\n            previously invoked the :func:`swift.obj.diskfile.DiskFile.open`\n            method.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'t'
op|','
name|'v'
op|','
name|'tb'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context exit.\n\n        .. note::\n\n            This method will be invoked by the object server while servicing\n            the REST API *before* the object has actually been read. It is the\n            responsibility of the implementation to properly handle that.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_fp'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|','
name|'self'
op|'.'
name|'_fp'
op|'='
name|'self'
op|'.'
name|'_fp'
op|','
name|'None'
newline|'\n'
name|'fp'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quarantine
dedent|''
dedent|''
name|'def'
name|'_quarantine'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Quarantine a file; responsible for incrementing the associated logger\'s\n        count of quarantines.\n\n        :param data_file: full path of data file to quarantine\n        :param msg: reason for quarantining to be included in the exception\n        :returns: DiskFileQuarantined exception object\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_quarantined_dir'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'manager'
op|'.'
name|'quarantine_renamer'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'warn'
op|'('
string|'"Quarantined object %s: %s"'
op|'%'
op|'('
nl|'\n'
name|'data_file'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'increment'
op|'('
string|"'quarantines'"
op|')'
newline|'\n'
name|'return'
name|'DiskFileQuarantined'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_file
dedent|''
name|'def'
name|'_get_ondisk_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do the work to figure out if the data directory exists, and if so,\n        determine the on-disk files to use.\n\n        :returns: a tuple of data, meta and ts (tombstone) files, in one of\n                  three states:\n\n        * all three are None\n\n          data directory does not exist, or there are no files in\n          that directory\n\n        * ts_file is not None, data_file is None, meta_file is None\n\n          object is considered deleted\n\n        * data_file is not None, ts_file is None\n\n          object exists, and optionally has fast-POST metadata\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
comment|"# If there's a file here instead of a directory, quarantine"
nl|'\n'
comment|"# it; something's gone wrong somewhere."
nl|'\n'
indent|'                '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
comment|'# hack: quarantine_renamer actually renames the directory'
nl|'\n'
comment|'# enclosing the filename you give it, but here we just'
nl|'\n'
comment|'# want this one file and not its parent.'
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
string|'"made-up-filename"'
op|')'
op|','
nl|'\n'
string|'"Expected directory, found file at %s"'
op|'%'
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|'"Error listing directory %s: %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
comment|'# The data directory does not exist, so the object cannot exist.'
nl|'\n'
dedent|''
name|'fileset'
op|'='
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'fileset'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'get_ondisk_files'
op|'('
name|'files'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'fileset'
newline|'\n'
nl|'\n'
DECL|member|_construct_exception_from_ts_file
dedent|''
name|'def'
name|'_construct_exception_from_ts_file'
op|'('
name|'self'
op|','
name|'ts_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a tombstone is present it means the object is considered\n        deleted. We just need to pull the metadata from the tombstone file\n        which has the timestamp to construct the deleted exception. If there\n        was no tombstone, just report it does not exist.\n\n        :param ts_file: the tombstone file name found on disk\n        :returns: DiskFileDeleted if the ts_file was provided, else\n                  DiskFileNotExist\n        """'
newline|'\n'
name|'if'
name|'not'
name|'ts_file'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'ts_file'
op|','
name|'ts_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileQuarantined'
op|':'
newline|'\n'
comment|"# If the tombstone's corrupted, quarantine it and pretend it"
nl|'\n'
comment|"# wasn't there"
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileNotExist'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# All well and good that we have found a tombstone file, but'
nl|'\n'
comment|"# we don't have a data file so we are just going to raise an"
nl|'\n'
comment|'# exception that we could not find the object, providing the'
nl|'\n'
comment|"# tombstone's timestamp."
nl|'\n'
indent|'                '
name|'exc'
op|'='
name|'DiskFileDeleted'
op|'('
name|'metadata'
op|'='
name|'metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'exc'
newline|'\n'
nl|'\n'
DECL|member|_verify_name_matches_hash
dedent|''
name|'def'
name|'_verify_name_matches_hash'
op|'('
name|'self'
op|','
name|'data_file'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'hash_from_fs'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
name|'hash_from_name'
op|'='
name|'hash_path'
op|'('
name|'self'
op|'.'
name|'_name'
op|'.'
name|'lstrip'
op|'('
string|"'/'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'hash_from_fs'
op|'!='
name|'hash_from_name'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
nl|'\n'
string|'"Hash of name in metadata does not match directory name"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_verify_data_file
dedent|''
dedent|''
name|'def'
name|'_verify_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'fp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify the metadata\'s name value matches what we think the object is\n        named.\n\n        :param data_file: data file name being consider, used when quarantines\n                          occur\n        :param fp: open file pointer so that we can `fstat()` the file to\n                   verify the on-disk size with Content-Length metadata value\n        :raises DiskFileCollision: if the metadata stored name does not match\n                                   the referenced name of the file\n        :raises DiskFileExpired: if the object has expired\n        :raises DiskFileQuarantined: if data inconsistencies were detected\n                                     between the metadata and the file-system\n                                     metadata\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mname'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"missing name metadata"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mname'
op|'!='
name|'self'
op|'.'
name|'_name'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Client path %(client)s does not match '"
nl|'\n'
string|"'path stored in object metadata %(meta)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'client'"
op|':'
name|'self'
op|'.'
name|'_name'
op|','
string|"'meta'"
op|':'
name|'mname'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'DiskFileCollision'
op|'('
string|"'Client path does not match path '"
nl|'\n'
string|"'stored in object metadata'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'x_delete_at'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the x-delete-at key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata x-delete-at value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'X-Delete-At'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'x_delete_at'
op|'<='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileExpired'
op|'('
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'metadata_size'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"missing content-length in metadata"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|'# Quarantine, the content-length key is present but not an'
nl|'\n'
comment|'# integer.'
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"bad metadata content-length value %s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'fd'
op|'='
name|'fp'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'statbuf'
op|'='
name|'os'
op|'.'
name|'fstat'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
comment|"# Quarantine, we can't successfully stat the file."
nl|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
name|'data_file'
op|','
string|'"not stat-able: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'obj_size'
op|'='
name|'statbuf'
op|'.'
name|'st_size'
newline|'\n'
dedent|''
name|'if'
name|'obj_size'
op|'!='
name|'metadata_size'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'data_file'
op|','
string|'"metadata content-length %s does"'
nl|'\n'
string|'" not match actual object size %s"'
op|'%'
op|'('
nl|'\n'
name|'metadata_size'
op|','
name|'statbuf'
op|'.'
name|'st_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_content_length'
op|'='
name|'obj_size'
newline|'\n'
name|'return'
name|'obj_size'
newline|'\n'
nl|'\n'
DECL|member|_failsafe_read_metadata
dedent|''
name|'def'
name|'_failsafe_read_metadata'
op|'('
name|'self'
op|','
name|'source'
op|','
name|'quarantine_filename'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# Takes source and filename separately so we can read from an open'
nl|'\n'
comment|'# file if we have one'
nl|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'read_metadata'
op|'('
name|'source'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
name|'quarantine_filename'
op|','
nl|'\n'
string|'"Exception reading metadata: %s"'
op|'%'
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_construct_from_data_file
dedent|''
dedent|''
name|'def'
name|'_construct_from_data_file'
op|'('
name|'self'
op|','
name|'data_file'
op|','
name|'meta_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Open the `.data` file to fetch its metadata, and fetch the metadata\n        from the fast-POST `.meta` file as well if it exists, merging them\n        properly.\n\n        :param data_file: on-disk `.data` file being considered\n        :param meta_file: on-disk fast-POST `.meta` file being considered\n        :returns: an opened data file pointer\n        :raises DiskFileError: various exceptions from\n                    :func:`swift.obj.diskfile.DiskFile._verify_data_file`\n        """'
newline|'\n'
name|'fp'
op|'='
name|'open'
op|'('
name|'data_file'
op|','
string|"'rb'"
op|')'
newline|'\n'
name|'datafile_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'fp'
op|','
name|'data_file'
op|')'
newline|'\n'
name|'if'
name|'meta_file'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'self'
op|'.'
name|'_failsafe_read_metadata'
op|'('
name|'meta_file'
op|','
name|'meta_file'
op|')'
newline|'\n'
name|'sys_metadata'
op|'='
name|'dict'
op|'('
nl|'\n'
op|'['
op|'('
name|'key'
op|','
name|'val'
op|')'
name|'for'
name|'key'
op|','
name|'val'
name|'in'
name|'datafile_metadata'
op|'.'
name|'iteritems'
op|'('
op|')'
nl|'\n'
name|'if'
name|'key'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
name|'DATAFILE_SYSTEM_META'
nl|'\n'
name|'or'
name|'is_sys_meta'
op|'('
string|"'object'"
op|','
name|'key'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'.'
name|'update'
op|'('
name|'sys_metadata'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_metadata'
op|'='
name|'datafile_metadata'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_name'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# If we don't know our name, we were just given a hash dir at"
nl|'\n'
comment|"# instantiation, so we'd better validate that the name hashes back"
nl|'\n'
comment|'# to us'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_name'
op|'='
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_verify_name_matches_hash'
op|'('
name|'data_file'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_verify_data_file'
op|'('
name|'data_file'
op|','
name|'fp'
op|')'
newline|'\n'
name|'return'
name|'fp'
newline|'\n'
nl|'\n'
DECL|member|get_metadata
dedent|''
name|'def'
name|'get_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Provide the metadata for a previously opened object as a dictionary.\n\n        :returns: object\'s metadata dictionary\n        :raises DiskFileNotOpen: if the\n            :func:`swift.obj.diskfile.DiskFile.open` method was not previously\n            invoked\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_metadata'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileNotOpen'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_metadata'
newline|'\n'
nl|'\n'
DECL|member|read_metadata
dedent|''
name|'def'
name|'read_metadata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the metadata for an object without requiring the caller to open\n        the object first.\n\n        :returns: metadata dictionary for an object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `open()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'open'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'get_metadata'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|reader
dedent|''
dedent|''
name|'def'
name|'reader'
op|'('
name|'self'
op|','
name|'keep_cache'
op|'='
name|'False'
op|','
nl|'\n'
name|'_quarantine_hook'
op|'='
name|'lambda'
name|'m'
op|':'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a :class:`swift.common.swob.Response` class compatible\n        "`app_iter`" object as defined by\n        :class:`swift.obj.diskfile.DiskFileReader`.\n\n        For this implementation, the responsibility of closing the open file\n        is passed to the :class:`swift.obj.diskfile.DiskFileReader` object.\n\n        :param keep_cache: caller\'s preference for keeping data read in the\n                           OS buffer cache\n        :param _quarantine_hook: 1-arg callable called when obj quarantined;\n                                 the arg is the reason for quarantine.\n                                 Default is to ignore it.\n                                 Not needed by the REST layer.\n        :returns: a :class:`swift.obj.diskfile.DiskFileReader` object\n        """'
newline|'\n'
name|'dr'
op|'='
name|'self'
op|'.'
name|'reader_cls'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|','
name|'self'
op|'.'
name|'_data_file'
op|','
name|'int'
op|'('
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'Content-Length'"
op|']'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_metadata'
op|'['
string|"'ETag'"
op|']'
op|','
name|'self'
op|'.'
name|'_threadpool'
op|','
name|'self'
op|'.'
name|'_disk_chunk_size'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_manager'
op|'.'
name|'keep_cache_size'
op|','
name|'self'
op|'.'
name|'_device_path'
op|','
name|'self'
op|'.'
name|'_logger'
op|','
nl|'\n'
name|'use_splice'
op|'='
name|'self'
op|'.'
name|'_use_splice'
op|','
name|'quarantine_hook'
op|'='
name|'_quarantine_hook'
op|','
nl|'\n'
name|'pipe_size'
op|'='
name|'self'
op|'.'
name|'_pipe_size'
op|','
name|'diskfile'
op|'='
name|'self'
op|','
name|'keep_cache'
op|'='
name|'keep_cache'
op|')'
newline|'\n'
comment|'# At this point the reader object is now responsible for closing'
nl|'\n'
comment|'# the file pointer.'
nl|'\n'
name|'self'
op|'.'
name|'_fp'
op|'='
name|'None'
newline|'\n'
name|'return'
name|'dr'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextmanager'
newline|'\n'
DECL|member|create
name|'def'
name|'create'
op|'('
name|'self'
op|','
name|'size'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Context manager to create a file. We create a temporary file first, and\n        then return a DiskFileWriter object to encapsulate the state.\n\n        .. note::\n\n            An implementation is not required to perform on-disk\n            preallocations even if the parameter is specified. But if it does\n            and it fails, it must raise a `DiskFileNoSpace` exception.\n\n        :param size: optional initial size of file to explicitly allocate on\n                     disk\n        :raises DiskFileNoSpace: if a size is specified and allocation fails\n        """'
newline|'\n'
name|'if'
name|'not'
name|'exists'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mkdirs'
op|'('
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fd'
op|','
name|'tmppath'
op|'='
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'self'
op|'.'
name|'_tmpdir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
comment|'# No more inodes in filesystem'
nl|'\n'
indent|'                '
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'dfw'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'size'
name|'is'
name|'not'
name|'None'
name|'and'
name|'size'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'fallocate'
op|'('
name|'fd'
op|','
name|'size'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'dfw'
op|'='
name|'self'
op|'.'
name|'writer_cls'
op|'('
name|'self'
op|'.'
name|'_name'
op|','
name|'self'
op|'.'
name|'_datadir'
op|','
name|'fd'
op|','
name|'tmppath'
op|','
nl|'\n'
name|'bytes_per_sync'
op|'='
name|'self'
op|'.'
name|'_bytes_per_sync'
op|','
nl|'\n'
name|'threadpool'
op|'='
name|'self'
op|'.'
name|'_threadpool'
op|','
nl|'\n'
name|'diskfile'
op|'='
name|'self'
op|')'
newline|'\n'
name|'yield'
name|'dfw'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'dfw'
name|'is'
name|'None'
op|')'
name|'or'
op|'('
name|'not'
name|'dfw'
op|'.'
name|'put_succeeded'
op|')'
op|':'
newline|'\n'
comment|'# Try removing the temp file only if put did NOT succeed.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# dfw.put_succeeded is set to True after renamer() succeeds in'
nl|'\n'
comment|'# DiskFileWriter._finalize_put()'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmppath'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_logger'
op|'.'
name|'exception'
op|'('
string|"'Error removing tempfile: %s'"
op|'%'
nl|'\n'
name|'tmppath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|write_metadata
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'write_metadata'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a block of metadata to an object without requiring the caller to\n        create the object first. Supports fast-POST behavior semantics.\n\n        :param metadata: dictionary of metadata to be associated with the\n                         object\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'writer'
op|':'
newline|'\n'
indent|'            '
name|'writer'
op|'.'
name|'_extension'
op|'='
string|"'.meta'"
newline|'\n'
name|'writer'
op|'.'
name|'put'
op|'('
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete
dedent|''
dedent|''
name|'def'
name|'delete'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delete the object.\n\n        This implementation creates a tombstone file using the given\n        timestamp, and removes any older versions of the object file. Any\n        file that has an older timestamp than timestamp will be deleted.\n\n        .. note::\n\n            An implementation is free to use or ignore the timestamp\n            parameter.\n\n        :param timestamp: timestamp to compare with each file\n        :raises DiskFileError: this implementation will raise the same\n                            errors as the `create()` method.\n        """'
newline|'\n'
comment|'# this is dumb, only tests send in strings'
nl|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
name|'as'
name|'deleter'
op|':'
newline|'\n'
indent|'            '
name|'deleter'
op|'.'
name|'_extension'
op|'='
string|"'.ts'"
newline|'\n'
name|'deleter'
op|'.'
name|'put'
op|'('
op|'{'
string|"'X-Timestamp'"
op|':'
name|'timestamp'
op|'.'
name|'internal'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO: move DiskFileManager definition down here'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'DiskFileManager'
op|'.'
name|'diskfile_cls'
op|'='
name|'DiskFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFileReader
name|'class'
name|'ECDiskFileReader'
op|'('
name|'DiskFileReader'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFileWriter
dedent|''
name|'class'
name|'ECDiskFileWriter'
op|'('
name|'DiskFileWriter'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|_finalize_durable
indent|'    '
name|'def'
name|'_finalize_durable'
op|'('
name|'self'
op|','
name|'durable_file_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exc'
op|'='
name|'msg'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'durable_file_path'
op|','
string|"'w'"
op|')'
name|'as'
name|'_fp'
op|':'
newline|'\n'
indent|'                '
name|'fsync'
op|'('
name|'_fp'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'hash_cleanup_listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Problem cleaning up %s'"
op|')'
op|','
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Problem fsyncing durable state file: %s'"
op|')'
op|','
nl|'\n'
name|'durable_file_path'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'DiskFileError'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
name|'as'
name|'io_err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'io_err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOSPC'
op|','
name|'errno'
op|'.'
name|'EDQUOT'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"No space left on device for %s"'
op|')'
op|','
nl|'\n'
name|'durable_file_path'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'DiskFileNoSpace'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Problem writing durable state file: %s'"
op|')'
op|','
nl|'\n'
name|'durable_file_path'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'DiskFileError'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'manager'
op|'.'
name|'logger'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exc'
newline|'\n'
nl|'\n'
DECL|member|commit
dedent|''
dedent|''
name|'def'
name|'commit'
op|'('
name|'self'
op|','
name|'timestamp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Finalize put by writing a timestamp.durable file for the object. We\n        do this for EC policy because it requires a 2-phase put commit\n        confirmation.\n\n        :param timestamp: object put timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        """'
newline|'\n'
name|'durable_file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_datadir'
op|','
name|'timestamp'
op|'.'
name|'internal'
op|'+'
string|"'.durable'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_durable'
op|','
name|'durable_file_path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|put
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference between this method and the replication policy\n        DiskFileWriter method is the call into manager.make_on_disk_filename\n        to construct the data file name.\n        """'
newline|'\n'
name|'timestamp'
op|'='
name|'Timestamp'
op|'('
name|'metadata'
op|'['
string|"'X-Timestamp'"
op|']'
op|')'
newline|'\n'
name|'fi'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_extension'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# generally we treat the fragment index provided in metadata as'
nl|'\n'
comment|"# canon, but if it's unavailable (e.g. tests) it's reasonable to"
nl|'\n'
comment|'# use the frag_index provided at instantiation. Either way make'
nl|'\n'
comment|'# sure that the fragment index is included in object sysmeta.'
nl|'\n'
indent|'            '
name|'fi'
op|'='
name|'metadata'
op|'.'
name|'setdefault'
op|'('
string|"'X-Object-Sysmeta-Ec-Frag-Index'"
op|','
nl|'\n'
name|'self'
op|'.'
name|'_diskfile'
op|'.'
name|'_frag_index'
op|')'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'make_on_disk_filename'
op|'('
nl|'\n'
name|'timestamp'
op|','
name|'self'
op|'.'
name|'_extension'
op|','
name|'frag_index'
op|'='
name|'fi'
op|')'
newline|'\n'
name|'metadata'
op|'['
string|"'name'"
op|']'
op|'='
name|'self'
op|'.'
name|'_name'
newline|'\n'
name|'target_path'
op|'='
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'filename'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_threadpool'
op|'.'
name|'force_run_in_thread'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_finalize_put'
op|','
name|'metadata'
op|','
name|'target_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ECDiskFile
dedent|''
dedent|''
name|'class'
name|'ECDiskFile'
op|'('
name|'DiskFile'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|reader_cls
indent|'    '
name|'reader_cls'
op|'='
name|'ECDiskFileReader'
newline|'\n'
DECL|variable|writer_cls
name|'writer_cls'
op|'='
name|'ECDiskFileWriter'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'ECDiskFile'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'frag_index'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'frag_index'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_frag_index'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'frag_index'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_frag_index'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_ondisk_file
dedent|''
dedent|''
name|'def'
name|'_get_ondisk_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference between this method and the replication policy\n        DiskFile method is passing in the frag_index kwarg to our manager\'s\n        get_ondisk_files method.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'files'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
comment|"# If there's a file here instead of a directory, quarantine"
nl|'\n'
comment|"# it; something's gone wrong somewhere."
nl|'\n'
indent|'                '
name|'raise'
name|'self'
op|'.'
name|'_quarantine'
op|'('
nl|'\n'
comment|'# hack: quarantine_renamer actually renames the directory'
nl|'\n'
comment|'# enclosing the filename you give it, but here we just'
nl|'\n'
comment|'# want this one file and not its parent.'
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
string|'"made-up-filename"'
op|')'
op|','
nl|'\n'
string|'"Expected directory, found file at %s"'
op|'%'
name|'self'
op|'.'
name|'_datadir'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|'"Error listing directory %s: %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
comment|'# The data directory does not exist, so the object cannot exist.'
nl|'\n'
dedent|''
name|'fileset'
op|'='
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'fileset'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'get_ondisk_files'
op|'('
nl|'\n'
name|'files'
op|','
name|'self'
op|'.'
name|'_datadir'
op|','
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'_frag_index'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'fileset'
newline|'\n'
nl|'\n'
DECL|member|purge
dedent|''
name|'def'
name|'purge'
op|'('
name|'self'
op|','
name|'timestamp'
op|','
name|'frag_index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a tombstone file matching the specified timestamp or\n        datafile matching the specified timestamp and fragment index\n        from the object directory.\n\n        This provides the EC reconstructor/ssync process with a way to\n        remove a tombstone or fragment from a handoff node after\n        reverting it to its primary node.\n\n        The hash will be invalidated, and if empty or invalid the\n        hsh_path will be removed on next hash_cleanup_listdir.\n\n        :param timestamp: the object timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        :param frag_index: a fragment archive index, must be a whole number.\n        """'
newline|'\n'
name|'for'
name|'ext'
name|'in'
op|'('
string|"'.data'"
op|','
string|"'.ts'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'purge_file'
op|'='
name|'self'
op|'.'
name|'manager'
op|'.'
name|'make_on_disk_filename'
op|'('
nl|'\n'
name|'timestamp'
op|','
name|'ext'
op|'='
name|'ext'
op|','
name|'frag_index'
op|'='
name|'frag_index'
op|')'
newline|'\n'
name|'remove_file'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|','
name|'purge_file'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'manager'
op|'.'
name|'invalidate_hash'
op|'('
name|'dirname'
op|'('
name|'self'
op|'.'
name|'_datadir'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'DiskFileRouter'
op|'.'
name|'register'
op|'('
name|'EC_POLICY'
op|')'
newline|'\n'
DECL|class|ECDiskFileManager
name|'class'
name|'ECDiskFileManager'
op|'('
name|'DiskFileManager'
op|')'
op|':'
newline|'\n'
DECL|variable|diskfile_cls
indent|'    '
name|'diskfile_cls'
op|'='
name|'ECDiskFile'
newline|'\n'
nl|'\n'
DECL|member|validate_fragment_index
name|'def'
name|'validate_fragment_index'
op|'('
name|'self'
op|','
name|'frag_index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return int representation of frag_index, or raise a DiskFileError if\n        frag_index is not a whole number.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'frag_index'
op|'='
name|'int'
op|'('
name|'str'
op|'('
name|'frag_index'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'TypeError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|"'Bad fragment index: %s: %s'"
op|'%'
op|'('
name|'frag_index'
op|','
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'frag_index'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileError'
op|'('
nl|'\n'
string|"'Fragment index must not be negative: %s'"
op|'%'
name|'frag_index'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'frag_index'
newline|'\n'
nl|'\n'
DECL|member|make_on_disk_filename
dedent|''
name|'def'
name|'make_on_disk_filename'
op|'('
name|'self'
op|','
name|'timestamp'
op|','
name|'ext'
op|'='
name|'None'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
nl|'\n'
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the EC specific filename for given timestamp.\n\n        :param timestamp: the object timestamp, an instance of\n                          :class:`~swift.common.utils.Timestamp`\n        :param ext: an optional string representing a file extension to be\n                    appended to the returned file name\n        :param frag_index: a fragment archive index, used with .data extension\n                           only, must be a whole number.\n        :returns: a file name\n        :raises DiskFileError: if ext==\'.data\' and the kwarg frag_index is not\n                               a whole number\n        """'
newline|'\n'
name|'rv'
op|'='
name|'timestamp'
op|'.'
name|'internal'
newline|'\n'
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# for datafiles only we encode the fragment index in the filename'
nl|'\n'
comment|'# to allow archives of different indexes to temporarily be stored'
nl|'\n'
comment|'# on the same node in certain situations'
nl|'\n'
indent|'            '
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
name|'rv'
op|'+='
string|"'#'"
op|'+'
name|'str'
op|'('
name|'frag_index'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'ext'
op|':'
newline|'\n'
indent|'            '
name|'rv'
op|'='
string|"'%s%s'"
op|'%'
op|'('
name|'rv'
op|','
name|'ext'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'rv'
newline|'\n'
nl|'\n'
DECL|member|parse_on_disk_filename
dedent|''
name|'def'
name|'parse_on_disk_filename'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the timestamp extracted from a policy specific .data file name.\n        For EC policy the data file name includes a fragment index which must\n        be stripped off to retrieve the timestamp.\n\n        :param filename: the data file name including extension\n        :returns: a dict, with keys for timestamp, frag_index, and ext::\n\n            * timestamp is a :class:`~swift.common.utils.Timestamp`\n            * frag_index is an int or None\n            * ext is a string, the file extension including the leading dot or\n              the empty string if the filename has no extenstion.\n\n        :raises DiskFileError: if any part of the filename is not able to be\n                               validated.\n        """'
newline|'\n'
name|'frag_index'
op|'='
name|'None'
newline|'\n'
name|'filename'
op|','
name|'ext'
op|'='
name|'splitext'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'parts'
op|'='
name|'filename'
op|'.'
name|'split'
op|'('
string|"'#'"
op|','
number|'1'
op|')'
newline|'\n'
name|'timestamp'
op|'='
name|'parts'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# it is an error for an EC data file to not have a valid'
nl|'\n'
comment|'# fragment index'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'frag_index'
op|'='
name|'parts'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|'# expect validate_fragment_index raise DiskFileError'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'frag_index'
op|'='
name|'self'
op|'.'
name|'validate_fragment_index'
op|'('
name|'frag_index'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'{'
nl|'\n'
string|"'timestamp'"
op|':'
name|'Timestamp'
op|'('
name|'timestamp'
op|')'
op|','
nl|'\n'
string|"'frag_index'"
op|':'
name|'frag_index'
op|','
nl|'\n'
string|"'ext'"
op|':'
name|'ext'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|is_obsolete
dedent|''
name|'def'
name|'is_obsolete'
op|'('
name|'self'
op|','
name|'filename'
op|','
name|'other_filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test if a given file is considered to be obsolete with respect to\n        another file in an object storage dir.\n\n        Implements EC policy specific behavior when comparing files against a\n        .durable file.\n\n        A simple string comparison would consider t2#1.data to be older than\n        t2.durable (since t2#1.data < t2.durable). By stripping off the file\n        extensions we get the desired behavior: t2#1 > t2 without compromising\n        the detection of t1#1 < t2.\n\n        :param filename: a string representing an absolute filename\n        :param other_filename: a string representing an absolute filename\n        :returns: True if filename is considered obsolete, False otherwise.\n        """'
newline|'\n'
name|'if'
name|'other_filename'
op|'.'
name|'endswith'
op|'('
string|"'.durable'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'splitext'
op|'('
name|'filename'
op|')'
op|'['
number|'0'
op|']'
op|'<'
name|'splitext'
op|'('
name|'other_filename'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'filename'
op|'<'
name|'other_filename'
newline|'\n'
nl|'\n'
DECL|member|_gather_on_disk_file
dedent|''
name|'def'
name|'_gather_on_disk_file'
op|'('
name|'self'
op|','
name|'filename'
op|','
name|'ext'
op|','
name|'context'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by gather_ondisk_files() for each file in an object\n        datadir in reverse sorted order. If a file is considered part of a\n        valid on-disk file set it will be added to the context dict, keyed by\n        its extension. If a file is considered to be obsolete it will be added\n        to a list stored under the key \'obsolete\' in the context dict.\n\n        :param filename: name of file to be accepted or not\n        :param ext: extension part of filename\n        :param context: a context dict that may have been populated by previous\n                        calls to this method\n        :param frag_index: if set, search for a specific fragment index .data\n                           file, otherwise accept the first valid .data file.\n        :returns: True if a valid file set has been found, False otherwise\n        """'
newline|'\n'
nl|'\n'
comment|'# if first file with given extension then add filename to context'
nl|'\n'
comment|'# dict and return True'
nl|'\n'
name|'accept_first'
op|'='
name|'lambda'
op|':'
name|'context'
op|'.'
name|'setdefault'
op|'('
name|'ext'
op|','
name|'filename'
op|')'
op|'=='
name|'filename'
newline|'\n'
comment|'# add the filename to the list of obsolete files in context dict'
nl|'\n'
name|'discard'
op|'='
name|'lambda'
op|':'
name|'context'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'filename'
op|')'
newline|'\n'
comment|'# set a flag in the context dict indicating that a valid fileset has'
nl|'\n'
comment|'# been found'
nl|'\n'
name|'set_valid_fileset'
op|'='
name|'lambda'
op|':'
name|'context'
op|'.'
name|'setdefault'
op|'('
string|"'found_valid'"
op|','
name|'True'
op|')'
newline|'\n'
comment|'# return True if the valid fileset flag is set in the context dict'
nl|'\n'
name|'have_valid_fileset'
op|'='
name|'lambda'
op|':'
name|'context'
op|'.'
name|'get'
op|'('
string|"'found_valid'"
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'context'
op|'.'
name|'get'
op|'('
string|"'.durable'"
op|')'
op|':'
newline|'\n'
comment|'# a .durable file has been found'
nl|'\n'
indent|'            '
name|'if'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'is_obsolete'
op|'('
name|'filename'
op|','
name|'context'
op|'.'
name|'get'
op|'('
string|"'.durable'"
op|')'
op|')'
op|':'
newline|'\n'
comment|'# this and remaining data files are older than durable'
nl|'\n'
indent|'                    '
name|'discard'
op|'('
op|')'
newline|'\n'
name|'set_valid_fileset'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# accept the first .data file if it matches requested'
nl|'\n'
comment|'# frag_index, or if no specific frag_index is requested'
nl|'\n'
indent|'                    '
name|'fi'
op|'='
name|'self'
op|'.'
name|'parse_on_disk_filename'
op|'('
name|'filename'
op|')'
op|'['
string|"'frag_index'"
op|']'
newline|'\n'
name|'if'
name|'frag_index'
name|'is'
name|'None'
name|'or'
name|'frag_index'
op|'=='
name|'int'
op|'('
name|'fi'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'accept_first'
op|'('
op|')'
newline|'\n'
name|'set_valid_fileset'
op|'('
op|')'
newline|'\n'
comment|'# else: keep searching for a .data file to match frag_index'
nl|'\n'
dedent|''
name|'context'
op|'.'
name|'setdefault'
op|'('
string|"'fragments'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# there can no longer be a matching .data file so mark what has'
nl|'\n'
comment|'# been found so far as the valid fileset'
nl|'\n'
indent|'                '
name|'discard'
op|'('
op|')'
newline|'\n'
name|'set_valid_fileset'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'ext'
op|'=='
string|"'.data'"
op|':'
newline|'\n'
comment|'# not yet found a .durable'
nl|'\n'
indent|'            '
name|'if'
name|'have_valid_fileset'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# valid fileset means we must have a newer'
nl|'\n'
comment|'# .ts, so discard the older .data file'
nl|'\n'
indent|'                '
name|'discard'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# .data newer than a .durable or .ts, don't discard yet"
nl|'\n'
indent|'                '
name|'context'
op|'.'
name|'setdefault'
op|'('
string|"'fragments_without_durable'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
nl|'\n'
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'ext'
op|'=='
string|"'.ts'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'have_valid_fileset'
op|'('
op|')'
name|'or'
name|'not'
name|'accept_first'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# newer .data, .durable or .ts already found so discard this'
nl|'\n'
indent|'                '
name|'discard'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'have_valid_fileset'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# remove any .meta that may have been previously found'
nl|'\n'
indent|'                '
name|'context'
op|'['
string|"'.meta'"
op|']'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'set_valid_fileset'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'ext'
name|'in'
op|'('
string|"'.meta'"
op|','
string|"'.durable'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'have_valid_fileset'
op|'('
op|')'
name|'or'
name|'not'
name|'accept_first'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# newer .data, .durable or .ts already found so discard this'
nl|'\n'
indent|'                '
name|'discard'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# ignore unexpected files'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'have_valid_fileset'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_verify_on_disk_files
dedent|''
name|'def'
name|'_verify_on_disk_files'
op|'('
name|'self'
op|','
name|'accepted_files'
op|','
name|'frag_index'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the final combination of on disk files complies with the\n        diskfile contract.\n\n        :param accepted_files: files that have been found and accepted\n        :param frag_index: specifies a specific fragment index .data file\n        :returns: True if the file combination is compliant, False otherwise\n        """'
newline|'\n'
name|'if'
name|'not'
name|'accepted_files'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
op|':'
newline|'\n'
comment|"# We may find only a .meta, which doesn't mean the on disk"
nl|'\n'
comment|'# contract is broken. So we clear it to comply with'
nl|'\n'
comment|'# superclass assertions.'
nl|'\n'
indent|'            '
name|'accepted_files'
op|'['
string|"'.meta'"
op|']'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'data_file'
op|','
name|'meta_file'
op|','
name|'ts_file'
op|','
name|'durable_file'
op|'='
name|'tuple'
op|'('
nl|'\n'
op|'['
name|'accepted_files'
op|'.'
name|'get'
op|'('
name|'ext'
op|')'
nl|'\n'
name|'for'
name|'ext'
name|'in'
op|'('
string|"'.data'"
op|','
string|"'.meta'"
op|','
string|"'.ts'"
op|','
string|"'.durable'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'('
op|'('
name|'data_file'
name|'is'
name|'None'
name|'or'
name|'durable_file'
name|'is'
name|'not'
name|'None'
op|')'
nl|'\n'
name|'and'
op|'('
name|'data_file'
name|'is'
name|'None'
name|'and'
name|'meta_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'ts_file'
name|'is'
name|'None'
name|'and'
name|'durable_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'ts_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'data_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'meta_file'
name|'is'
name|'None'
name|'and'
name|'durable_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'data_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'durable_file'
name|'is'
name|'not'
name|'None'
nl|'\n'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
nl|'\n'
name|'or'
op|'('
name|'durable_file'
name|'is'
name|'not'
name|'None'
name|'and'
name|'meta_file'
name|'is'
name|'None'
nl|'\n'
name|'and'
name|'ts_file'
name|'is'
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gather_ondisk_files
dedent|''
name|'def'
name|'gather_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|','
name|'include_obsolete'
op|'='
name|'False'
op|','
nl|'\n'
name|'frag_index'
op|'='
name|'None'
op|','
name|'verify'
op|'='
name|'False'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a simple list of files names, iterate over them to determine the\n        files that constitute a valid object, and optionally determine the\n        files that are obsolete and could be deleted. Note that some files may\n        fall into neither category.\n\n        :param files: a list of file names.\n        :param include_obsolete: By default the iteration will stop when a\n                                 valid file set has been found. Setting this\n                                 argument to True will cause the iteration to\n                                 continue in order to find all obsolete files.\n        :param frag_index: if set, search for a specific fragment index .data\n                           file, otherwise accept the first valid .data file.\n        :returns: a dict that may contain: valid on disk files keyed by their\n                  filename extension; a list of obsolete files stored under the\n                  key \'obsolete\'.\n        """'
newline|'\n'
comment|'# This visitor pattern enables future refactoring of other disk'
nl|'\n'
comment|'# manager implementations to re-use this method and override'
nl|'\n'
comment|'# _gather_ondisk_file and _verify_ondisk_files to apply implementation'
nl|'\n'
comment|'# specific selection and verification of on-disk files.'
nl|'\n'
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'results'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'afile'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'ts_file'
op|'='
name|'results'
op|'.'
name|'get'
op|'('
string|"'.ts'"
op|')'
newline|'\n'
name|'data_file'
op|'='
name|'results'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'include_obsolete'
op|':'
newline|'\n'
indent|'                '
name|'assert'
name|'ts_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after tombstone, %s, encountered"'
op|'%'
name|'ts_file'
newline|'\n'
name|'assert'
name|'data_file'
name|'is'
name|'None'
op|','
string|'"On-disk file search loop"'
string|'" continuing after data file, %s, encountered"'
op|'%'
name|'data_file'
newline|'\n'
nl|'\n'
dedent|''
name|'ext'
op|'='
name|'splitext'
op|'('
name|'afile'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_gather_on_disk_file'
op|'('
nl|'\n'
name|'afile'
op|','
name|'ext'
op|','
name|'results'
op|','
name|'frag_index'
op|'='
name|'frag_index'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'include_obsolete'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'verify'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'self'
op|'.'
name|'_verify_on_disk_files'
op|'('
nl|'\n'
name|'results'
op|','
name|'frag_index'
op|'='
name|'frag_index'
op|','
op|'**'
name|'kwargs'
op|')'
op|','
string|'"On-disk file search algorithm contract is broken: %s"'
op|'%'
name|'results'
op|'.'
name|'values'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'results'
newline|'\n'
nl|'\n'
DECL|member|get_ondisk_files
dedent|''
name|'def'
name|'get_ondisk_files'
op|'('
name|'self'
op|','
name|'files'
op|','
name|'datadir'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a simple list of files names, determine the files to use.\n\n        :param files: simple set of files as a python list\n        :param datadir: directory name files are from for convenience\n        :returns: a tuple of data, meta, and tombstone\n        """'
newline|'\n'
comment|"# maintain compatibility with 'legacy' get_ondisk_files return value"
nl|'\n'
name|'accepted_files'
op|'='
name|'self'
op|'.'
name|'gather_ondisk_files'
op|'('
name|'files'
op|','
name|'verify'
op|'='
name|'True'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'result'
op|'='
op|'['
op|'('
name|'join'
op|'('
name|'datadir'
op|','
name|'accepted_files'
op|'.'
name|'get'
op|'('
name|'ext'
op|')'
op|')'
nl|'\n'
name|'if'
name|'accepted_files'
op|'.'
name|'get'
op|'('
name|'ext'
op|')'
name|'else'
name|'None'
op|')'
nl|'\n'
name|'for'
name|'ext'
name|'in'
op|'('
string|"'.data'"
op|','
string|"'.meta'"
op|','
string|"'.ts'"
op|')'
op|']'
newline|'\n'
name|'return'
name|'tuple'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
DECL|member|cleanup_ondisk_files
dedent|''
name|'def'
name|'cleanup_ondisk_files'
op|'('
name|'self'
op|','
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|','
nl|'\n'
name|'frag_index'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Clean up on-disk files that are obsolete and gather the set of valid\n        on-disk files for an object.\n\n        :param hsh_path: object hash path\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :param frag_index: if set, search for a specific fragment index .data\n                           file, otherwise accept the first valid .data file\n        :returns: a dict that may contain: valid on disk files keyed by their\n                  filename extension; a list of obsolete files stored under the\n                  key \'obsolete\'; a list of files remaining in the directory,\n                  reverse sorted, stored under the key \'files\'.\n        """'
newline|'\n'
DECL|function|is_reclaimable
name|'def'
name|'is_reclaimable'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'timestamp'
op|'='
name|'self'
op|'.'
name|'parse_on_disk_filename'
op|'('
name|'filename'
op|')'
op|'['
string|"'timestamp'"
op|']'
newline|'\n'
name|'return'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'float'
op|'('
name|'timestamp'
op|')'
op|')'
op|'>'
name|'reclaim_age'
newline|'\n'
nl|'\n'
dedent|''
name|'files'
op|'='
name|'listdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
name|'results'
op|'='
name|'self'
op|'.'
name|'gather_ondisk_files'
op|'('
name|'files'
op|','
name|'include_obsolete'
op|'='
name|'True'
op|','
nl|'\n'
name|'frag_index'
op|'='
name|'frag_index'
op|')'
newline|'\n'
name|'if'
string|"'.durable'"
name|'in'
name|'results'
name|'and'
name|'not'
name|'results'
op|'.'
name|'get'
op|'('
string|"'fragments'"
op|')'
op|':'
newline|'\n'
comment|'# a .durable with no .data is deleted as soon as it is found'
nl|'\n'
indent|'            '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'results'
op|'.'
name|'pop'
op|'('
string|"'.durable'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'.ts'"
name|'in'
name|'results'
name|'and'
name|'is_reclaimable'
op|'('
name|'results'
op|'['
string|"'.ts'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'results'
op|'.'
name|'pop'
op|'('
string|"'.ts'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'filename'
name|'in'
name|'results'
op|'.'
name|'get'
op|'('
string|"'fragments_without_durable'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
comment|'# stray fragments are not deleted until reclaim-age'
nl|'\n'
indent|'            '
name|'if'
name|'is_reclaimable'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'results'
op|'.'
name|'setdefault'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'filename'
name|'in'
name|'results'
op|'.'
name|'get'
op|'('
string|"'obsolete'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'remove_file'
op|'('
name|'join'
op|'('
name|'hsh_path'
op|','
name|'filename'
op|')'
op|')'
newline|'\n'
name|'files'
op|'.'
name|'remove'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
name|'results'
op|'['
string|"'files'"
op|']'
op|'='
name|'files'
newline|'\n'
name|'return'
name|'results'
newline|'\n'
nl|'\n'
DECL|member|hash_cleanup_listdir
dedent|''
name|'def'
name|'hash_cleanup_listdir'
op|'('
name|'self'
op|','
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'ONE_WEEK'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        List contents of a hash directory and clean up any old files.\n        For EC policy, delete files older than a .durable or .ts file.\n\n        :param hsh_path: object hash path\n        :param reclaim_age: age in seconds at which to remove tombstones\n        :returns: list of files remaining in the directory, reverse sorted\n        """'
newline|'\n'
comment|"# maintain compatibility with 'legacy' hash_cleanup_listdir"
nl|'\n'
comment|'# return value'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'cleanup_ondisk_files'
op|'('
nl|'\n'
name|'hsh_path'
op|','
name|'reclaim_age'
op|'='
name|'reclaim_age'
op|')'
op|'['
string|"'files'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|yield_hashes
dedent|''
name|'def'
name|'yield_hashes'
op|'('
name|'self'
op|','
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|','
nl|'\n'
name|'suffixes'
op|'='
name|'None'
op|','
name|'frag_index'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is the same as the replicated yield_hashes except when frag_index\n        is provided data files for fragment indexes not matching the given\n        frag_index are skipped.\n        """'
newline|'\n'
name|'dev_path'
op|'='
name|'self'
op|'.'
name|'get_dev_path'
op|'('
name|'device'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dev_path'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DiskFileDeviceUnavailable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'suffixes'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'suffixes'
op|'='
name|'self'
op|'.'
name|'yield_suffixes'
op|'('
name|'device'
op|','
name|'partition'
op|','
name|'policy'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'partition_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dev_path'
op|','
nl|'\n'
name|'get_data_dir'
op|'('
name|'policy'
op|')'
op|','
nl|'\n'
name|'str'
op|'('
name|'partition'
op|')'
op|')'
newline|'\n'
name|'suffixes'
op|'='
op|'('
nl|'\n'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
op|','
name|'suffix'
op|')'
nl|'\n'
name|'for'
name|'suffix'
name|'in'
name|'suffixes'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'suffix_path'
op|','
name|'suffix'
name|'in'
name|'suffixes'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'object_hash'
name|'in'
name|'self'
op|'.'
name|'_listdir'
op|'('
name|'suffix_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'object_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'suffix_path'
op|','
name|'object_hash'
op|')'
newline|'\n'
name|'newest_valid_file'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'results'
op|'='
name|'self'
op|'.'
name|'cleanup_ondisk_files'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'self'
op|'.'
name|'reclaim_age'
op|','
name|'frag_index'
op|'='
name|'frag_index'
op|')'
newline|'\n'
name|'newest_valid_file'
op|'='
op|'('
name|'results'
op|'.'
name|'get'
op|'('
string|"'.meta'"
op|')'
nl|'\n'
name|'or'
name|'results'
op|'.'
name|'get'
op|'('
string|"'.data'"
op|')'
nl|'\n'
name|'or'
name|'results'
op|'.'
name|'get'
op|'('
string|"'.ts'"
op|')'
op|')'
newline|'\n'
name|'if'
name|'newest_valid_file'
op|':'
newline|'\n'
indent|'                        '
name|'timestamp'
op|'='
name|'self'
op|'.'
name|'parse_on_disk_filename'
op|'('
nl|'\n'
name|'newest_valid_file'
op|')'
op|'['
string|"'timestamp'"
op|']'
newline|'\n'
name|'yield'
op|'('
name|'object_path'
op|','
name|'object_hash'
op|','
name|'timestamp'
op|'.'
name|'internal'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'AssertionError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
string|"'Invalid file set in %s (%s)'"
op|'%'
op|'('
nl|'\n'
name|'object_path'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'DiskFileError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'logger'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|"'Invalid diskfile filename %r in %r (%s)'"
op|'%'
op|'('
nl|'\n'
name|'newest_valid_file'
op|','
name|'object_path'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_hash_suffix
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_hash_suffix'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'reclaim_age'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference between this method and the module level function\n        hash_suffix is the way that files are updated on the returned hash.\n\n        Instead of all filenames hashed into a single hasher, each file name\n        will fall into a bucket either by fragment index for datafiles, or\n        None (indicating a durable, metadata or tombstone).\n        """'
newline|'\n'
comment|'# hash_per_fi instead of single hash for whole suffix'
nl|'\n'
name|'hash_per_fi'
op|'='
name|'defaultdict'
op|'('
name|'hashlib'
op|'.'
name|'md5'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'path_contents'
op|'='
name|'sorted'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'err'
op|'.'
name|'errno'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOTDIR'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'PathNotDir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'for'
name|'hsh'
name|'in'
name|'path_contents'
op|':'
newline|'\n'
indent|'            '
name|'hsh_path'
op|'='
name|'join'
op|'('
name|'path'
op|','
name|'hsh'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'files'
op|'='
name|'self'
op|'.'
name|'hash_cleanup_listdir'
op|'('
name|'hsh_path'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'err'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'err'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTDIR'
op|':'
newline|'\n'
indent|'                    '
name|'partition_path'
op|'='
name|'dirname'
op|'('
name|'path'
op|')'
newline|'\n'
name|'objects_path'
op|'='
name|'dirname'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'device_path'
op|'='
name|'dirname'
op|'('
name|'objects_path'
op|')'
newline|'\n'
name|'quar_path'
op|'='
name|'quarantine_renamer'
op|'('
name|'device_path'
op|','
name|'hsh_path'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'exception'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Quarantined %(hsh_path)s to %(quar_path)s because '"
nl|'\n'
string|"'it is not a directory'"
op|')'
op|','
op|'{'
string|"'hsh_path'"
op|':'
name|'hsh_path'
op|','
nl|'\n'
string|"'quar_path'"
op|':'
name|'quar_path'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'files'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'hsh_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
comment|'# we just deleted this hsh_path, why are we waiting'
nl|'\n'
comment|'# until the next suffix hash to raise PathNotDir so that'
nl|'\n'
comment|"# this suffix will get del'd from the suffix hashes?"
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'filename'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'                '
name|'info'
op|'='
name|'self'
op|'.'
name|'parse_on_disk_filename'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'fi'
op|'='
name|'info'
op|'['
string|"'frag_index'"
op|']'
newline|'\n'
name|'if'
name|'fi'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'hash_per_fi'
op|'['
name|'fi'
op|']'
op|'.'
name|'update'
op|'('
name|'filename'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'hash_per_fi'
op|'['
name|'fi'
op|']'
op|'.'
name|'update'
op|'('
name|'info'
op|'['
string|"'timestamp'"
op|']'
op|'.'
name|'internal'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# here we flatten out the hashers hexdigest into a dictionary instead'
nl|'\n'
comment|'# of just returning the one hexdigest for the whole suffix'
nl|'\n'
dedent|''
name|'return'
name|'dict'
op|'('
op|'('
name|'fi'
op|','
name|'md5'
op|'.'
name|'hexdigest'
op|'('
op|')'
op|')'
name|'for'
name|'fi'
op|','
name|'md5'
name|'in'
name|'hash_per_fi'
op|'.'
name|'items'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_hashes
dedent|''
name|'def'
name|'_get_hashes'
op|'('
name|'self'
op|','
name|'partition_path'
op|','
name|'recalculate'
op|'='
name|'None'
op|','
name|'do_listdir'
op|'='
name|'False'
op|','
nl|'\n'
name|'reclaim_age'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only difference with this method and the module level function\n        get_hashes is the call to hash_suffix routes to a method _hash_suffix\n        on this instance.\n        """'
newline|'\n'
name|'reclaim_age'
op|'='
name|'reclaim_age'
name|'or'
name|'self'
op|'.'
name|'reclaim_age'
newline|'\n'
name|'hashed'
op|'='
number|'0'
newline|'\n'
name|'hashes_file'
op|'='
name|'join'
op|'('
name|'partition_path'
op|','
name|'HASH_FILE'
op|')'
newline|'\n'
name|'modified'
op|'='
name|'False'
newline|'\n'
name|'force_rewrite'
op|'='
name|'False'
newline|'\n'
name|'hashes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'mtime'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'recalculate'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'recalculate'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'hashes_file'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                '
name|'hashes'
op|'='
name|'pickle'
op|'.'
name|'load'
op|'('
name|'fp'
op|')'
newline|'\n'
dedent|''
name|'mtime'
op|'='
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'do_listdir'
op|'='
name|'True'
newline|'\n'
name|'force_rewrite'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'if'
name|'do_listdir'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'suff'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'suff'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                    '
name|'hashes'
op|'.'
name|'setdefault'
op|'('
name|'suff'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'hashes'
op|'.'
name|'update'
op|'('
op|'('
name|'suffix'
op|','
name|'None'
op|')'
name|'for'
name|'suffix'
name|'in'
name|'recalculate'
op|')'
newline|'\n'
name|'for'
name|'suffix'
op|','
name|'hash_'
name|'in'
name|'hashes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'hash_'
op|':'
newline|'\n'
indent|'                '
name|'suffix_dir'
op|'='
name|'join'
op|'('
name|'partition_path'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'hashes'
op|'['
name|'suffix'
op|']'
op|'='
name|'self'
op|'.'
name|'_hash_suffix'
op|'('
name|'suffix_dir'
op|','
name|'reclaim_age'
op|')'
newline|'\n'
name|'hashed'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'except'
name|'PathNotDir'
op|':'
newline|'\n'
indent|'                    '
name|'del'
name|'hashes'
op|'['
name|'suffix'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                    '
name|'logging'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Error hashing suffix'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'modified'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'modified'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'lock_path'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'force_rewrite'
name|'or'
name|'not'
name|'exists'
op|'('
name|'hashes_file'
op|')'
name|'or'
name|'getmtime'
op|'('
name|'hashes_file'
op|')'
op|'=='
name|'mtime'
op|':'
newline|'\n'
indent|'                    '
name|'write_pickle'
op|'('
nl|'\n'
name|'hashes'
op|','
name|'hashes_file'
op|','
name|'partition_path'
op|','
name|'PICKLE_PROTOCOL'
op|')'
newline|'\n'
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_get_hashes'
op|'('
name|'partition_path'
op|','
name|'recalculate'
op|','
name|'do_listdir'
op|','
nl|'\n'
name|'reclaim_age'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'hashed'
op|','
name|'hashes'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
